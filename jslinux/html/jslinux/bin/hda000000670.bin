uld
     assign X (which will always be a C variable) a new value.

     It is not necessary for this macro to come up with a legitimate
     address.  The compiler has standard ways of doing so in all cases.
     In fact, it is safe to omit this macro.  But often a
     machine-dependent strategy can generate better code.

 -- Macro: LEGITIMIZE_RELOAD_ADDRESS (X, MODE, OPNUM, TYPE, IND_LEVELS,
          WIN)
     A C compound statement that attempts to replace X, which is an
     address that needs reloading, with a valid memory address for an
     operand of mode MODE.  WIN will be a C statement label elsewhere
     in the code.  It is not necessary to define this macro, but it
     might be useful for performance reasons.

     For example, on the i386, it is sometimes possible to use a single
     reload register instead of two by reloading a sum of two pseudo
     registers into a register.  On the other hand, for number of RISC
     processors offsets are limited so that often an intermediate
     address needs to be generated in order to address a stack slot.
     By defining `LEGITIMIZE_RELOAD_ADDRESS' appropriately, the
     intermediate addresses generated for adjacent some stack slots can
     be made identical, and thus be shared.

     _Note_: This macro should be used with caution.  It is necessary
     to know something of how reload works in order to effectively use
     this, and it is quite easy to produce macros that build in too
     much knowledge of reload internals.

     _Note_: This macro must be able to reload an address created by a
     previous invocation of this macro.  If it fails to handle such
     addresses then the compiler may generate incorrect code or abort.

     The macro definition should use `push_reload' to indicate parts
     that need reloading; OPNUM, TYPE and IND_LEVELS are usually
     suitable to be passed unaltered to `push_reload'.

     The code generated by this macro must not alter the substructure of
     X.  If it transforms X into a more legitimate form, it should
     assign X (which will always be a C variable) a new value.  This
     also applies to parts that you change indirectly by calling
     `push_reload'.

     The macro definition may use `strict_memory_address_p' to test if
     the address has become legitimate.

     If you want to change only a part of X, one standard way of doing
     this is to use `copy_rtx'.  Note, however, that it unshares only a
     single level of rtl.  Thus, if the part to be changed is not at the
     top level, you'll need to replace first the top level.  It is not
     necessary for this macro to come up with a legitimate address;
     but often a machine-dependent strategy can generate better code.

 -- Macro: GO_IF_MODE_DEPENDENT_ADDRESS (ADDR, LABEL)
     A C statement or compound statement with a conditional `goto
     LABEL;' executed if memory address X (an RTX) can have different
     meanings depending on the machine mode of the memory reference it
     is used for or if the address is valid for some modes but not
     others.

     Autoincrement and autodecrement addresses typically have
     mode-dependent effects because the amount of the increment or
     decrement is the size of the operand being addressed.  Some
     machines have other mode-dependent addresses.  Many RISC machines
     have no mode-dependent addresses.

     You may assume that ADDR is a valid address for the machine.

 -- Macro: LEGITIMATE_CONSTANT_P (X)
     A C expression that is nonzero if X is a legitimate constant for
     an immediate operand on the target machine.  You can assume that X
     satisfies `CONSTANT_P', so you need not check this.  In fact, `1'
     is a suitable definition for this macro on machines where anything
     `CONSTANT_P' is valid.

 -- Target Hook: rtx TARGET_DELEGITIMIZE_ADDRESS (rtx X)
     This hook is used to undo the possibly obfuscating effects of the
     `LEGITIMIZE_ADDRESS' and `LEGITIMIZE_RELOAD_ADDRESS' target
     macros.  Some backend implementations of these macros wrap symbol
     references inside an `UNSPEC' rtx to represent PIC or similar
     addressing modes.  This target hook allows GCC's optimizers to
     understand the semantics of these opaque `UNSPEC's by converting
     them back into their original form.

 -- Target Hook: bool TARGET_CANNOT_FORCE_CONST_MEM (rtx X)
     This hook should return true if X is of a form that cannot (or
     should not) be spilled to the constant pool.  The default version
     of this hook returns false.

     The primary reason to define this hook is to prevent reload from
     deciding that a non-legitimate constant would be better reloaded
     from the constant pool instead of spilling and reloading a register
     holding the constant.  This restriction is often true of addresses
     of TLS symbols for various targets.

 -- Target Hook: bool TARGET_USE_BLOCKS_FOR_CONSTANT_P (enum
          machine_mode MODE, rtx X)
     This hook should return true if pool entries for constant X can be
     placed in an `object_block' structure.  MODE is the mode of X.

     The default version returns false for all constants.

 -- Target Hook: tree TARGET_BUILTIN_RECIPROCAL (enum tree_code FN,
          bool TM_FN, bool SQRT)
     This hook should return the DECL of a function that implements
     reciprocal of the builtin function with builtin function code FN,
     or `NULL_TREE' if such a function is not available.  TM_FN is true
     when FN is a code of a machine-dependent builtin function.  When
     SQRT is true, additional optimizations that apply only to the
     reciprocal of a square root function are performed, and only
     reciprocals of `sqrt' function are valid.

 -- Target Hook: tree TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD (void)
     This hook should return the DECL of a function F that given an
     address ADDR as an argument returns a mask M that can be used to
     extract from two vectors the relevant data that resides in ADDR in
     case ADDR is not properly aligned.

     The autovectorizer, when vectorizing a load operation from an
     address ADDR that may be unaligned, will generate two vector loads
     from the two aligned addresses around ADDR. It then generates a
     `REALIGN_LOAD' operation to extract the relevant data from the two
     loaded vectors. The first two arguments to `REALIGN_LOAD', V1 and
     V2, are the two vectors, each of size VS, and the third argument,
     OFF, defines how the data will be extracted from these two
     vectors: if OFF is 0, then the returned vector is V2; otherwise,
     the returned vector is composed from the last VS-OFF elements of
     V1 concatenated to the first OFF elements of V2.

     If this hook is defined, the autovectorizer will generate a call
     to F (using the DECL tree that this hook returns) and will use the
     return value of F as the argument OFF to `REALIGN_LOAD'.
     Therefore, the mask M returned by F should comply with the
     semantics expected by `REALIGN_LOAD' described above.  If this
     hook is not defined, then ADDR will be used as the argument OFF to
     `REALIGN_LOAD', in which case the low log2(VS)-1 bits of ADDR will
     be considered.

 -- Target Hook: tree TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN (tree X)
     This hook should return the DECL of a function F that implements
     widening multiplication of the even elements of two input vectors
     of type X.

     If this hook is defined, the autovectorizer will use it along with
     the `TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD' target hook when
     vectorizing widening multiplication in cases that the order of the
     results does not have to be preserved (e.g. used only by a
     reduction computation). Otherwise, the `widen_mult_hi/lo' idioms
     will be used.

 -- Target Hook: tree TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD (tree X)
     This hook should return the DECL of a function F that implements
     widening multiplication of the odd elements of two input vectors
     of type X.

     If this hook is defined, the autovectorizer will use it along with
     the `TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN' target hook when
     vectorizing widening multiplication in cases that the order of the
     results does not have to be preserved (e.g. used only by a
     reduction computation). Otherwise, the `widen_mult_hi/lo' idioms
     will be used.

 -- Target Hook: tree TARGET_VECTORIZE_BUILTIN_CONVERSION (enum
          tree_code CODE, tree TYPE)
     This hook should return the DECL of a function that implements
     conversion of the input vector of type TYPE.  If TYPE is an
     integral type, the result of the conversion is a vector of
     floating-point type of the same size.  If TYPE is a floating-point
     type, the result of the conversion is a vector of integral type of
     the same size.  CODE specifies how the conversion is to be applied
     (truncation, rounding, etc.).

     If this hook is defined, the autovectorizer will use the
     `TARGET_VECTORIZE_BUILTIN_CONVERSION' target hook when vectorizing
     conversion. Otherwise, it will return `NULL_TREE'.

 -- Target Hook: tree TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION
          (enum built_in_function CODE, tree VEC_TYPE_OUT, tree
          VEC_TYPE_IN)
     This hook should return the decl of a function that implements the
     vectorized variant of the builtin function with builtin function
     code CODE or `NULL_TREE' if such a function is not available.  The
     return type of the vectorized function shall be of vector type
     VEC_TYPE_OUT and the argument types should be VEC_TYPE_IN.


File: gccint.info,  Node: Anchored Addresses,  Next: Condition Code,  Prev: Addressing Modes,  Up: Target Macros

15.15 Anchored Addresses
========================

GCC usually addresses every static object as a separate entity.  For
example, if we have:

     static int a, b, c;
     int foo (void) { return a + b + c; }

 the code for `foo' will usually calculate three separate symbolic
addresses: those of `a', `b' and `c'.  On some targets, it would be
better to calculate just one symbolic address and access the three
variables relative to it.  The equivalent pseudocode would be something
like:

     int foo (void)
     {
       register int *xr = &x;
       return xr[&a - &x] + xr[&b - &x] + xr[&c - &x];
     }

 (which isn't valid C).  We refer to shared addresses like `x' as
"section anchors".  Their use is controlled by `-fsection-anchors'.

 The hooks below describe the target properties that GCC needs to know
in order to make effective use of section anchors.  It won't use
section anchors at all unless either `TARGET_MIN_ANCHOR_OFFSET' or
`TARGET_MAX_ANCHOR_OFFSET' is set to a nonzero value.

 -- Variable: Target Hook HOST_WIDE_INT TARGET_MIN_ANCHOR_OFFSET
     The minimum offset that should be applied to a section anchor.  On
     most targets, it should be the smallest offset that can be applied
     to a base register while still giving a legitimate address for
     every mode.  The default value is 0.

 -- Variable: Target Hook HOST_WIDE_INT TARGET_MAX_ANCHOR_OFFSET
     Like `TARGET_MIN_ANCHOR_OFFSET', but the maximum (inclusive)
     offset that should be applied to section anchors.  The default
     value is 0.

 -- Target Hook: void TARGET_ASM_OUTPUT_ANCHOR (rtx X)
     Write the assembly code to define section anchor X, which is a
     `SYMBOL_REF' for which `SYMBOL_REF_ANCHOR_P (X)' is true.  The
     hook is called with the assembly output position set to the
     beginning of `SYMBOL_REF_BLOCK (X)'.

     If `ASM_OUTPUT_DEF' is available, the hook's default definition
     uses it to define the symbol as `. + SYMBOL_REF_BLOCK_OFFSET (X)'.
     If `ASM_OUTPUT_DEF' is not available, the hook's default definition
     is `NULL', which disables the use of section anchors altogether.

 -- Target Hook: bool TARGET_USE_ANCHORS_FOR_SYMBOL_P (rtx X)
     Return true if GCC should attempt to use anchors to access
     `SYMBOL_REF' X.  You can assume `SYMBOL_REF_HAS_BLOCK_INFO_P (X)'
     and `!SYMBOL_REF_ANCHOR_P (X)'.

     The default version is correct for most targets, but you might
     need to intercept this hook to handle things like target-specific
     attributes or target-specific sections.


File: gccint.info,  Node: Condition Code,  Next: Costs,  Prev: Anchored Addresses,  Up: Target Macros

15.16 Condition Code Status
===========================

This describes the condition code status.

 The file `conditions.h' defines a variable `cc_status' to describe how
the condition code was computed (in case the interpretation of the
condition code depends on the instruction that it was set by).  This
variable contains the RTL expressions on which the condition code is
currently based, and several standard flags.

 Sometimes additional machine-specific flags must be defined in the
machine description header file.  It can also add additional
machine-specific information by defining `CC_STATUS_MDEP'.

 -- Macro: CC_STATUS_MDEP
     C code for a data type which is used for declaring the `mdep'
     component of `cc_status'.  It defaults to `int'.

     This macro is not used on machines that do not use `cc0'.

 -- Macro: CC_STATUS_MDEP_INIT
     A C expression to initialize the `mdep' field to "empty".  The
     default definition does nothing, since most machines don't use the
     field anyway.  If you want to use the field, you should probably
     define this macro to initialize it.

     This macro is not used on machines that do not use `cc0'.

 -- Macro: NOTICE_UPDATE_CC (EXP, INSN)
     A C compound statement to set the components of `cc_status'
     appropriately for an insn INSN whose body is EXP.  It is this
     macro's responsibility to recognize insns that set the condition
     code as a byproduct of other activity as well as those that
     explicitly set `(cc0)'.

     This macro is not used on machines that do not use `cc0'.

     If there are insns that do not set the condition code but do alter
     other machine registers, this macro must check to see whether they
     invalidate the expressions that the condition code is recorded as
     reflecting.  For example, on the 68000, insns that store in address
     registers do not set the condition code, which means that usually
     `NOTICE_UPDATE_CC' can leave `cc_status' unaltered for such insns.
     But suppose that the previous insn set the condition code based on
     location `a4@(102)' and the current insn stores a new value in
     `a4'.  Although the condition code is not changed by this, it will
     no longer be true that it reflects the contents of `a4@(102)'.
     Therefore, `NOTICE_UPDATE_CC' must alter `cc_status' in this case
     to say that nothing is known about the condition code value.

     The definition of `NOTICE_UPDATE_CC' must be prepared to deal with
     the results of peephole optimization: insns whose patterns are
     `parallel' RTXs containing various `reg', `mem' or constants which
     are just the operands.  The RTL structure of these insns is not
     sufficient to indicate what the insns actually do.  What
     `NOTICE_UPDATE_CC' should do when it sees one is just to run
     `CC_STATUS_INIT'.

     A possible definition of `NOTICE_UPDATE_CC' is to call a function
     that looks at an attribute (*note Insn Attributes::) named, for
     example, `cc'.  This avoids having detailed information about
     patterns in two places, the `md' file and in `NOTICE_UPDATE_CC'.

 -- Macro: SELECT_CC_MODE (OP, X, Y)
     Returns a mode from class `MODE_CC' to be used when comparison
     operation code OP is applied to rtx X and Y.  For example, on the
     SPARC, `SELECT_CC_MODE' is defined as (see *note Jump Patterns::
     for a description of the reason for this definition)

          #define SELECT_CC_MODE(OP,X,Y) \
            (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT          \
             ? ((OP == EQ || OP == NE) ? CCFPmode : CCFPEmode)    \
             : ((GET_CODE (X) == PLUS || GET_CODE (X) == MINUS    \
                 || GET_CODE (X) == NEG) \
                ? CC_NOOVmode : CCmode))

     You should define this macro if and only if you define extra CC
     modes in `MACHINE-modes.def'.

 -- Macro: CANONICALIZE_COMPARISON (CODE, OP0, OP1)
     On some machines not all possible comparisons are defined, but you
     can convert an invalid comparison into a valid one.  For example,
     the Alpha does not have a `GT' comparison, but you can use an `LT'
     comparison instead and swap the order of the operands.

     On such machines, define this macro to be a C statement to do any
     required conversions.  CODE is the initial comparison code and OP0
     and OP1 are the left and right operands of the comparison,
     respectively.  You should modify CODE, OP0, and OP1 as required.

     GCC will not assume that the comparison resulting from this macro
     is valid but will see if the resulting insn matches a pattern in
     the `md' file.

     You need not define this macro if it would never change the
     comparison code or operands.

 -- Macro: REVERSIBLE_CC_MODE (MODE)
     A C expression whose value is one if it is always safe to reverse a
     comparison whose mode is MODE.  If `SELECT_CC_MODE' can ever
     return MODE for a floating-point inequality comparison, then
     `REVERSIBLE_CC_MODE (MODE)' must be zero.

     You need not define this macro if it would always returns zero or
     if the floating-point format is anything other than
     `IEEE_FLOAT_FORMAT'.  For example, here is the definition used on
     the SPARC, where floating-point inequality comparisons are always
     given `CCFPEmode':

          #define REVERSIBLE_CC_MODE(MODE)  ((MODE) != CCFPEmode)

 -- Macro: REVERSE_CONDITION (CODE, MODE)
     A C expression whose value is reversed condition code of the CODE
     for comparison done in CC_MODE MODE.  The macro is used only in
     case `REVERSIBLE_CC_MODE (MODE)' is nonzero.  Define this macro in
     case machine has some non-standard way how to reverse certain
     conditionals.  For instance in case all floating point conditions
     are non-trapping, compiler may freely convert unordered compares
     to ordered one.  Then definition may look like:

          #define REVERSE_CONDITION(CODE, MODE) \
             ((MODE) != CCFPmode ? reverse_condition (CODE) \
              : reverse_condition_maybe_unordered (CODE))

 -- Macro: REVERSE_CONDEXEC_PREDICATES_P (OP1, OP2)
     A C expression that returns true if the conditional execution
     predicate OP1, a comparison operation, is the inverse of OP2 and
     vice versa.  Define this to return 0 if the target has conditional
     execution predicates that cannot be reversed safely.  There is no
     need to validate that the arguments of op1 and op2 are the same,
     this is done separately.  If no expansion is specified, this macro
     is defined as follows:

          #define REVERSE_CONDEXEC_PREDICATES_P (x, y) \
             (GET_CODE ((x)) == reversed_comparison_code ((y), NULL))

 -- Target Hook: bool TARGET_FIXED_CONDITION_CODE_REGS (unsigned int *,
          unsigned int *)
     On targets which do not use `(cc0)', and which use a hard register
     rather than a pseudo-register to hold condition codes, the regular
     CSE passes are often not able to identify cases in which the hard
     register is set to a common value.  Use this hook to enable a
     small pass which optimizes such cases.  This hook should return
     true to enable this pass, and it should set the integers to which
     its arguments point to the hard register numbers used for
     condition codes.  When there is only one such register, as is true
     on most systems, the integer pointed to by the second argument
     should be set to `INVALID_REGNUM'.

     The default version of this hook returns false.

 -- Target Hook: enum machine_mode TARGET_CC_MODES_COMPATIBLE (enum
          machine_mode, enum machine_mode)
     On targets which use multiple condition code modes in class
     `MODE_CC', it is sometimes the case that a comparison can be
     validly done in more than one mode.  On such a system, define this
     target hook to take two mode arguments and to return a mode in
     which both comparisons may be validly done.  If there is no such
     mode, return `VOIDmode'.

     The default version of this hook checks whether the modes are the
     same.  If they are, it returns that mode.  If they are different,
     it returns `VOIDmode'.


File: gccint.info,  Node: Costs,  Next: Scheduling,  Prev: Condition Code,  Up: Target Macros

15.17 Describing Relative Costs of Operations
=============================================

These macros let you describe the relative speed of various operations
on the target machine.

 -- Macro: REGISTER_MOVE_COST (MODE, FROM, TO)
     A C expression for the cost of moving data of mode MODE from a
     register in class FROM to one in class TO.  The classes are
     expressed using the enumeration values such as `GENERAL_REGS'.  A
     value of 2 is the default; other values are interpreted relative to
     that.

     It is not required that the cost always equal 2 when FROM is the
     same as TO; on some machines it is expensive to move between
     registers if they are not general registers.

     If reload sees an insn consisting of a single `set' between two
     hard registers, and if `REGISTER_MOVE_COST' applied to their
     classes returns a value of 2, reload does not check to ensure that
     the constraints of the insn are met.  Setting a cost of other than
     2 will allow reload to verify that the constraints are met.  You
     should do this if the `movM' pattern's constraints do not allow
     such copying.

 -- Macro: MEMORY_MOVE_COST (MODE, CLASS, IN)
     A C expression for the cost of moving data of mode MODE between a
     register of class CLASS and memory; IN is zero if the value is to
     be written to memory, nonzero if it is to be read in.  This cost
     is relative to those in `REGISTER_MOVE_COST'.  If moving between
     registers and memory is more expensive than between two registers,
     you should define this macro to express the relative cost.

     If you do not define this macro, GCC uses a default cost of 4 plus
     the cost of copying via a secondary reload register, if one is
     needed.  If your machine requires a secondary reload register to
     copy between memory and a register of CLASS but the reload
     mechanism is more complex than copying via an intermediate, define
     this macro to reflect the actual cost of the move.

     GCC defines the function `memory_move_secondary_cost' if secondary
     reloads are needed.  It computes the costs due to copying via a
     secondary register.  If your machine copies from memory using a
     secondary register in the conventional way but the default base
     value of 4 is not correct for your machine, define this macro to
     add some other value to the result of that function.  The
     arguments to that function are the same as to this macro.

 -- Macro: BRANCH_COST
     A C expression for the cost of a branch instruction.  A value of 1
     is the default; other values are interpreted relative to that.

 Here are additional macros which do not specify precise relative costs,
but only that certain actions are more expensive than GCC would
ordinarily expect.

 -- Macro: SLOW_BYTE_ACCESS
     Define this macro as a C expression which is nonzero if accessing
     less than a word of memory (i.e. a `char' or a `short') is no
     faster than accessing a word of memory, i.e., if such access
     require more than one instruction or if there is no difference in
     cost between byte and (aligned) word loads.

     When this macro is not defined, the compiler will access a field by
     finding the smallest containing object; when it is defined, a
     fullword load will be used if alignment permits.  Unless bytes
     accesses are faster than word accesses, using word accesses is
     preferable since it may eliminate subsequent memory access if
     subsequent accesses occur to other fields in the same word of the
     structure, but to different bytes.

 -- Macro: SLOW_UNALIGNED_ACCESS (MODE, ALIGNMENT)
     Define this macro to be the value 1 if memory accesses described
     by the MODE and ALIGNMENT parameters have a cost many times greater
     than aligned accesses, for example if they are emulated in a trap
     handler.

     When this macro is nonzero, the compiler will act as if
     `STRICT_ALIGNMENT' were nonzero when generating code for block
     moves.  This can cause significantly more instructions to be
     produced.  Therefore, do not set this macro nonzero if unaligned
     accesses only add a cycle or two to the time for a memory access.

     If the value of this macro is always zero, it need not be defined.
     If this macro is defined, it should produce a nonzero value when
     `STRICT_ALIGNMENT' is nonzero.

 -- Macro: MOVE_RATIO
     The threshold of number of scalar memory-to-memory move insns,
     _below_ which a sequence of insns should be generated instead of a
     string move insn or a library call.  Increasing the value will
     always make code faster, but eventually incurs high cost in
     increased code size.

     Note that on machines where the corresponding move insn is a
     `define_expand' that emits a sequence of insns, this macro counts
     the number of such sequences.

     If you don't define this, a reasonable default is used.

 -- Macro: MOVE_BY_PIECES_P (SIZE, ALIGNMENT)
     A C expression used to determine whether `move_by_pieces' will be
     used to copy a chunk of memory, or whether some other block move
     mechanism will be used.  Defaults to 1 if `move_by_pieces_ninsns'
     returns less than `MOVE_RATIO'.

 -- Macro: MOVE_MAX_PIECES
     A C expression used by `move_by_pieces' to determine the largest
     unit a load or store used to copy memory is.  Defaults to
     `MOVE_MAX'.

 -- Macro: CLEAR_RATIO
     The threshold of number of scalar move insns, _below_ which a
     sequence of insns should be generated to clear memory instead of a
     string clear insn or a library call.  Increasing the value will
     always make code faster, but eventually incurs high cost in
     increased code size.

     If you don't define this, a reasonable default is used.

 -- Macro: CLEAR_BY_PIECES_P (SIZE, ALIGNMENT)
     A C expression used to determine whether `clear_by_pieces' will be
     used to clear a chunk of memory, or whether some other block clear
     mechanism will be used.  Defaults to 1 if `move_by_pieces_ninsns'
     returns less than `CLEAR_RATIO'.

 -- Macro: SET_RATIO
     The threshold of number of scalar move insns, _below_ which a
     sequence of insns should be generated to set memory to a constant
     value, instead of a block set insn or a library call.  Increasing
     the value will always make code faster, but eventually incurs high
     cost in increased code size.

     If you don't define this, it defaults to the value of `MOVE_RATIO'.

 -- Macro: SET_BY_PIECES_P (SIZE, ALIGNMENT)
     A C expression used to determine whether `store_by_pieces' will be
     used to set a chunk of memory to a constant value, or whether some
     other mechanism will be used.  Used by `__builtin_memset' when
     storing values other than constant zero.  Defaults to 1 if
     `move_by_pieces_ninsns' returns less than `SET_RATIO'.

 -- Macro: STORE_BY_PIECES_P (SIZE, ALIGNMENT)
     A C expression used to determine whether `store_by_pieces' will be
     used to set a chunk of memory to a constant string value, or
     whether some other mechanism will be used.  Used by
     `__builtin_strcpy' when called with a constant source string.
     Defaults to 1 if `move_by_pieces_ninsns' returns less than
     `MOVE_RATIO'.

 -- Macro: USE_LOAD_POST_INCREMENT (MODE)
     A C expression used to determine whether a load postincrement is a
     good thing to use for a given mode.  Defaults to the value of
     `HAVE_POST_INCREMENT'.

 -- Macro: USE_LOAD_POST_DECREMENT (MODE)
     A C expression used to determine whether a load postdecrement is a
     good thing to use for a given mode.  Defaults to the value of
     `HAVE_POST_DECREMENT'.

 -- Macro: USE_LOAD_PRE_INCREMENT (MODE)
     A C expression used to determine whether a load preincrement is a
     good thing to use for a given mode.  Defaults to the value of
     `HAVE_PRE_INCREMENT'.

 -- Macro: USE_LOAD_PRE_DECREMENT (MODE)
     A C expression used to determine whether a load predecrement is a
     good thing to use for a given mode.  Defaults to the value of
     `HAVE_PRE_DECREMENT'.

 -- Macro: USE_STORE_POST_INCREMENT (MODE)
     A C expression used to determine whether a store postincrement is
     a good thing to use for a given mode.  Defaults to the value of
     `HAVE_POST_INCREMENT'.

 -- Macro: USE_STORE_POST_DECREMENT (MODE)
     A C expression used to determine whether a store postdecrement is
     a good thing to use for a given mode.  Defaults to the value of
     `HAVE_POST_DECREMENT'.

 -- Macro: USE_STORE_PRE_INCREMENT (MODE)
     This macro is used to determine whether a store preincrement is a
     good thing to use for a given mode.  Defaults to the value of
     `HAVE_PRE_INCREMENT'.

 -- Macro: USE_STORE_PRE_DECREMENT (MODE)
     This macro is used to determine whether a store predecrement is a
     good thing to use for a given mode.  Defaults to the value of
     `HAVE_PRE_DECREMENT'.

 -- Macro: NO_FUNCTION_CSE
     Define this macro if it is as good or better to call a constant
     function address than to call an address kept in a register.

 -- Macro: RANGE_TEST_NON_SHORT_CIRCUIT
     Define this macro if a non-short-circuit operation produced by
     `fold_range_test ()' is optimal.  This macro defaults to true if
     `BRANCH_COST' is greater than or equal to the value 2.

 -- Target Hook: bool TARGET_RTX_COSTS (rtx X, int CODE, int
          OUTER_CODE, int *TOTAL)
     This target hook describes the relative costs of RTL expressions.

     The cost may depend on the precise form of the expression, which is
     available for examination in X, and the rtx code of the expression
     in which it is contained, found in OUTER_CODE.  CODE is the
     expression code--redundant, since it can be obtained with
     `GET_CODE (X)'.

     In implementing this hook, you can use the construct
     `COSTS_N_INSNS (N)' to specify a cost equal to N fast instructions.

     On entry to the hook, `*TOTAL' contains a default estimate for the
     cost of the expression.  The hook should modify this value as
     necessary.  Traditionally, the default costs are `COSTS_N_INSNS
     (5)' for multiplications, `COSTS_N_INSNS (7)' for division and
     modulus operations, and `COSTS_N_INSNS (1)' for all other
     operations.

     When optimizing for code size, i.e. when `optimize_size' is
     nonzero, this target hook should be used to estimate the relative
     size cost of an expression, again relative to `COSTS_N_INSNS'.

     The hook returns true when all subexpressions of X have been
     processed, and false when `rtx_cost' should recurse.

 -- Target Hook: int TARGET_ADDRESS_COST (rtx ADDRESS)
     This hook computes the cost of an addressing mode that contains
     ADDRESS.  If not defined, the cost is computed from the ADDRESS
     expression and the `TARGET_RTX_COST' hook.

     For most CISC machines, the default cost is a good approximation
     of the true cost of the addressing mode.  However, on RISC
     machines, all instructions normally have the same length and
     execution time.  Hence all addresses will have equal costs.

     In cases where more than one form of an address is known, the form
     with the lowest cost will be used.  If multiple forms have the
     same, lowest, cost, the one that is the most complex will be used.

     For example, suppose an address that is equal to the sum of a
     register and a constant is used twice in the same basic block.
     When this macro is not defined, the address will be computed in a
     register and memory references will be indirect through that
     register.  On machines where the cost of the addressing mode
     containing the sum is no higher than that of a simple indirect
     reference, this will produce an additional instruction and
     possibly require an additional register.  Proper specification of
     this macro eliminates this overhead for such machines.

     This hook is never called with an invalid address.

     On machines where an address involving more than one register is as
     cheap as an address computation involving only one register,
     defining `TARGET_ADDRESS_COST' to reflect this can cause two
     registers to be live over a region of code where only one would
     have been if `TARGET_ADDRESS_COST' were not defined in that
     manner.  This effect should be considered in the definition of
     this macro.  Equivalent costs should probably only be given to
     addresses with different numbers of registers on machines with
     lots of registers.


File: gccint.info,  Node: Scheduling,  Next: Sections,  Prev: Costs,  Up: Target Macros

15.18 Adjusting the Instruction Scheduler
=========================================

The instruction scheduler may need a fair amount of machine-specific
adjustment in order to produce good code.  GCC provides several target
hooks for this purpose.  It is usually enough to define just a few of
them: try the first ones in this list first.

 -- Target Hook: int TARGET_SCHED_ISSUE_RATE (void)
     This hook returns the maximum number of instructions that can ever
     issue at the same time on the target machine.  The default is one.
     Although the insn scheduler can define itself the possibility of
     issue an insn on the same cycle, the value can serve as an
     additional constraint to issue insns on the same simulated
     processor cycle (see hooks `TARGET_SCHED_REORDER' and
     `TARGET_SCHED_REORDER2').  This value must be constant over the
     entire compilation.  If you need it to vary depending on what the
     instructions are, you must use `TARGET_SCHED_VARIABLE_ISSUE'.

 -- Target Hook: int TARGET_SCHED_VARIABLE_ISSUE (FILE *FILE, int
          VERBOSE, rtx INSN, int MORE)
     This hook is executed by the scheduler after it has scheduled an
     insn from the ready list.  It should return the number of insns
     which can still be issued in the current cycle.  The default is
     `MORE - 1' for insns other than `CLOBBER' and `USE', which
     normally are not counted against the issue rate.  You should
     define this hook if some insns take more machine resources than
     others, so that fewer insns can follow them in the same cycle.
     FILE is either a null pointer, or a stdio stream to write any
     debug output to.  VERBOSE is the verbose level provided by
     `-fsched-verbose-N'.  INSN is the instruction that was scheduled.

 -- Target Hook: int TARGET_SCHED_ADJUST_COST (rtx INSN, rtx LINK, rtx
          DEP_INSN, int COST)
     This function corrects the value of COST based on the relationship
     between INSN and DEP_INSN through the dependence LINK.  It should
     return the new value.  The default is to make no adjustment to
     COST.  This can be used for example to specify to the scheduler
     using the traditional pipeline description that an output- or
     anti-dependence does not incur the same cost as a data-dependence.
     If the scheduler using the automaton based pipeline description,
     the cost of anti-dependence is zero and the cost of
     output-dependence is maximum of one and the difference of latency
     times of the first and the second insns.  If these values are not
     acceptable, you could use the hook to modify them too.  See also
     *note Processor pipeline description::.

 -- Target Hook: int TARGET_SCHED_ADJUST_PRIORITY (rtx INSN, int
          PRIORITY)
     This hook adjusts the integer scheduling priority PRIORITY of
     INSN.  It should return the new priority.  Increase the priority to
     execute INSN earlier, reduce the priority to execute INSN later.
     Do not define this hook if you do not need to adjust the
     scheduling priorities of insns.

 -- Target Hook: int TARGET_SCHED_REORDER (FILE *FILE, int VERBOSE, rtx
          *READY, int *N_READYP, int CLOCK)
     This hook is executed by the scheduler after it has scheduled the
     ready list, to allow the machine description to reorder it (for
     example to combine two small instructions together on `VLIW'
     machines).  FILE is either a null pointer, or a stdio stream to
     write any debug output to.  VERBOSE is the verbose level provided
     by `-fsched-verbose-N'.  READY is a pointer to the ready list of
     instructions that are ready to be scheduled.  N_READYP is a
     pointer to the number of elements in the ready list.  The scheduler
     reads the ready list in reverse order, starting with
     READY[*N_READYP-1] and going to READY[0].  CLOCK is the timer tick
     of the scheduler.  You may modify the ready list and the number of
     ready insns.  The return value is the number of insns that can
     issue this cycle; normally this is just `issue_rate'.  See also
     `TARGET_SCHED_REORDER2'.

 -- Target Hook: int TARGET_SCHED_REORDER2 (FILE *FILE, int VERBOSE,
          rtx *READY, int *N_READY, CLOCK)
     Like `TARGET_SCHED_REORDER', but called at a different time.  That
     function is called whenever the scheduler starts a new cycle.
     This one is called once per iteration over a cycle, immediately
     after `TARGET_SCHED_VARIABLE_ISSUE'; it can reorder the ready list
     and return the number of insns to be scheduled in the same cycle.
     Defining this hook can be useful if there are frequent situations
     where scheduling one insn causes other insns to become ready in
     the same cycle.  These other insns can then be taken into account
     properly.

 -- Target Hook: void TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK (rtx
          HEAD, rtx TAIL)
     This hook is called after evaluation forward dependencies of insns
     in chain given by two parameter values (HEAD and TAIL
     correspondingly) but before insns scheduling of the insn chain.
     For example, it can be used for better insn classification if it
     requires analysis of dependencies.  This hook can use backward and
     forward dependencies of the insn scheduler because they are already
     calculated.

 -- Target Hook: void TARGET_SCHED_INIT (FILE *FILE, int VERBOSE, int
          MAX_READY)
     This hook is executed by the scheduler at the beginning of each
     block of instructions that are to be scheduled.  FILE is either a
     null pointer, or a stdio stream to write any debug output to.
     VERBOSE is the verbose level provided by `-fsched-verbose-N'.
     MAX_READY is the maximum number of insns in the current scheduling
     region that can be live at the same time.  This can be used to
     allocate scratch space if it is needed, e.g. by
     `TARGET_SCHED_REORDER'.

 -- Target Hook: void TARGET_SCHED_FINISH (FILE *FILE, int VERBOSE)
     This hook is executed by the scheduler at the end of each block of
     instructions that are to be scheduled.  It can be used to perform
     cleanup of any actions done by the other scheduling hooks.  FILE
     is either a null pointer, or a stdio stream to write any debug
     output to.  VERBOSE is the verbose level provided by
     `-fsched-verbose-N'.

 -- Target Hook: void TARGET_SCHED_INIT_GLOBAL (FILE *FILE, int
          VERBOSE, int OLD_MAX_UID)
     This hook is executed by the scheduler after function level
     initializations.  FILE is either a null pointer, or a stdio stream
     to write any debug output to.  VERBOSE is the verbose level
     provided by `-fsched-verbose-N'.  OLD_MAX_UID is the maximum insn
     uid when scheduling begins.

 -- Target Hook: void TARGET_SCHED_FINISH_GLOBAL (FILE *FILE, int
          VERBOSE)
     This is the cleanup hook corresponding to
     `TARGET_SCHED_INIT_GLOBAL'.  FILE is either a null pointer, or a
     stdio stream to write any debug output to.  VERBOSE is the verbose
     level provided by `-fsched-verbose-N'.

 -- Target Hook: int TARGET_SCHED_DFA_PRE_CYCLE_INSN (void)
     The hook returns an RTL insn.  The automaton state used in the
     pipeline hazard recognizer is changed as if the insn were scheduled
     when the new simulated processor cycle starts.  Usage of the hook
     may simplify the automaton pipeline description for some VLIW
     processors.  If the hook is defined, it is used only for the
     automaton based pipeline description.  The default is not to
     change the state when the new simulated processor cycle starts.

 -- Target Hook: void TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN (void)
     The hook can be used to initialize data used by the previous hook.

 -- Target Hook: int TARGET_SCHED_DFA_POST_CYCLE_INSN (void)
     The hook is analogous to `TARGET_SCHED_DFA_PRE_CYCLE_INSN' but used
     to changed the state as if the insn were scheduled when the new
     simulated processor cycle finishes.

 -- Target Hook: void TARGET_SCHED_INIT_DFA_POST_CYCLE_INSN (void)
     The hook is analogous to `TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN' but
     used to initialize data used by the previous hook.

 -- Target Hook: void TARGET_SCHED_DFA_PRE_CYCLE_ADVANCE (void)
     The hook to notify target that the current simulated cycle is
     about to finish.  The hook is analogous to
     `TARGET_SCHED_DFA_PRE_CYCLE_INSN' but used to change the state in
     more complicated situations - e.g., when advancing state on a
     single insn is not enough.

 -- Target Hook: void TARGET_SCHED_DFA_POST_CYCLE_ADVANCE (void)
     The hook to notify target that new simulated cycle has just
     started.  The hook is analogous to
     `TARGET_SCHED_DFA_POST_CYCLE_INSN' but used to change the state in
     more complicated situations - e.g., when advancing state on a
     single insn is not enough.

 -- Target Hook: int TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
          (void)
     This hook controls better choosing an insn from the ready insn
     queue for the DFA-based insn scheduler.  Usually the scheduler
     chooses the first insn from the queue.  If the hook returns a
     positive value, an additional scheduler code tries all
     permutations of `TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
     ()' subsequent ready insns to choose an insn whose issue will
     result in maximal number of issued insns on the same cycle.  For
     the VLIW processor, the code could actually solve the problem of
     packing simple insns into the VLIW insn.  Of course, if the rules
     of VLIW packing are described in the automaton.

     This code also could be used for superscalar RISC processors.  Let
     us consider a superscalar RISC processor with 3 pipelines.  Some
     insns can be executed in pipelines A or B, some insns can be
     executed only in pipelines B or C, and one insn can be executed in
     pipeline B.  The processor may issue the 1st insn into A and the
     2nd one into B.  In this case, the 3rd insn will wait for freeing B
     until the next cycle.  If the scheduler issues the 3rd insn the
     first, the processor could issue all 3 insns per cycle.

     Actually this code demonstrates advantages of the automaton based
     pipeline hazard recognizer.  We try quickly and easy many insn
     schedules to choose the best one.

     The default is no multipass scheduling.

 -- Target Hook: int
TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD (rtx)
     This hook controls what insns from the ready insn queue will be
     considered for the multipass insn scheduling.  If the hook returns
     zero for insn passed as the parameter, the insn will be not chosen
     to be issued.

     The default is that any ready insns can be chosen to be issued.

 -- Target Hook: int TARGET_SCHED_DFA_NEW_CYCLE (FILE *, int, rtx, int,
          int, int *)
     This hook is called by the insn scheduler before issuing insn
     passed as the third parameter on given cycle.  If the hook returns
     nonzero, the insn is not issued on given processors cycle.
     Instead of that, the processor cycle is advanced.  If the value
     passed through the last parameter is zero, the insn ready queue is
     not sorted on the new cycle start as usually.  The first parameter
     passes file for debugging output.  The second one passes the
     scheduler verbose level of the debugging output.  The forth and
     the fifth parameter values are correspondingly processor cycle on
     which the previous insn has been issued and the current processor
     cycle.

 -- Target Hook: bool TARGET_SCHED_IS_COSTLY_DEPENDENCE (struct dep_def
          *_DEP, int COST, int DISTANCE)
     This hook is used to define which dependences are considered
     costly by the target, so costly that it is not advisable to
     schedule the insns that are involved in the dependence too close
     to one another.  The parameters to this hook are as follows:  The
     first parameter _DEP is the dependence being evaluated.  The
     second parameter COST is the cost of the dependence, and the third
     parameter DISTANCE is the distance in cycles between the two insns.
     The hook returns `true' if considering the distance between the two
     insns the dependence between them is considered costly by the
     target, and `false' otherwise.

     Defining this hook can be useful in multiple-issue out-of-order
     machines, where (a) it's practically hopeless to predict the
     actual data/resource delays, however: (b) there's a better chance
     to predict the actual grouping that will be formed, and (c)
     correctly emulating the grouping can be very important.  In such
     targets one may want to allow issuing dependent insns closer to
     one another--i.e., closer than the dependence distance;  however,
     not in cases of "costly dependences", which this hooks allows to
     define.

 -- Target Hook: void TARGET_SCHED_H_I_D_EXTENDED (void)
     This hook is called by the insn scheduler after emitting a new
     instruction to the instruction stream.  The hook notifies a target
     backend to extend its per instruction data structures.

 -- Target Hook: int TARGET_SCHED_SPECULATE_INSN (rtx INSN, int
          REQUEST, rtx *NEW_PAT)
     This hook is called by the insn scheduler when INSN has only
     speculative dependencies and therefore can be scheduled
     speculatively.  The hook is used to check if the pattern of INSN
     has a speculative version and, in case of successful check, to
     generate that speculative pattern.  The hook should return 1, if
     the instruction has a speculative form, or -1, if it doesn't.
     REQUEST describes the type of requested speculation.  If the
     return value equals 1 then NEW_PAT is assigned the generated
     speculative pattern.

 -- Target Hook: int TARGET_SCHED_NEEDS_BLOCK_P (rtx INSN)
     This hook is called by the insn scheduler during generation of
     recovery code for INSN.  It should return nonzero, if the
     corresponding check instruction should branch to recovery code, or
     zero otherwise.

 -- Target Hook: rtx TARGET_SCHED_GEN_CHECK (rtx INSN, rtx LABEL, int
          MUTATE_P)
     This hook is called by the insn scheduler to generate a pattern
     for recovery check instruction.  If MUTATE_P is zero, then INSN is
     a speculative instruction for which the check should be generated.
     LABEL is either a label of a basic block, where recovery code
     should be emitted, or a null pointer, when requested check doesn't
     branch to recovery code (a simple check).  If MUTATE_P is nonzero,
     then a pattern for a branchy check corresponding to a simple check
     denoted by INSN should be generated.  In this case LABEL can't be
     null.

 -- Target Hook: int
TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD_SPEC (rtx INSN)
     This hook is used as a workaround for
     `TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD' not being
     called on the first instruction of the ready list.  The hook is
     used to discard speculative instruction that stand first in the
     ready list from being scheduled on the current cycle.  For
     non-speculative instructions, the hook should always return
     nonzero.  For example, in the ia64 backend the hook is used to
     cancel data speculative insns when the ALAT table is nearly full.

 -- Target Hook: void TARGET_SCHED_SET_SCHED_FLAGS (unsigned int
          *FLAGS, spec_info_t SPEC_INFO)
     This hook is used by the insn scheduler to find out what features
     should be enabled/used.  FLAGS initially may have either the
     SCHED_RGN or SCHED_EBB bit set.  This denotes the scheduler pass
     for which the data should be provided.  The target backend should
     modify FLAGS by modifying the bits corresponding to the following
     features: USE_DEPS_LIST, USE_GLAT, DETACH_LIFE_INFO, and
     DO_SPECULATION.  For the DO_SPECULATION feature an additional
     structure SPEC_INFO should be filled by the target.  The structure
     describes speculation types that can be used in the scheduler.

 -- Target Hook: int TARGET_SCHED_SMS_RES_MII (struct ddg *G)
     This hook is called by the swing modulo scheduler to calculate a
     resource-based lower bound which is based on the resources
     available in the machine and the resources required by each
     instruction.  The target backend can use G to calculate such
     bound.  A very simple lower bound will be used in case this hook
     is not implemented: the total number of instructions divided by
     the issue rate.


File: gccint.info,  Node: Sections,  Next: PIC,  Prev: Scheduling,  Up: Target Macros

15.19 Dividing the Output into Sections (Texts, Data, ...)
==========================================================

An object file is divided into sections containing different types of
data.  In the most common case, there are three sections: the "text
section", which holds instructions and read-only data; the "data
section", which holds initialized writable data; and the "bss section",
which holds uninitialized data.  Some systems have other kinds of
sections.

 `varasm.c' provides several well-known sections, such as
`text_section', `data_section' and `bss_section'.  The normal way of
controlling a `FOO_section' variable is to define the associated
`FOO_SECTION_ASM_OP' macro, as described below.  The macros are only
read once, when `varasm.c' initializes itself, so their values must be
run-time constants.  They may however depend on command-line flags.

 _Note:_ Some run-time files, such `crtstuff.c', also make use of the
`FOO_SECTION_ASM_OP' macros, and expect them to be string literals.

 Some assemblers require a different string to be written every time a
section is selected.  If your assembler falls into this category, you
should define the `TARGET_ASM_INIT_SECTIONS' hook and use
`get_unnamed_section' to set up the sections.

 You must always create a `text_section', either by defining
`TEXT_SECTION_ASM_OP' or by initializing `text_section' in
`TARGET_ASM_INIT_SECTIONS'.  The same is true of `data_section' and
`DATA_SECTION_ASM_OP'.  If you do not create a distinct
`readonly_data_section', the default is to reuse `text_section'.

 All the other `varasm.c' sections are optional, and are null if the
target does not provide them.

 -- Macro: TEXT_SECTION_ASM_OP
     A C expression whose value is a string, including spacing,
     containing the assembler operation that should precede
     instructions and read-only data.  Normally `"\t.text"' is right.

 -- Macro: HOT_TEXT_SECTION_NAME
     If defined, a C string constant for the name of the section
     containing most frequently executed functions of the program.  If
     not defined, GCC will provide a default definition if the target
     supports named sections.

 -- Macro: UNLIKELY_EXECUTED_TEXT_SECTION_NAME
     If defined, a C string constant for the name of the section
     containing unlikely executed functions in the program.

 -- Macro: DATA_SECTION_ASM_OP
     A C expression whose value is a string, including spacing,
     containing the assembler operation to identify the following data
     as writable initialized data.  Normally `"\t.data"' is right.

 -- Macro: SDATA_SECTION_ASM_OP
     If defined, a C expression whose value is a string, including
     spacing, containing the assembler operation to identify the
     following data as initialized, writable small data.

 -- Macro: READONLY_DATA_SECTION_ASM_OP
     A C expression whose value is a string, including spacing,
     containing the assembler operation to identify the following data
     as read-only initialized data.

 -- Macro: BSS_SECTION_ASM_OP
     If defined, a C expression whose value is a string, including
     spacing, containing the assembler operation to identify the
     following data as uninitialized global data.  If not defined, and
     neither `ASM_OUTPUT_BSS' nor `ASM_OUTPUT_ALIGNED_BSS' are defined,
     uninitialized global data will be output in the data section if
     `-fno-common' is passed, otherwise `ASM_OUTPUT_COMMON' will be
     used.

 -- Macro: SBSS_SECTION_ASM_OP
     If defined, a C expression whose value is a string, including
     spacing, containing the assembler operation to identify the
     following data as uninitialized, writable small data.

 -- Macro: INIT_SECTION_ASM_OP
     If defined, a C expression whose value is a string, including
     spacing, containing the assembler operation to identify the
     following data as initialization code.  If not defined, GCC will
     assume such a section does not exist.  This section has no
     corresponding `init_section' variable; it is used entirely in
     runtime code.

 -- Macro: FINI_SECTION_ASM_OP
     If defined, a C expression whose value is a string, including
     spacing, containing the assembler operation to identify the
     following data as finalization code.  If not defined, GCC will
     assume such a section does not exist.  This section has no
     corresponding `fini_section' variable; it is used entirely in
     runtime code.

 -- Macro: INIT_ARRAY_SECTION_ASM_OP
     If defined, a C expression whose value is a string, including
     spacing, containing the assembler operation to identify the
     following data as part of the `.init_array' (or equivalent)
     section.  If not defined, GCC will assume such a section does not
     exist.  Do not define both this macro and `INIT_SECTION_ASM_OP'.

 -- Macro: FINI_ARRAY_SECTION_ASM_OP
     If defined, a C expression whose value is a string, including
     spacing, containing the assembler operation to identify the
     following data as part of the `.fini_array' (or equivalent)
     section.  If not defined, GCC will assume such a section does not
     exist.  Do not define both this macro and `FINI_SECTION_ASM_OP'.

 -- Macro: CRT_CALL_STATIC_FUNCTION (SECTION_OP, FUNCTION)
     If defined, an ASM statement that switches to a different section
     via SECTION_OP, calls FUNCTION, and switches back to the text
     section.  This is used in `crtstuff.c' if `INIT_SECTION_ASM_OP' or
     `FINI_SECTION_ASM_OP' to calls to initialization and finalization
     functions from the init and fini sections.  By default, this macro
     uses a simple function call.  Some ports need hand-crafted
     assembly code to avoid dependencies on registers initialized in
     the function prologue or to ensure that constant pools don't end
     up too far way in the text section.

 -- Macro: TARGET_LIBGCC_SDATA_SECTION
     If defined, a string which names the section into which small
     variables defined in crtstuff and libgcc should go.  This is useful
     when the target has options for optimizing access to small data,
     and you want the crtstuff and libgcc routines to be conservative
     in what they expect of your application yet liberal in what your
     application expects.  For example, for targets with a `.sdata'
     section (like MIPS), you could compile crtstuff with `-G 0' so
     that it doesn't require small data support from your application,
     but use this macro to put small data into `.sdata' so that your
     application can access these variables whether it uses small data
     or not.

 -- Macro: FORCE_CODE_SECTION_ALIGN
     If defined, an ASM statement that aligns a code section to some
     arbitrary boundary.  This is used to force all fragments of the
     `.init' and `.fini' sections to have to same alignment and thus
     prevent the linker from having to add any padding.

 -- Macro: JUMP_TABLES_IN_TEXT_SECTION
     Define this macro to be an expression with a nonzero value if jump
     tables (for `tablejump' insns) should be output in the text
     section, along with the assembler instructions.  Otherwise, the
     readonly data section is used.

     This macro is irrelevant if there is no separate readonly data
     section.

 -- Target Hook: void TARGET_ASM_INIT_SECTIONS (void)
     Define this hook if you need to do something special to set up the
     `varasm.c' sections, or if your target has some special sections
     of its own that you need to create.

     GCC calls this hook after processing the command line, but before
     writing any assembly code, and before calling any of the
     section-returning hooks described below.

 -- Target Hook: TARGET_ASM_RELOC_RW_MASK (void)
     Return a mask describing how relocations should be treated when
     selecting sections.  Bit 1 should be set if global relocations
     should be placed in a read-write section; bit 0 should be set if
     local relocations should be placed in a read-write section.

     The default version of this function returns 3 when `-fpic' is in
     effect, and 0 otherwise.  The hook is typically redefined when the
     target cannot support (some kinds of) dynamic relocations in
     read-only sections even in executables.

 -- Target Hook: section * TARGET_ASM_SELECT_SECTION (tree EXP, int
          RELOC, unsigned HOST_WIDE_INT ALIGN)
     Return the section into which EXP should be placed.  You can
     assume that EXP is either a `VAR_DECL' node or a constant of some
     sort.  RELOC indicates whether the initial value of EXP requires
     link-time relocations.  Bit 0 is set when variable contains local
     relocations only, while bit 1 is set for global relocations.
     ALIGN is the constant alignment in bits.

     The default version of this function takes care of putting
     read-only variables in `readonly_data_section'.

     See also USE_SELECT_SECTION_FOR_FUNCTIONS.

 -- Macro: USE_SELECT_SECTION_FOR_FUNCTIONS
     Define this macro if you wish TARGET_ASM_SELECT_SECTION to be
     called for `FUNCTION_DECL's as well as for variables and constants.

     In the case of a `FUNCTION_DECL', RELOC will be zero if the
     function has been determined to be likely to be called, and
     nonzero if it is unlikely to be called.

 -- Target Hook: void TARGET_ASM_UNIQUE_SECTION (tree DECL, int RELOC)
     Build up a unique section name, expressed as a `STRING_CST' node,
     and assign it to `DECL_SECTION_NAME (DECL)'.  As with
     `TARGET_ASM_SELECT_SECTION', RELOC indicates whether the initial
     value of EXP requires link-time relocations.

     The default version of this function appends the symbol name to the
     ELF section name that would normally be used for the symbol.  For
     example, the function `foo' would be placed in `.text.foo'.
     Whatever the actual target object format, this is often good
     enough.

 -- Target Hook: section * TARGET_ASM_FUNCTION_RODATA_SECTION (tree
          DECL)
     Return the readonly data section associated with
     `DECL_SECTION_NAME (DECL)'.  The default version of this function
     selects `.gnu.linkonce.r.name' if the function's section is
     `.gnu.linkonce.t.name', `.rodata.name' if function is in
     `.text.name', and the normal readonly-data section otherwise.

 -- Target Hook: section * TARGET_ASM_SELECT_RTX_SECTION (enum
          machine_mode MODE, rtx X, unsigned HOST_WIDE_INT ALIGN)
     Return the section into which a constant X, of mode MODE, should
     be placed.  You can assume that X is some kind of constant in RTL.
     The argument MODE is redundant except in the case of a `const_int'
     rtx.  ALIGN is the constant alignment in bits.

     The default version of this function takes care of putting symbolic
     constants in `flag_pic' mode in `data_section' and everything else
     in `readonly_data_section'.

 -- Target Hook: void TARGET_MANGLE_DECL_ASSEMBLER_NAME (tree DECL,
          tree ID)
     Define this hook if you need to postprocess the assembler name
     generated by target-independent code.  The ID provided to this
     hook will be the computed name (e.g., the macro `DECL_NAME' of the
     DECL in C, or the mangled name of the DECL in C++).  The return
     value of the hook is an `IDENTIFIER_NODE' for the appropriate
     mangled name on your target system.  The default implementation of
     this hook just returns the ID provided.

 -- Target Hook: void TARGET_ENCODE_SECTION_INFO (tree DECL, rtx RTL,
          int NEW_DECL_P)
     Define this hook if references to a symbol or a constant must be
     treated differently depending on something about the variable or
     function named by the symbol (such as what section it is in).

     The hook is executed immediately after rtl has been created for
     DECL, which may be a variable or function declaration or an entry
     in the constant pool.  In either case, RTL is the rtl in question.
     Do _not_ use `DECL_RTL (DECL)' in this hook; that field may not
     have been initialized yet.

     In the case of a constant, it is safe to assume that the rtl is a
     `mem' whose address is a `symbol_ref'.  Most decls will also have
     this form, but that is not guaranteed.  Global register variables,
     for instance, will have a `reg' for their rtl.  (Normally the
     right thing to do with such unusual rtl is leave it alone.)

     The NEW_DECL_P argument will be true if this is the first time
     that `TARGET_ENCODE_SECTION_INFO' has been invoked on this decl.
     It will be false for subsequent invocations, which will happen for
     duplicate declarations.  Whether or not anything must be done for
     the duplicate declaration depends on whether the hook examines
     `DECL_ATTRIBUTES'.  NEW_DECL_P is always true when the hook is
     called for a constant.

     The usual thing for this hook to do is to record flags in the
     `symbol_ref', using `SYMBOL_REF_FLAG' or `SYMBOL_REF_FLAGS'.
     Historically, the name string was modified if it was necessary to
     encode more than one bit of information, but this practice is now
     discouraged; use `SYMBOL_REF_FLAGS'.

     The default definition of this hook, `default_encode_section_info'
     in `varasm.c', sets a number of commonly-useful bits in
     `SYMBOL_REF_FLAGS'.  Check whether the default does what you need
     before overriding it.

 -- Target Hook: const char *TARGET_STRIP_NAME_ENCODING (const char
          *name)
     Decode NAME and return the real name part, sans the characters
     that `TARGET_ENCODE_SECTION_INFO' may have added.

 -- Target Hook: bool TARGET_IN_SMALL_DATA_P (tree EXP)
     Returns true if EXP should be placed into a "small data" section.
     The default version of this hook always returns false.

 -- Variable: Target Hook bool TARGET_HAVE_SRODATA_SECTION
     Contains the value true if the target places read-only "small
     data" into a separate section.  The default value is false.

 -- Target Hook: bool TARGET_BINDS_LOCAL_P (tree EXP)
     Returns true if EXP names an object for which name resolution
     rules must resolve to the current "module" (dynamic shared library
     or executable image).

     The default version of this hook implements the name resolution
     rules for ELF, which has a looser model of global name binding
     than other currently supported object file formats.

 -- Variable: Target Hook bool TARGET_HAVE_TLS
     Contains the value true if the target supports thread-local
     storage.  The default value is false.


File: gccint.info,  Node: PIC,  Next: Assembler Format,  Prev: Sections,  Up: Target Macros

15.20 Position Independent Code
===============================

This section describes macros that help implement generation of position
independent code.  Simply defining these macros is not enough to
generate valid PIC; you must also add support to the macros
`GO_IF_LEGITIMATE_ADDRESS' and `PRINT_OPERAND_ADDRESS', as well as
`LEGITIMIZE_ADDRESS'.  You must modify the definition of `movsi' to do
something appropriate when the source operand contains a symbolic
address.  You may also need to alter the handling of switch statements
so that they use relative addresses.

 -- Macro: PIC_OFFSET_TABLE_REGNUM
     The register number of the register used to address a table of
     static data 