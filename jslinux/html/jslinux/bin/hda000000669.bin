ree node or 0 if that is not known
     (which happens for C support library functions); and NAMED, which
     is 1 for an ordinary argument and 0 for nameless arguments that
     correspond to `...' in the called function's prototype.  TYPE can
     be an incomplete type if a syntax error has previously occurred.

     The value of the expression is usually either a `reg' RTX for the
     hard register in which to pass the argument, or zero to pass the
     argument on the stack.

     For machines like the VAX and 68000, where normally all arguments
     are pushed, zero suffices as a definition.

     The value of the expression can also be a `parallel' RTX.  This is
     used when an argument is passed in multiple locations.  The mode
     of the `parallel' should be the mode of the entire argument.  The
     `parallel' holds any number of `expr_list' pairs; each one
     describes where part of the argument is passed.  In each
     `expr_list' the first operand must be a `reg' RTX for the hard
     register in which to pass this part of the argument, and the mode
     of the register RTX indicates how large this part of the argument
     is.  The second operand of the `expr_list' is a `const_int' which
     gives the offset in bytes into the entire argument of where this
     part starts.  As a special exception the first `expr_list' in the
     `parallel' RTX may have a first operand of zero.  This indicates
     that the entire argument is also stored on the stack.

     The last time this macro is called, it is called with `MODE ==
     VOIDmode', and its result is passed to the `call' or `call_value'
     pattern as operands 2 and 3 respectively.

     The usual way to make the ISO library `stdarg.h' work on a machine
     where some arguments are usually passed in registers, is to cause
     nameless arguments to be passed on the stack instead.  This is done
     by making `FUNCTION_ARG' return 0 whenever NAMED is 0.

     You may use the hook `targetm.calls.must_pass_in_stack' in the
     definition of this macro to determine if this argument is of a
     type that must be passed in the stack.  If `REG_PARM_STACK_SPACE'
     is not defined and `FUNCTION_ARG' returns nonzero for such an
     argument, the compiler will abort.  If `REG_PARM_STACK_SPACE' is
     defined, the argument will be computed in the stack and then
     loaded into a register.

 -- Target Hook: bool TARGET_MUST_PASS_IN_STACK (enum machine_mode
          MODE, tree TYPE)
     This target hook should return `true' if we should not pass TYPE
     solely in registers.  The file `expr.h' defines a definition that
     is usually appropriate, refer to `expr.h' for additional
     documentation.

 -- Macro: FUNCTION_INCOMING_ARG (CUM, MODE, TYPE, NAMED)
     Define this macro if the target machine has "register windows", so
     that the register in which a function sees an arguments is not
     necessarily the same as the one in which the caller passed the
     argument.

     For such machines, `FUNCTION_ARG' computes the register in which
     the caller passes the value, and `FUNCTION_INCOMING_ARG' should be
     defined in a similar fashion to tell the function being called
     where the arguments will arrive.

     If `FUNCTION_INCOMING_ARG' is not defined, `FUNCTION_ARG' serves
     both purposes.

 -- Target Hook: int TARGET_ARG_PARTIAL_BYTES (CUMULATIVE_ARGS *CUM,
          enum machine_mode MODE, tree TYPE, bool NAMED)
     This target hook returns the number of bytes at the beginning of an
     argument that must be put in registers.  The value must be zero for
     arguments that are passed entirely in registers or that are
     entirely pushed on the stack.

     On some machines, certain arguments must be passed partially in
     registers and partially in memory.  On these machines, typically
     the first few words of arguments are passed in registers, and the
     rest on the stack.  If a multi-word argument (a `double' or a
     structure) crosses that boundary, its first few words must be
     passed in registers and the rest must be pushed.  This macro tells
     the compiler when this occurs, and how many bytes should go in
     registers.

     `FUNCTION_ARG' for these arguments should return the first
     register to be used by the caller for this argument; likewise
     `FUNCTION_INCOMING_ARG', for the called function.

 -- Target Hook: bool TARGET_PASS_BY_REFERENCE (CUMULATIVE_ARGS *CUM,
          enum machine_mode MODE, tree TYPE, bool NAMED)
     This target hook should return `true' if an argument at the
     position indicated by CUM should be passed by reference.  This
     predicate is queried after target independent reasons for being
     passed by reference, such as `TREE_ADDRESSABLE (type)'.

     If the hook returns true, a copy of that argument is made in
     memory and a pointer to the argument is passed instead of the
     argument itself.  The pointer is passed in whatever way is
     appropriate for passing a pointer to that type.

 -- Target Hook: bool TARGET_CALLEE_COPIES (CUMULATIVE_ARGS *CUM, enum
          machine_mode MODE, tree TYPE, bool NAMED)
     The function argument described by the parameters to this hook is
     known to be passed by reference.  The hook should return true if
     the function argument should be copied by the callee instead of
     copied by the caller.

     For any argument for which the hook returns true, if it can be
     determined that the argument is not modified, then a copy need not
     be generated.

     The default version of this hook always returns false.

 -- Macro: CUMULATIVE_ARGS
     A C type for declaring a variable that is used as the first
     argument of `FUNCTION_ARG' and other related values.  For some
     target machines, the type `int' suffices and can hold the number
     of bytes of argument so far.

     There is no need to record in `CUMULATIVE_ARGS' anything about the
     arguments that have been passed on the stack.  The compiler has
     other variables to keep track of that.  For target machines on
     which all arguments are passed on the stack, there is no need to
     store anything in `CUMULATIVE_ARGS'; however, the data structure
     must exist and should not be empty, so use `int'.

 -- Macro: INIT_CUMULATIVE_ARGS (CUM, FNTYPE, LIBNAME, FNDECL,
          N_NAMED_ARGS)
     A C statement (sans semicolon) for initializing the variable CUM
     for the state at the beginning of the argument list.  The variable
     has type `CUMULATIVE_ARGS'.  The value of FNTYPE is the tree node
     for the data type of the function which will receive the args, or
     0 if the args are to a compiler support library function.  For
     direct calls that are not libcalls, FNDECL contain the declaration
     node of the function.  FNDECL is also set when
     `INIT_CUMULATIVE_ARGS' is used to find arguments for the function
     being compiled.  N_NAMED_ARGS is set to the number of named
     arguments, including a structure return address if it is passed as
     a parameter, when making a call.  When processing incoming
     arguments, N_NAMED_ARGS is set to -1.

     When processing a call to a compiler support library function,
     LIBNAME identifies which one.  It is a `symbol_ref' rtx which
     contains the name of the function, as a string.  LIBNAME is 0 when
     an ordinary C function call is being processed.  Thus, each time
     this macro is called, either LIBNAME or FNTYPE is nonzero, but
     never both of them at once.

 -- Macro: INIT_CUMULATIVE_LIBCALL_ARGS (CUM, MODE, LIBNAME)
     Like `INIT_CUMULATIVE_ARGS' but only used for outgoing libcalls,
     it gets a `MODE' argument instead of FNTYPE, that would be `NULL'.
     INDIRECT would always be zero, too.  If this macro is not defined,
     `INIT_CUMULATIVE_ARGS (cum, NULL_RTX, libname, 0)' is used instead.

 -- Macro: INIT_CUMULATIVE_INCOMING_ARGS (CUM, FNTYPE, LIBNAME)
     Like `INIT_CUMULATIVE_ARGS' but overrides it for the purposes of
     finding the arguments for the function being compiled.  If this
     macro is undefined, `INIT_CUMULATIVE_ARGS' is used instead.

     The value passed for LIBNAME is always 0, since library routines
     with special calling conventions are never compiled with GCC.  The
     argument LIBNAME exists for symmetry with `INIT_CUMULATIVE_ARGS'.

 -- Macro: FUNCTION_ARG_ADVANCE (CUM, MODE, TYPE, NAMED)
     A C statement (sans semicolon) to update the summarizer variable
     CUM to advance past an argument in the argument list.  The values
     MODE, TYPE and NAMED describe that argument.  Once this is done,
     the variable CUM is suitable for analyzing the _following_
     argument with `FUNCTION_ARG', etc.

     This macro need not do anything if the argument in question was
     passed on the stack.  The compiler knows how to track the amount
     of stack space used for arguments without any special help.

 -- Macro: FUNCTION_ARG_PADDING (MODE, TYPE)
     If defined, a C expression which determines whether, and in which
     direction, to pad out an argument with extra space.  The value
     should be of type `enum direction': either `upward' to pad above
     the argument, `downward' to pad below, or `none' to inhibit
     padding.

     The _amount_ of padding is always just enough to reach the next
     multiple of `FUNCTION_ARG_BOUNDARY'; this macro does not control
     it.

     This macro has a default definition which is right for most
     systems.  For little-endian machines, the default is to pad
     upward.  For big-endian machines, the default is to pad downward
     for an argument of constant size shorter than an `int', and upward
     otherwise.

 -- Macro: PAD_VARARGS_DOWN
     If defined, a C expression which determines whether the default
     implementation of va_arg will attempt to pad down before reading
     the next argument, if that argument is smaller than its aligned
     space as controlled by `PARM_BOUNDARY'.  If this macro is not
     defined, all such arguments are padded down if `BYTES_BIG_ENDIAN'
     is true.

 -- Macro: BLOCK_REG_PADDING (MODE, TYPE, FIRST)
     Specify padding for the last element of a block move between
     registers and memory.  FIRST is nonzero if this is the only
     element.  Defining this macro allows better control of register
     function parameters on big-endian machines, without using
     `PARALLEL' rtl.  In particular, `MUST_PASS_IN_STACK' need not test
     padding and mode of types in registers, as there is no longer a
     "wrong" part of a register;  For example, a three byte aggregate
     may be passed in the high part of a register if so required.

 -- Macro: FUNCTION_ARG_BOUNDARY (MODE, TYPE)
     If defined, a C expression that gives the alignment boundary, in
     bits, of an argument with the specified mode and type.  If it is
     not defined, `PARM_BOUNDARY' is used for all arguments.

 -- Macro: FUNCTION_ARG_REGNO_P (REGNO)
     A C expression that is nonzero if REGNO is the number of a hard
     register in which function arguments are sometimes passed.  This
     does _not_ include implicit arguments such as the static chain and
     the structure-value address.  On many machines, no registers can be
     used for this purpose since all function arguments are pushed on
     the stack.

 -- Target Hook: bool TARGET_SPLIT_COMPLEX_ARG (tree TYPE)
     This hook should return true if parameter of type TYPE are passed
     as two scalar parameters.  By default, GCC will attempt to pack
     complex arguments into the target's word size.  Some ABIs require
     complex arguments to be split and treated as their individual
     components.  For example, on AIX64, complex floats should be
     passed in a pair of floating point registers, even though a
     complex float would fit in one 64-bit floating point register.

     The default value of this hook is `NULL', which is treated as
     always false.

 -- Target Hook: tree TARGET_BUILD_BUILTIN_VA_LIST (void)
     This hook returns a type node for `va_list' for the target.  The
     default version of the hook returns `void*'.

 -- Target Hook: tree TARGET_GIMPLIFY_VA_ARG_EXPR (tree VALIST, tree
          TYPE, tree *PRE_P, tree *POST_P)
     This hook performs target-specific gimplification of
     `VA_ARG_EXPR'.  The first two parameters correspond to the
     arguments to `va_arg'; the latter two are as in
     `gimplify.c:gimplify_expr'.

 -- Target Hook: bool TARGET_VALID_POINTER_MODE (enum machine_mode MODE)
     Define this to return nonzero if the port can handle pointers with
     machine mode MODE.  The default version of this hook returns true
     for both `ptr_mode' and `Pmode'.

 -- Target Hook: bool TARGET_SCALAR_MODE_SUPPORTED_P (enum machine_mode
          MODE)
     Define this to return nonzero if the port is prepared to handle
     insns involving scalar mode MODE.  For a scalar mode to be
     considered supported, all the basic arithmetic and comparisons
     must work.

     The default version of this hook returns true for any mode
     required to handle the basic C types (as defined by the port).
     Included here are the double-word arithmetic supported by the code
     in `optabs.c'.

 -- Target Hook: bool TARGET_VECTOR_MODE_SUPPORTED_P (enum machine_mode
          MODE)
     Define this to return nonzero if the port is prepared to handle
     insns involving vector mode MODE.  At the very least, it must have
     move patterns for this mode.


File: gccint.info,  Node: Scalar Return,  Next: Aggregate Return,  Prev: Register Arguments,  Up: Stack and Calling

15.10.8 How Scalar Function Values Are Returned
-----------------------------------------------

This section discusses the macros that control returning scalars as
values--values that can fit in registers.

 -- Target Hook: rtx TARGET_FUNCTION_VALUE (tree RET_TYPE, tree
          FN_DECL_OR_TYPE, bool OUTGOING)
     Define this to return an RTX representing the place where a
     function returns or receives a value of data type RET_TYPE, a tree
     node node representing a data type.  FN_DECL_OR_TYPE is a tree node
     representing `FUNCTION_DECL' or `FUNCTION_TYPE' of a function
     being called.  If OUTGOING is false, the hook should compute the
     register in which the caller will see the return value.
     Otherwise, the hook should return an RTX representing the place
     where a function returns a value.

     On many machines, only `TYPE_MODE (RET_TYPE)' is relevant.
     (Actually, on most machines, scalar values are returned in the same
     place regardless of mode.)  The value of the expression is usually
     a `reg' RTX for the hard register where the return value is stored.
     The value can also be a `parallel' RTX, if the return value is in
     multiple places.  See `FUNCTION_ARG' for an explanation of the
     `parallel' form.   Note that the callee will populate every
     location specified in the `parallel', but if the first element of
     the `parallel' contains the whole return value, callers will use
     that element as the canonical location and ignore the others.  The
     m68k port uses this type of `parallel' to return pointers in both
     `%a0' (the canonical location) and `%d0'.

     If `TARGET_PROMOTE_FUNCTION_RETURN' returns true, you must apply
     the same promotion rules specified in `PROMOTE_MODE' if VALTYPE is
     a scalar type.

     If the precise function being called is known, FUNC is a tree node
     (`FUNCTION_DECL') for it; otherwise, FUNC is a null pointer.  This
     makes it possible to use a different value-returning convention
     for specific functions when all their calls are known.

     Some target machines have "register windows" so that the register
     in which a function returns its value is not the same as the one
     in which the caller sees the value.  For such machines, you should
     return different RTX depending on OUTGOING.

     `TARGET_FUNCTION_VALUE' is not used for return values with
     aggregate data types, because these are returned in another way.
     See `TARGET_STRUCT_VALUE_RTX' and related macros, below.

 -- Macro: FUNCTION_VALUE (VALTYPE, FUNC)
     This macro has been deprecated.  Use `TARGET_FUNCTION_VALUE' for a
     new target instead.

 -- Macro: FUNCTION_OUTGOING_VALUE (VALTYPE, FUNC)
     This macro has been deprecated.  Use `TARGET_FUNCTION_VALUE' for a
     new target instead.

 -- Macro: LIBCALL_VALUE (MODE)
     A C expression to create an RTX representing the place where a
     library function returns a value of mode MODE.  If the precise
     function being called is known, FUNC is a tree node
     (`FUNCTION_DECL') for it; otherwise, FUNC is a null pointer.  This
     makes it possible to use a different value-returning convention
     for specific functions when all their calls are known.

     Note that "library function" in this context means a compiler
     support routine, used to perform arithmetic, whose name is known
     specially by the compiler and was not mentioned in the C code being
     compiled.

     The definition of `LIBRARY_VALUE' need not be concerned aggregate
     data types, because none of the library functions returns such
     types.

 -- Macro: FUNCTION_VALUE_REGNO_P (REGNO)
     A C expression that is nonzero if REGNO is the number of a hard
     register in which the values of called function may come back.

     A register whose use for returning values is limited to serving as
     the second of a pair (for a value of type `double', say) need not
     be recognized by this macro.  So for most machines, this definition
     suffices:

          #define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)

     If the machine has register windows, so that the caller and the
     called function use different registers for the return value, this
     macro should recognize only the caller's register numbers.

 -- Macro: APPLY_RESULT_SIZE
     Define this macro if `untyped_call' and `untyped_return' need more
     space than is implied by `FUNCTION_VALUE_REGNO_P' for saving and
     restoring an arbitrary return value.

 -- Target Hook: bool TARGET_RETURN_IN_MSB (tree TYPE)
     This hook should return true if values of type TYPE are returned
     at the most significant end of a register (in other words, if they
     are padded at the least significant end).  You can assume that TYPE
     is returned in a register; the caller is required to check this.

     Note that the register provided by `TARGET_FUNCTION_VALUE' must be
     able to hold the complete return value.  For example, if a 1-, 2-
     or 3-byte structure is returned at the most significant end of a
     4-byte register, `TARGET_FUNCTION_VALUE' should provide an
     `SImode' rtx.


File: gccint.info,  Node: Aggregate Return,  Next: Caller Saves,  Prev: Scalar Return,  Up: Stack and Calling

15.10.9 How Large Values Are Returned
-------------------------------------

When a function value's mode is `BLKmode' (and in some other cases),
the value is not returned according to `TARGET_FUNCTION_VALUE' (*note
Scalar Return::).  Instead, the caller passes the address of a block of
memory in which the value should be stored.  This address is called the
"structure value address".

 This section describes how to control returning structure values in
memory.

 -- Target Hook: bool TARGET_RETURN_IN_MEMORY (tree TYPE, tree FNTYPE)
     This target hook should return a nonzero value to say to return the
     function value in memory, just as large structures are always
     returned.  Here TYPE will be the data type of the value, and FNTYPE
     will be the type of the function doing the returning, or `NULL' for
     libcalls.

     Note that values of mode `BLKmode' must be explicitly handled by
     this function.  Also, the option `-fpcc-struct-return' takes
     effect regardless of this macro.  On most systems, it is possible
     to leave the hook undefined; this causes a default definition to
     be used, whose value is the constant 1 for `BLKmode' values, and 0
     otherwise.

     Do not use this hook to indicate that structures and unions should
     always be returned in memory.  You should instead use
     `DEFAULT_PCC_STRUCT_RETURN' to indicate this.

 -- Macro: DEFAULT_PCC_STRUCT_RETURN
     Define this macro to be 1 if all structure and union return values
     must be in memory.  Since this results in slower code, this should
     be defined only if needed for compatibility with other compilers
     or with an ABI.  If you define this macro to be 0, then the
     conventions used for structure and union return values are decided
     by the `TARGET_RETURN_IN_MEMORY' target hook.

     If not defined, this defaults to the value 1.

 -- Target Hook: rtx TARGET_STRUCT_VALUE_RTX (tree FNDECL, int INCOMING)
     This target hook should return the location of the structure value
     address (normally a `mem' or `reg'), or 0 if the address is passed
     as an "invisible" first argument.  Note that FNDECL may be `NULL',
     for libcalls.  You do not need to define this target hook if the
     address is always passed as an "invisible" first argument.

     On some architectures the place where the structure value address
     is found by the called function is not the same place that the
     caller put it.  This can be due to register windows, or it could
     be because the function prologue moves it to a different place.
     INCOMING is `1' or `2' when the location is needed in the context
     of the called function, and `0' in the context of the caller.

     If INCOMING is nonzero and the address is to be found on the
     stack, return a `mem' which refers to the frame pointer. If
     INCOMING is `2', the result is being used to fetch the structure
     value address at the beginning of a function.  If you need to emit
     adjusting code, you should do it at this point.

 -- Macro: PCC_STATIC_STRUCT_RETURN
     Define this macro if the usual system convention on the target
     machine for returning structures and unions is for the called
     function to return the address of a static variable containing the
     value.

     Do not define this if the usual system convention is for the
     caller to pass an address to the subroutine.

     This macro has effect in `-fpcc-struct-return' mode, but it does
     nothing when you use `-freg-struct-return' mode.


File: gccint.info,  Node: Caller Saves,  Next: Function Entry,  Prev: Aggregate Return,  Up: Stack and Calling

15.10.10 Caller-Saves Register Allocation
-----------------------------------------

If you enable it, GCC can save registers around function calls.  This
makes it possible to use call-clobbered registers to hold variables that
must live across calls.

 -- Macro: CALLER_SAVE_PROFITABLE (REFS, CALLS)
     A C expression to determine whether it is worthwhile to consider
     placing a pseudo-register in a call-clobbered hard register and
     saving and restoring it around each function call.  The expression
     should be 1 when this is worth doing, and 0 otherwise.

     If you don't define this macro, a default is used which is good on
     most machines: `4 * CALLS < REFS'.

 -- Macro: HARD_REGNO_CALLER_SAVE_MODE (REGNO, NREGS)
     A C expression specifying which mode is required for saving NREGS
     of a pseudo-register in call-clobbered hard register REGNO.  If
     REGNO is unsuitable for caller save, `VOIDmode' should be
     returned.  For most machines this macro need not be defined since
     GCC will select the smallest suitable mode.


File: gccint.info,  Node: Function Entry,  Next: Profiling,  Prev: Caller Saves,  Up: Stack and Calling

15.10.11 Function Entry and Exit
--------------------------------

This section describes the macros that output function entry
("prologue") and exit ("epilogue") code.

 -- Target Hook: void TARGET_ASM_FUNCTION_PROLOGUE (FILE *FILE,
          HOST_WIDE_INT SIZE)
     If defined, a function that outputs the assembler code for entry
     to a function.  The prologue is responsible for setting up the
     stack frame, initializing the frame pointer register, saving
     registers that must be saved, and allocating SIZE additional bytes
     of storage for the local variables.  SIZE is an integer.  FILE is
     a stdio stream to which the assembler code should be output.

     The label for the beginning of the function need not be output by
     this macro.  That has already been done when the macro is run.

     To determine which registers to save, the macro can refer to the
     array `regs_ever_live': element R is nonzero if hard register R is
     used anywhere within the function.  This implies the function
     prologue should save register R, provided it is not one of the
     call-used registers.  (`TARGET_ASM_FUNCTION_EPILOGUE' must
     likewise use `regs_ever_live'.)

     On machines that have "register windows", the function entry code
     does not save on the stack the registers that are in the windows,
     even if they are supposed to be preserved by function calls;
     instead it takes appropriate steps to "push" the register stack,
     if any non-call-used registers are used in the function.

     On machines where functions may or may not have frame-pointers, the
     function entry code must vary accordingly; it must set up the frame
     pointer if one is wanted, and not otherwise.  To determine whether
     a frame pointer is in wanted, the macro can refer to the variable
     `frame_pointer_needed'.  The variable's value will be 1 at run
     time in a function that needs a frame pointer.  *Note
     Elimination::.

     The function entry code is responsible for allocating any stack
     space required for the function.  This stack space consists of the
     regions listed below.  In most cases, these regions are allocated
     in the order listed, with the last listed region closest to the
     top of the stack (the lowest address if `STACK_GROWS_DOWNWARD' is
     defined, and the highest address if it is not defined).  You can
     use a different order for a machine if doing so is more convenient
     or required for compatibility reasons.  Except in cases where
     required by standard or by a debugger, there is no reason why the
     stack layout used by GCC need agree with that used by other
     compilers for a machine.

 -- Target Hook: void TARGET_ASM_FUNCTION_END_PROLOGUE (FILE *FILE)
     If defined, a function that outputs assembler code at the end of a
     prologue.  This should be used when the function prologue is being
     emitted as RTL, and you have some extra assembler that needs to be
     emitted.  *Note prologue instruction pattern::.

 -- Target Hook: void TARGET_ASM_FUNCTION_BEGIN_EPILOGUE (FILE *FILE)
     If defined, a function that outputs assembler code at the start of
     an epilogue.  This should be used when the function epilogue is
     being emitted as RTL, and you have some extra assembler that needs
     to be emitted.  *Note epilogue instruction pattern::.

 -- Target Hook: void TARGET_ASM_FUNCTION_EPILOGUE (FILE *FILE,
          HOST_WIDE_INT SIZE)
     If defined, a function that outputs the assembler code for exit
     from a function.  The epilogue is responsible for restoring the
     saved registers and stack pointer to their values when the
     function was called, and returning control to the caller.  This
     macro takes the same arguments as the macro
     `TARGET_ASM_FUNCTION_PROLOGUE', and the registers to restore are
     determined from `regs_ever_live' and `CALL_USED_REGISTERS' in the
     same way.

     On some machines, there is a single instruction that does all the
     work of returning from the function.  On these machines, give that
     instruction the name `return' and do not define the macro
     `TARGET_ASM_FUNCTION_EPILOGUE' at all.

     Do not define a pattern named `return' if you want the
     `TARGET_ASM_FUNCTION_EPILOGUE' to be used.  If you want the target
     switches to control whether return instructions or epilogues are
     used, define a `return' pattern with a validity condition that
     tests the target switches appropriately.  If the `return'
     pattern's validity condition is false, epilogues will be used.

     On machines where functions may or may not have frame-pointers, the
     function exit code must vary accordingly.  Sometimes the code for
     these two cases is completely different.  To determine whether a
     frame pointer is wanted, the macro can refer to the variable
     `frame_pointer_needed'.  The variable's value will be 1 when
     compiling a function that needs a frame pointer.

     Normally, `TARGET_ASM_FUNCTION_PROLOGUE' and
     `TARGET_ASM_FUNCTION_EPILOGUE' must treat leaf functions specially.
     The C variable `current_function_is_leaf' is nonzero for such a
     function.  *Note Leaf Functions::.

     On some machines, some functions pop their arguments on exit while
     others leave that for the caller to do.  For example, the 68020
     when given `-mrtd' pops arguments in functions that take a fixed
     number of arguments.

     Your definition of the macro `RETURN_POPS_ARGS' decides which
     functions pop their own arguments.  `TARGET_ASM_FUNCTION_EPILOGUE'
     needs to know what was decided.  The variable that is called
     `current_function_pops_args' is the number of bytes of its
     arguments that a function should pop.  *Note Scalar Return::.

   * A region of `current_function_pretend_args_size' bytes of
     uninitialized space just underneath the first argument arriving on
     the stack.  (This may not be at the very start of the allocated
     stack region if the calling sequence has pushed anything else
     since pushing the stack arguments.  But usually, on such machines,
     nothing else has been pushed yet, because the function prologue
     itself does all the pushing.)  This region is used on machines
     where an argument may be passed partly in registers and partly in
     memory, and, in some cases to support the features in `<stdarg.h>'.

   * An area of memory used to save certain registers used by the
     function.  The size of this area, which may also include space for
     such things as the return address and pointers to previous stack
     frames, is machine-specific and usually depends on which registers
     have been used in the function.  Machines with register windows
     often do not require a save area.

   * A region of at least SIZE bytes, possibly rounded up to an
     allocation boundary, to contain the local variables of the
     function.  On some machines, this region and the save area may
     occur in the opposite order, with the save area closer to the top
     of the stack.

   * Optionally, when `ACCUMULATE_OUTGOING_ARGS' is defined, a region of
     `current_function_outgoing_args_size' bytes to be used for outgoing
     argument lists of the function.  *Note Stack Arguments::.

 -- Macro: EXIT_IGNORE_STACK
     Define this macro as a C expression that is nonzero if the return
     instruction or the function epilogue ignores the value of the stack
     pointer; in other words, if it is safe to delete an instruction to
     adjust the stack pointer before a return from the function.  The
     default is 0.

     Note that this macro's value is relevant only for functions for
     which frame pointers are maintained.  It is never safe to delete a
     final stack adjustment in a function that has no frame pointer,
     and the compiler knows this regardless of `EXIT_IGNORE_STACK'.

 -- Macro: EPILOGUE_USES (REGNO)
     Define this macro as a C expression that is nonzero for registers
     that are used by the epilogue or the `return' pattern.  The stack
     and frame pointer registers are already assumed to be used as
     needed.

 -- Macro: EH_USES (REGNO)
     Define this macro as a C expression that is nonzero for registers
     that are used by the exception handling mechanism, and so should
     be considered live on entry to an exception edge.

 -- Macro: DELAY_SLOTS_FOR_EPILOGUE
     Define this macro if the function epilogue contains delay slots to
     which instructions from the rest of the function can be "moved".
     The definition should be a C expression whose value is an integer
     representing the number of delay slots there.

 -- Macro: ELIGIBLE_FOR_EPILOGUE_DELAY (INSN, N)
     A C expression that returns 1 if INSN can be placed in delay slot
     number N of the epilogue.

     The argument N is an integer which identifies the delay slot now
     being considered (since different slots may have different rules of
     eligibility).  It is never negative and is always less than the
     number of epilogue delay slots (what `DELAY_SLOTS_FOR_EPILOGUE'
     returns).  If you reject a particular insn for a given delay slot,
     in principle, it may be reconsidered for a subsequent delay slot.
     Also, other insns may (at least in principle) be considered for
     the so far unfilled delay slot.

     The insns accepted to fill the epilogue delay slots are put in an
     RTL list made with `insn_list' objects, stored in the variable
     `current_function_epilogue_delay_list'.  The insn for the first
     delay slot comes first in the list.  Your definition of the macro
     `TARGET_ASM_FUNCTION_EPILOGUE' should fill the delay slots by
     outputting the insns in this list, usually by calling
     `final_scan_insn'.

     You need not define this macro if you did not define
     `DELAY_SLOTS_FOR_EPILOGUE'.

 -- Target Hook: void TARGET_ASM_OUTPUT_MI_THUNK (FILE *FILE, tree
          THUNK_FNDECL, HOST_WIDE_INT DELTA, HOST_WIDE_INT
          VCALL_OFFSET, tree FUNCTION)
     A function that outputs the assembler code for a thunk function,
     used to implement C++ virtual function calls with multiple
     inheritance.  The thunk acts as a wrapper around a virtual
     function, adjusting the implicit object parameter before handing
     control off to the real function.

     First, emit code to add the integer DELTA to the location that
     contains the incoming first argument.  Assume that this argument
     contains a pointer, and is the one used to pass the `this' pointer
     in C++.  This is the incoming argument _before_ the function
     prologue, e.g. `%o0' on a sparc.  The addition must preserve the
     values of all other incoming arguments.

     Then, if VCALL_OFFSET is nonzero, an additional adjustment should
     be made after adding `delta'.  In particular, if P is the adjusted
     pointer, the following adjustment should be made:

          p += (*((ptrdiff_t **)p))[vcall_offset/sizeof(ptrdiff_t)]

     After the additions, emit code to jump to FUNCTION, which is a
     `FUNCTION_DECL'.  This is a direct pure jump, not a call, and does
     not touch the return address.  Hence returning from FUNCTION will
     return to whoever called the current `thunk'.

     The effect must be as if FUNCTION had been called directly with
     the adjusted first argument.  This macro is responsible for
     emitting all of the code for a thunk function;
     `TARGET_ASM_FUNCTION_PROLOGUE' and `TARGET_ASM_FUNCTION_EPILOGUE'
     are not invoked.

     The THUNK_FNDECL is redundant.  (DELTA and FUNCTION have already
     been extracted from it.)  It might possibly be useful on some
     targets, but probably not.

     If you do not define this macro, the target-independent code in
     the C++ front end will generate a less efficient heavyweight thunk
     that calls FUNCTION instead of jumping to it.  The generic
     approach does not support varargs.

 -- Target Hook: bool TARGET_ASM_CAN_OUTPUT_MI_THUNK (tree
          THUNK_FNDECL, HOST_WIDE_INT DELTA, HOST_WIDE_INT
          VCALL_OFFSET, tree FUNCTION)
     A function that returns true if TARGET_ASM_OUTPUT_MI_THUNK would
     be able to output the assembler code for the thunk function
     specified by the arguments it is passed, and false otherwise.  In
     the latter case, the generic approach will be used by the C++
     front end, with the limitations previously exposed.


File: gccint.info,  Node: Profiling,  Next: Tail Calls,  Prev: Function Entry,  Up: Stack and Calling

15.10.12 Generating Code for Profiling
--------------------------------------

These macros will help you generate code for profiling.

 -- Macro: FUNCTION_PROFILER (FILE, LABELNO)
     A C statement or compound statement to output to FILE some
     assembler code to call the profiling subroutine `mcount'.

     The details of how `mcount' expects to be called are determined by
     your operating system environment, not by GCC.  To figure them out,
     compile a small program for profiling using the system's installed
     C compiler and look at the assembler code that results.

     Older implementations of `mcount' expect the address of a counter
     variable to be loaded into some register.  The name of this
     variable is `LP' followed by the number LABELNO, so you would
     generate the name using `LP%d' in a `fprintf'.

 -- Macro: PROFILE_HOOK
     A C statement or compound statement to output to FILE some assembly
     code to call the profiling subroutine `mcount' even the target does
     not support profiling.

 -- Macro: NO_PROFILE_COUNTERS
     Define this macro to be an expression with a nonzero value if the
     `mcount' subroutine on your system does not need a counter variable
     allocated for each function.  This is true for almost all modern
     implementations.  If you define this macro, you must not use the
     LABELNO argument to `FUNCTION_PROFILER'.

 -- Macro: PROFILE_BEFORE_PROLOGUE
     Define this macro if the code for function profiling should come
     before the function prologue.  Normally, the profiling code comes
     after.


File: gccint.info,  Node: Tail Calls,  Next: Stack Smashing Protection,  Prev: Profiling,  Up: Stack and Calling

15.10.13 Permitting tail calls
------------------------------

 -- Target Hook: bool TARGET_FUNCTION_OK_FOR_SIBCALL (tree DECL, tree
          EXP)
     True if it is ok to do sibling call optimization for the specified
     call expression EXP.  DECL will be the called function, or `NULL'
     if this is an indirect call.

     It is not uncommon for limitations of calling conventions to
     prevent tail calls to functions outside the current unit of
     translation, or during PIC compilation.  The hook is used to
     enforce these restrictions, as the `sibcall' md pattern can not
     fail, or fall over to a "normal" call.  The criteria for
     successful sibling call optimization may vary greatly between
     different architectures.

 -- Target Hook: void TARGET_EXTRA_LIVE_ON_ENTRY (bitmap *REGS)
     Add any hard registers to REGS that are live on entry to the
     function.  This hook only needs to be defined to provide registers
     that cannot be found by examination of FUNCTION_ARG_REGNO_P, the
     callee saved registers, STATIC_CHAIN_INCOMING_REGNUM,
     STATIC_CHAIN_REGNUM, TARGET_STRUCT_VALUE_RTX,
     FRAME_POINTER_REGNUM, EH_USES, FRAME_POINTER_REGNUM,
     ARG_POINTER_REGNUM, and the PIC_OFFSET_TABLE_REGNUM.


File: gccint.info,  Node: Stack Smashing Protection,  Prev: Tail Calls,  Up: Stack and Calling

15.10.14 Stack smashing protection
----------------------------------

 -- Target Hook: tree TARGET_STACK_PROTECT_GUARD (void)
     This hook returns a `DECL' node for the external variable to use
     for the stack protection guard.  This variable is initialized by
     the runtime to some random value and is used to initialize the
     guard value that is placed at the top of the local stack frame.
     The type of this variable must be `ptr_type_node'.

     The default version of this hook creates a variable called
     `__stack_chk_guard', which is normally defined in `libgcc2.c'.

 -- Target Hook: tree TARGET_STACK_PROTECT_FAIL (void)
     This hook returns a tree expression that alerts the runtime that
     the stack protect guard variable has been modified.  This
     expression should involve a call to a `noreturn' function.

     The default version of this hook invokes a function called
     `__stack_chk_fail', taking no arguments.  This function is
     normally defined in `libgcc2.c'.


File: gccint.info,  Node: Varargs,  Next: Trampolines,  Prev: Stack and Calling,  Up: Target Macros

15.11 Implementing the Varargs Macros
=====================================

GCC comes with an implementation of `<varargs.h>' and `<stdarg.h>' that
work without change on machines that pass arguments on the stack.
Other machines require their own implementations of varargs, and the
two machine independent header files must have conditionals to include
it.

 ISO `<stdarg.h>' differs from traditional `<varargs.h>' mainly in the
calling convention for `va_start'.  The traditional implementation
takes just one argument, which is the variable in which to store the
argument pointer.  The ISO implementation of `va_start' takes an
additional second argument.  The user is supposed to write the last
named argument of the function here.

 However, `va_start' should not use this argument.  The way to find the
end of the named arguments is with the built-in functions described
below.

 -- Macro: __builtin_saveregs ()
     Use this built-in function to save the argument registers in
     memory so that the varargs mechanism can access them.  Both ISO
     and traditional versions of `va_start' must use
     `__builtin_saveregs', unless you use
     `TARGET_SETUP_INCOMING_VARARGS' (see below) instead.

     On some machines, `__builtin_saveregs' is open-coded under the
     control of the target hook `TARGET_EXPAND_BUILTIN_SAVEREGS'.  On
     other machines, it calls a routine written in assembler language,
     found in `libgcc2.c'.

     Code generated for the call to `__builtin_saveregs' appears at the
     beginning of the function, as opposed to where the call to
     `__builtin_saveregs' is written, regardless of what the code is.
     This is because the registers must be saved before the function
     starts to use them for its own purposes.

 -- Macro: __builtin_args_info (CATEGORY)
     Use this built-in function to find the first anonymous arguments in
     registers.

     In general, a machine may have several categories of registers
     used for arguments, each for a particular category of data types.
     (For example, on some machines, floating-point registers are used
     for floating-point arguments while other arguments are passed in
     the general registers.)  To make non-varargs functions use the
     proper calling convention, you have defined the `CUMULATIVE_ARGS'
     data type to record how many registers in each category have been
     used so far

     `__builtin_args_info' accesses the same data structure of type
     `CUMULATIVE_ARGS' after the ordinary argument layout is finished
     with it, with CATEGORY specifying which word to access.  Thus, the
     value indicates the first unused register in a given category.

     Normally, you would use `__builtin_args_info' in the implementation
     of `va_start', accessing each category just once and storing the
     value in the `va_list' object.  This is because `va_list' will
     have to update the values, and there is no way to alter the values
     accessed by `__builtin_args_info'.

 -- Macro: __builtin_next_arg (LASTARG)
     This is the equivalent of `__builtin_args_info', for stack
     arguments.  It returns the address of the first anonymous stack
     argument, as type `void *'.  If `ARGS_GROW_DOWNWARD', it returns
     the address of the location above the first anonymous stack
     argument.  Use it in `va_start' to initialize the pointer for
     fetching arguments from the stack.  Also use it in `va_start' to
     verify that the second parameter LASTARG is the last named argument
     of the current function.

 -- Macro: __builtin_classify_type (OBJECT)
     Since each machine has its own conventions for which data types are
     passed in which kind of register, your implementation of `va_arg'
     has to embody these conventions.  The easiest way to categorize the
     specified data type is to use `__builtin_classify_type' together
     with `sizeof' and `__alignof__'.

     `__builtin_classify_type' ignores the value of OBJECT, considering
     only its data type.  It returns an integer describing what kind of
     type that is--integer, floating, pointer, structure, and so on.

     The file `typeclass.h' defines an enumeration that you can use to
     interpret the values of `__builtin_classify_type'.

 These machine description macros help implement varargs:

 -- Target Hook: rtx TARGET_EXPAND_BUILTIN_SAVEREGS (void)
     If defined, this hook produces the machine-specific code for a
     call to `__builtin_saveregs'.  This code will be moved to the very
     beginning of the function, before any parameter access are made.
     The return value of this function should be an RTX that contains
     the value to use as the return of `__builtin_saveregs'.

 -- Target Hook: void TARGET_SETUP_INCOMING_VARARGS (CUMULATIVE_ARGS
          *ARGS_SO_FAR, enum machine_mode MODE, tree TYPE, int
          *PRETEND_ARGS_SIZE, int SECOND_TIME)
     This target hook offers an alternative to using
     `__builtin_saveregs' and defining the hook
     `TARGET_EXPAND_BUILTIN_SAVEREGS'.  Use it to store the anonymous
     register arguments into the stack so that all the arguments appear
     to have been passed consecutively on the stack.  Once this is
     done, you can use the standard implementation of varargs that
     works for machines that pass all their arguments on the stack.

     The argument ARGS_SO_FAR points to the `CUMULATIVE_ARGS' data
     structure, containing the values that are obtained after
     processing the named arguments.  The arguments MODE and TYPE
     describe the last named argument--its machine mode and its data
     type as a tree node.

     The target hook should do two things: first, push onto the stack
     all the argument registers _not_ used for the named arguments, and
     second, store the size of the data thus pushed into the
     `int'-valued variable pointed to by PRETEND_ARGS_SIZE.  The value
     that you store here will serve as additional offset for setting up
     the stack frame.

     Because you must generate code to push the anonymous arguments at
     compile time without knowing their data types,
     `TARGET_SETUP_INCOMING_VARARGS' is only useful on machines that
     have just a single category of argument register and use it
     uniformly for all data types.

     If the argument SECOND_TIME is nonzero, it means that the
     arguments of the function are being analyzed for the second time.
     This happens for an inline function, which is not actually
     compiled until the end of the source file.  The hook
     `TARGET_SETUP_INCOMING_VARARGS' should not generate any
     instructions in this case.

 -- Target Hook: bool TARGET_STRICT_ARGUMENT_NAMING (CUMULATIVE_ARGS
          *CA)
     Define this hook to return `true' if the location where a function
     argument is passed depends on whether or not it is a named
     argument.

     This hook controls how the NAMED argument to `FUNCTION_ARG' is set
     for varargs and stdarg functions.  If this hook returns `true',
     the NAMED argument is always true for named arguments, and false
     for unnamed arguments.  If it returns `false', but
     `TARGET_PRETEND_OUTGOING_VARARGS_NAMED' returns `true', then all
     arguments are treated as named.  Otherwise, all named arguments
     except the last are treated as named.

     You need not define this hook if it always returns zero.

 -- Target Hook: bool TARGET_PRETEND_OUTGOING_VARARGS_NAMED
     If you need to conditionally change ABIs so that one works with
     `TARGET_SETUP_INCOMING_VARARGS', but the other works like neither
     `TARGET_SETUP_INCOMING_VARARGS' nor
     `TARGET_STRICT_ARGUMENT_NAMING' was defined, then define this hook
     to return `true' if `TARGET_SETUP_INCOMING_VARARGS' is used,
     `false' otherwise.  Otherwise, you should not define this hook.


File: gccint.info,  Node: Trampolines,  Next: Library Calls,  Prev: Varargs,  Up: Target Macros

15.12 Trampolines for Nested Functions
======================================

A "trampoline" is a small piece of code that is created at run time
when the address of a nested function is taken.  It normally resides on
the stack, in the stack frame of the containing function.  These macros
tell GCC how to generate code to allocate and initialize a trampoline.

 The instructions in the trampoline must do two things: load a constant
address into the static chain register, and jump to the real address of
the nested function.  On CISC machines such as the m68k, this requires
two instructions, a move immediate and a jump.  Then the two addresses
exist in the trampoline as word-long immediate operands.  On RISC
machines, it is often necessary to load each address into a register in
two parts.  Then pieces of each address form separate immediate
operands.

 The code generated to initialize the trampoline must store the variable
parts--the static chain value and the function address--into the
immediate operands of the instructions.  On a CISC machine, this is
simply a matter of copying each address to a memory reference at the
proper offset from the start of the trampoline.  On a RISC machine, it
may be necessary to take out pieces of the address and store them
separately.

 -- Macro: TRAMPOLINE_TEMPLATE (FILE)
     A C statement to output, on the stream FILE, assembler code for a
     block of data that contains the constant parts of a trampoline.
     This code should not include a label--the label is taken care of
     automatically.

     If you do not define this macro, it means no template is needed
     for the target.  Do not define this macro on systems where the
     block move code to copy the trampoline into place would be larger
     than the code to generate it on the spot.

 -- Macro: TRAMPOLINE_SECTION
     Return the section into which the trampoline template is to be
     placed (*note Sections::).  The default value is
     `readonly_data_section'.

 -- Macro: TRAMPOLINE_SIZE
     A C expression for the size in bytes of the trampoline, as an
     integer.

 -- Macro: TRAMPOLINE_ALIGNMENT
     Alignment required for trampolines, in bits.

     If you don't define this macro, the value of `BIGGEST_ALIGNMENT'
     is used for aligning trampolines.

 -- Macro: INITIALIZE_TRAMPOLINE (ADDR, FNADDR, STATIC_CHAIN)
     A C statement to initialize the variable parts of a trampoline.
     ADDR is an RTX for the address of the trampoline; FNADDR is an RTX
     for the address of the nested function; STATIC_CHAIN is an RTX for
     the static chain value that should be passed to the function when
     it is called.

 -- Macro: TRAMPOLINE_ADJUST_ADDRESS (ADDR)
     A C statement that should perform any machine-specific adjustment
     in the address of the trampoline.  Its argument contains the
     address that was passed to `INITIALIZE_TRAMPOLINE'.  In case the
     address to be used for a function call should be different from
     the address in which the template was stored, the different
     address should be assigned to ADDR.  If this macro is not defined,
     ADDR will be used for function calls.

     If this macro is not defined, by default the trampoline is
     allocated as a stack slot.  This default is right for most
     machines.  The exceptions are machines where it is impossible to
     execute instructions in the stack area.  On such machines, you may
     have to implement a separate stack, using this macro in
     conjunction with `TARGET_ASM_FUNCTION_PROLOGUE' and
     `TARGET_ASM_FUNCTION_EPILOGUE'.

     FP points to a data structure, a `struct function', which
     describes the compilation status of the immediate containing
     function of the function which the trampoline is for.  The stack
     slot for the trampoline is in the stack frame of this containing
     function.  Other allocation strategies probably must do something
     analogous with this information.

 Implementing trampolines is difficult on many machines because they
have separate instruction and data caches.  Writing into a stack
location fails to clear the memory in the instruction cache, so when
the program jumps to that location, it executes the old contents.

 Here are two possible solutions.  One is to clear the relevant parts of
the instruction cache whenever a trampoline is set up.  The other is to
make all trampolines identical, by having them jump to a standard
subroutine.  The former technique makes trampoline execution faster; the
latter makes initialization faster.

 To clear the instruction cache when a trampoline is initialized, define
the following macro.

 -- Macro: CLEAR_INSN_CACHE (BEG, END)
     If defined, expands to a C expression clearing the _instruction
     cache_ in the specified interval.  The definition of this macro
     would typically be a series of `asm' statements.  Both BEG and END
     are both pointer expressions.

 The operating system may also require the stack to be made executable
before calling the trampoline.  To implement this requirement, define
the following macro.

 -- Macro: ENABLE_EXECUTE_STACK
     Define this macro if certain operations must be performed before
     executing code located on the stack.  The macro should expand to a
     series of C file-scope constructs (e.g. functions) and provide a
     unique entry point named `__enable_execute_stack'.  The target is
     responsible for emitting calls to the entry point in the code, for
     example from the `INITIALIZE_TRAMPOLINE' macro.

 To use a standard subroutine, define the following macro.  In addition,
you must make sure that the instructions in a trampoline fill an entire
cache line with identical instructions, or else ensure that the
beginning of the trampoline code is always aligned at the same point in
its cache line.  Look in `m68k.h' as a guide.

 -- Macro: TRANSFER_FROM_TRAMPOLINE
     Define this macro if trampolines need a special subroutine to do
     their work.  The macro should expand to a series of `asm'
     statements which will be compiled with GCC.  They go in a library
     function named `__transfer_from_trampoline'.

     If you need to avoid executing the ordinary prologue code of a
     compiled C function when you jump to the subroutine, you can do so
     by placing a special label of your own in the assembler code.  Use
     one `asm' statement to generate an assembler label, and another to
     make the label global.  Then trampolines can use that label to
     jump directly to your special assembler code.


File: gccint.info,  Node: Library Calls,  Next: Addressing Modes,  Prev: Trampolines,  Up: Target Macros

15.13 Implicit Calls to Library Routines
========================================

Here is an explanation of implicit calls to library routines.

 -- Macro: DECLARE_LIBRARY_RENAMES
     This macro, if defined, should expand to a piece of C code that
     will get expanded when compiling functions for libgcc.a.  It can
     be used to provide alternate names for GCC's internal library
     functions if there are ABI-mandated names that the compiler should
     provide.

 -- Target Hook: void TARGET_INIT_LIBFUNCS (void)
     This hook should declare additional library routines or rename
     existing ones, using the functions `set_optab_libfunc' and
     `init_one_libfunc' defined in `optabs.c'.  `init_optabs' calls
     this macro after initializing all the normal library routines.

     The default is to do nothing.  Most ports don't need to define
     this hook.

 -- Macro: FLOAT_LIB_COMPARE_RETURNS_BOOL (MODE, COMPARISON)
     This macro should return `true' if the library routine that
     implements the floating point comparison operator COMPARISON in
     mode MODE will return a boolean, and FALSE if it will return a
     tristate.

     GCC's own floating point libraries return tristates from the
     comparison operators, so the default returns false always.  Most
     ports don't need to define this macro.

 -- Macro: TARGET_LIB_INT_CMP_BIASED
     This macro should evaluate to `true' if the integer comparison
     functions (like `__cmpdi2') return 0 to indicate that the first
     operand is smaller than the second, 1 to indicate that they are
     equal, and 2 to indicate that the first operand is greater than
     the second.  If this macro evaluates to `false' the comparison
     functions return -1, 0, and 1 instead of 0, 1, and 2.  If the
     target uses the routines in `libgcc.a', you do not need to define
     this macro.

 -- Macro: US_SOFTWARE_GOFAST
     Define this macro if your system C library uses the US Software
     GOFAST library to provide floating point emulation.

     In addition to defining this macro, your architecture must set
     `TARGET_INIT_LIBFUNCS' to `gofast_maybe_init_libfuncs', or else
     call that function from its version of that hook.  It is defined
     in `config/gofast.h', which must be included by your
     architecture's `CPU.c' file.  See `sparc/sparc.c' for an example.

     If this macro is defined, the
     `TARGET_FLOAT_LIB_COMPARE_RETURNS_BOOL' target hook must return
     false for `SFmode' and `DFmode' comparisons.

 -- Macro: TARGET_EDOM
     The value of `EDOM' on the target machine, as a C integer constant
     expression.  If you don't define this macro, GCC does not attempt
     to deposit the value of `EDOM' into `errno' directly.  Look in
     `/usr/include/errno.h' to find the value of `EDOM' on your system.

     If you do not define `TARGET_EDOM', then compiled code reports
     domain errors by calling the library function and letting it
     report the error.  If mathematical functions on your system use
     `matherr' when there is an error, then you should leave
     `TARGET_EDOM' undefined so that `matherr' is used normally.

 -- Macro: GEN_ERRNO_RTX
     Define this macro as a C expression to create an rtl expression
     that refers to the global "variable" `errno'.  (On certain systems,
     `errno' may not actually be a variable.)  If you don't define this
     macro, a reasonable default is used.

 -- Macro: TARGET_C99_FUNCTIONS
     When this macro is nonzero, GCC will implicitly optimize `sin'
     calls into `sinf' and similarly for other functions defined by C99
     standard.  The default is nonzero that should be proper value for
     most modern systems, however number of existing systems lacks
     support for these functions in the runtime so they needs this
     macro to be redefined to 0.

 -- Macro: TARGET_HAS_SINCOS
     When this macro is nonzero, GCC will implicitly optimize calls to
     `sin' and `cos' with the same argument to a call to `sincos'.  The
     default is zero.  The target has to provide the following
     functions:
          void sincos(double x, double *sin, double *cos);
          void sincosf(float x, float *sin, float *cos);
          void sincosl(long double x, long double *sin, long double *cos);

 -- Macro: NEXT_OBJC_RUNTIME
     Define this macro to generate code for Objective-C message sending
     using the calling convention of the NeXT system.  This calling
     convention involves passing the object, the selector and the
     method arguments all at once to the method-lookup library function.

     The default calling convention passes just the object and the
     selector to the lookup function, which returns a pointer to the
     method.


File: gccint.info,  Node: Addressing Modes,  Next: Anchored Addresses,  Prev: Library Calls,  Up: Target Macros

15.14 Addressing Modes
======================

This is about addressing modes.

 -- Macro: HAVE_PRE_INCREMENT
 -- Macro: HAVE_PRE_DECREMENT
 -- Macro: HAVE_POST_INCREMENT
 -- Macro: HAVE_POST_DECREMENT
     A C expression that is nonzero if the machine supports
     pre-increment, pre-decrement, post-increment, or post-decrement
     addressing respectively.

 -- Macro: HAVE_PRE_MODIFY_DISP
 -- Macro: HAVE_POST_MODIFY_DISP
     A C expression that is nonzero if the machine supports pre- or
     post-address side-effect generation involving constants other than
     the size of the memory operand.

 -- Macro: HAVE_PRE_MODIFY_REG
 -- Macro: HAVE_POST_MODIFY_REG
     A C expression that is nonzero if the machine supports pre- or
     post-address side-effect generation involving a register
     displacement.

 -- Macro: CONSTANT_ADDRESS_P (X)
     A C expression that is 1 if the RTX X is a constant which is a
     valid address.  On most machines, this can be defined as
     `CONSTANT_P (X)', but a few machines are more restrictive in which
     constant addresses are supported.

 -- Macro: CONSTANT_P (X)
     `CONSTANT_P', which is defined by target-independent code, accepts
     integer-values expressions whose values are not explicitly known,
     such as `symbol_ref', `label_ref', and `high' expressions and
     `const' arithmetic expressions, in addition to `const_int' and
     `const_double' expressions.

 -- Macro: MAX_REGS_PER_ADDRESS
     A number, the maximum number of registers that can appear in a
     valid memory address.  Note that it is up to you to specify a
     value equal to the maximum number that `GO_IF_LEGITIMATE_ADDRESS'
     would ever accept.

 -- Macro: GO_IF_LEGITIMATE_ADDRESS (MODE, X, LABEL)
     A C compound statement with a conditional `goto LABEL;' executed
     if X (an RTX) is a legitimate memory address on the target machine
     for a memory operand of mode MODE.

     It usually pays to define several simpler macros to serve as
     subroutines for this one.  Otherwise it may be too complicated to
     understand.

     This macro must exist in two variants: a strict variant and a
     non-strict one.  The strict variant is used in the reload pass.  It
     must be defined so that any pseudo-register that has not been
     allocated a hard register is considered a memory reference.  In
     contexts where some kind of register is required, a pseudo-register
     with no hard register must be rejected.

     The non-strict variant is used in other passes.  It must be
     defined to accept all pseudo-registers in every context where some
     kind of register is required.

     Compiler source files that want to use the strict variant of this
     macro define the macro `REG_OK_STRICT'.  You should use an `#ifdef
     REG_OK_STRICT' conditional to define the strict variant in that
     case and the non-strict variant otherwise.

     Subroutines to check for acceptable registers for various purposes
     (one for base registers, one for index registers, and so on) are
     typically among the subroutines used to define
     `GO_IF_LEGITIMATE_ADDRESS'.  Then only these subroutine macros
     need have two variants; the higher levels of macros may be the
     same whether strict or not.

     Normally, constant addresses which are the sum of a `symbol_ref'
     and an integer are stored inside a `const' RTX to mark them as
     constant.  Therefore, there is no need to recognize such sums
     specifically as legitimate addresses.  Normally you would simply
     recognize any `const' as legitimate.

     Usually `PRINT_OPERAND_ADDRESS' is not prepared to handle constant
     sums that are not marked with  `const'.  It assumes that a naked
     `plus' indicates indexing.  If so, then you _must_ reject such
     naked constant sums as illegitimate addresses, so that none of
     them will be given to `PRINT_OPERAND_ADDRESS'.

     On some machines, whether a symbolic address is legitimate depends
     on the section that the address refers to.  On these machines,
     define the target hook `TARGET_ENCODE_SECTION_INFO' to store the
     information into the `symbol_ref', and then check for it here.
     When you see a `const', you will have to look inside it to find the
     `symbol_ref' in order to determine the section.  *Note Assembler
     Format::.

 -- Macro: FIND_BASE_TERM (X)
     A C expression to determine the base term of address X.  This
     macro is used in only one place: `find_base_term' in alias.c.

     It is always safe for this macro to not be defined.  It exists so
     that alias analysis can understand machine-dependent addresses.

     The typical use of this macro is to handle addresses containing a
     label_ref or symbol_ref within an UNSPEC.

 -- Macro: LEGITIMIZE_ADDRESS (X, OLDX, MODE, WIN)
     A C compound statement that attempts to replace X with a valid
     memory address for an operand of mode MODE.  WIN will be a C
     statement label elsewhere in the code; the macro definition may use

          GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN);

     to avoid further processing if the address has become legitimate.

     X will always be the result of a call to `break_out_memory_refs',
     and OLDX will be the operand that was given to that function to
     produce X.

     The code generated by this macro should not alter the substructure
     of X.  If it transforms X into a more legitimate form, it sho