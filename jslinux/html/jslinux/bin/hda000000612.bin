able value for
each pattern individually.  The VARIABLE-ASSIGNMENT can be any valid
form of assignment.  Any command-line variable setting will take
precedence, unless `override' is specified.

   For example:

     %.o : CFLAGS = -O

will assign `CFLAGS' the value of `-O' for all targets matching the
pattern `%.o'.


File: make.info,  Node: Conditionals,  Next: Functions,  Prev: Using Variables,  Up: Top

7 Conditional Parts of Makefiles
********************************

A "conditional" causes part of a makefile to be obeyed or ignored
depending on the values of variables.  Conditionals can compare the
value of one variable to another, or the value of a variable to a
constant string.  Conditionals control what `make' actually "sees" in
the makefile, so they _cannot_ be used to control shell commands at the
time of execution.

* Menu:

* Conditional Example::         Example of a conditional
* Conditional Syntax::          The syntax of conditionals.
* Testing Flags::               Conditionals that test flags.


File: make.info,  Node: Conditional Example,  Next: Conditional Syntax,  Prev: Conditionals,  Up: Conditionals

7.1 Example of a Conditional
============================

The following example of a conditional tells `make' to use one set of
libraries if the `CC' variable is `gcc', and a different set of
libraries otherwise.  It works by controlling which of two command
lines will be used as the command for a rule.  The result is that
`CC=gcc' as an argument to `make' changes not only which compiler is
used but also which libraries are linked.

     libs_for_gcc = -lgnu
     normal_libs =

     foo: $(objects)
     ifeq ($(CC),gcc)
             $(CC) -o foo $(objects) $(libs_for_gcc)
     else
             $(CC) -o foo $(objects) $(normal_libs)
     endif

   This conditional uses three directives: one `ifeq', one `else' and
one `endif'.

   The `ifeq' directive begins the conditional, and specifies the
condition.  It contains two arguments, separated by a comma and
surrounded by parentheses.  Variable substitution is performed on both
arguments and then they are compared.  The lines of the makefile
following the `ifeq' are obeyed if the two arguments match; otherwise
they are ignored.

   The `else' directive causes the following lines to be obeyed if the
previous conditional failed.  In the example above, this means that the
second alternative linking command is used whenever the first
alternative is not used.  It is optional to have an `else' in a
conditional.

   The `endif' directive ends the conditional.  Every conditional must
end with an `endif'.  Unconditional makefile text follows.

   As this example illustrates, conditionals work at the textual level:
the lines of the conditional are treated as part of the makefile, or
ignored, according to the condition.  This is why the larger syntactic
units of the makefile, such as rules, may cross the beginning or the
end of the conditional.

   When the variable `CC' has the value `gcc', the above example has
this effect:

     foo: $(objects)
             $(CC) -o foo $(objects) $(libs_for_gcc)

When the variable `CC' has any other value, the effect is this:

     foo: $(objects)
             $(CC) -o foo $(objects) $(normal_libs)

   Equivalent results can be obtained in another way by
conditionalizing a variable assignment and then using the variable
unconditionally:

     libs_for_gcc = -lgnu
     normal_libs =

     ifeq ($(CC),gcc)
       libs=$(libs_for_gcc)
     else
       libs=$(normal_libs)
     endif

     foo: $(objects)
             $(CC) -o foo $(objects) $(libs)


File: make.info,  Node: Conditional Syntax,  Next: Testing Flags,  Prev: Conditional Example,  Up: Conditionals

7.2 Syntax of Conditionals
==========================

The syntax of a simple conditional with no `else' is as follows:

     CONDITIONAL-DIRECTIVE
     TEXT-IF-TRUE
     endif

The TEXT-IF-TRUE may be any lines of text, to be considered as part of
the makefile if the condition is true.  If the condition is false, no
text is used instead.

   The syntax of a complex conditional is as follows:

     CONDITIONAL-DIRECTIVE
     TEXT-IF-TRUE
     else
     TEXT-IF-FALSE
     endif

   or:

     CONDITIONAL-DIRECTIVE
     TEXT-IF-ONE-IS-TRUE
     else CONDITIONAL-DIRECTIVE
     TEXT-IF-TRUE
     else
     TEXT-IF-FALSE
     endif

There can be as many "`else' CONDITIONAL-DIRECTIVE" clauses as
necessary.  Once a given condition is true, TEXT-IF-TRUE is used and no
other clause is used; if no condition is true then TEXT-IF-FALSE is
used.  The TEXT-IF-TRUE and TEXT-IF-FALSE can be any number of lines of
text.

   The syntax of the CONDITIONAL-DIRECTIVE is the same whether the
conditional is simple or complex; after an `else' or not.  There are
four different directives that test different conditions.  Here is a
table of them:

`ifeq (ARG1, ARG2)'
`ifeq 'ARG1' 'ARG2''
`ifeq "ARG1" "ARG2"'
`ifeq "ARG1" 'ARG2''
`ifeq 'ARG1' "ARG2"'
     Expand all variable references in ARG1 and ARG2 and compare them.
     If they are identical, the TEXT-IF-TRUE is effective; otherwise,
     the TEXT-IF-FALSE, if any, is effective.

     Often you want to test if a variable has a non-empty value.  When
     the value results from complex expansions of variables and
     functions, expansions you would consider empty may actually
     contain whitespace characters and thus are not seen as empty.
     However, you can use the `strip' function (*note Text Functions::)
     to avoid interpreting whitespace as a non-empty value.  For
     example:

          ifeq ($(strip $(foo)),)
          TEXT-IF-EMPTY
          endif

     will evaluate TEXT-IF-EMPTY even if the expansion of `$(foo)'
     contains whitespace characters.

`ifneq (ARG1, ARG2)'
`ifneq 'ARG1' 'ARG2''
`ifneq "ARG1" "ARG2"'
`ifneq "ARG1" 'ARG2''
`ifneq 'ARG1' "ARG2"'
     Expand all variable references in ARG1 and ARG2 and compare them.
     If they are different, the TEXT-IF-TRUE is effective; otherwise,
     the TEXT-IF-FALSE, if any, is effective.

`ifdef VARIABLE-NAME'
     The `ifdef' form takes the _name_ of a variable as its argument,
     not a reference to a variable.  The value of that variable has a
     non-empty value, the TEXT-IF-TRUE is effective; otherwise, the
     TEXT-IF-FALSE, if any, is effective.  Variables that have never
     been defined have an empty value.  The text VARIABLE-NAME is
     expanded, so it could be a variable or function that expands to
     the name of a variable.  For example:

          bar = true
          foo = bar
          ifdef $(foo)
          frobozz = yes
          endif

     The variable reference `$(foo)' is expanded, yielding `bar', which
     is considered to be the name of a variable.  The variable `bar' is
     not expanded, but its value is examined to determine if it is
     non-empty.

     Note that `ifdef' only tests whether a variable has a value.  It
     does not expand the variable to see if that value is nonempty.
     Consequently, tests using `ifdef' return true for all definitions
     except those like `foo ='.  To test for an empty value, use
     `ifeq ($(foo),)'.  For example,

          bar =
          foo = $(bar)
          ifdef foo
          frobozz = yes
          else
          frobozz = no
          endif

     sets `frobozz' to `yes', while:

          foo =
          ifdef foo
          frobozz = yes
          else
          frobozz = no
          endif

     sets `frobozz' to `no'.

`ifndef VARIABLE-NAME'
     If the variable VARIABLE-NAME has an empty value, the TEXT-IF-TRUE
     is effective; otherwise, the TEXT-IF-FALSE, if any, is effective.
     The rules for expansion and testing of VARIABLE-NAME are identical
     to the `ifdef' directive.

   Extra spaces are allowed and ignored at the beginning of the
conditional directive line, but a tab is not allowed.  (If the line
begins with a tab, it will be considered a command for a rule.)  Aside
from this, extra spaces or tabs may be inserted with no effect anywhere
except within the directive name or within an argument.  A comment
starting with `#' may appear at the end of the line.

   The other two directives that play a part in a conditional are `else'
and `endif'.  Each of these directives is written as one word, with no
arguments.  Extra spaces are allowed and ignored at the beginning of the
line, and spaces or tabs at the end.  A comment starting with `#' may
appear at the end of the line.

   Conditionals affect which lines of the makefile `make' uses.  If the
condition is true, `make' reads the lines of the TEXT-IF-TRUE as part
of the makefile; if the condition is false, `make' ignores those lines
completely.  It follows that syntactic units of the makefile, such as
rules, may safely be split across the beginning or the end of the
conditional.

   `make' evaluates conditionals when it reads a makefile.
Consequently, you cannot use automatic variables in the tests of
conditionals because they are not defined until commands are run (*note
Automatic Variables::).

   To prevent intolerable confusion, it is not permitted to start a
conditional in one makefile and end it in another.  However, you may
write an `include' directive within a conditional, provided you do not
attempt to terminate the conditional inside the included file.


File: make.info,  Node: Testing Flags,  Prev: Conditional Syntax,  Up: Conditionals

7.3 Conditionals that Test Flags
================================

You can write a conditional that tests `make' command flags such as
`-t' by using the variable `MAKEFLAGS' together with the `findstring'
function (*note Functions for String Substitution and Analysis: Text
Functions.).  This is useful when `touch' is not enough to make a file
appear up to date.

   The `findstring' function determines whether one string appears as a
substring of another.  If you want to test for the `-t' flag, use `t'
as the first string and the value of `MAKEFLAGS' as the other.

   For example, here is how to arrange to use `ranlib -t' to finish
marking an archive file up to date:

     archive.a: ...
     ifneq (,$(findstring t,$(MAKEFLAGS)))
             +touch archive.a
             +ranlib -t archive.a
     else
             ranlib archive.a
     endif

The `+' prefix marks those command lines as "recursive" so that they
will be executed despite use of the `-t' flag.  *Note Recursive Use of
`make': Recursion.


File: make.info,  Node: Functions,  Next: Running,  Prev: Conditionals,  Up: Top

8 Functions for Transforming Text
*********************************

"Functions" allow you to do text processing in the makefile to compute
the files to operate on or the commands to use.  You use a function in a
"function call", where you give the name of the function and some text
(the "arguments") for the function to operate on.  The result of the
function's processing is substituted into the makefile at the point of
the call, just as a variable might be substituted.

* Menu:

* Syntax of Functions::         How to write a function call.
* Text Functions::              General-purpose text manipulation functions.
* File Name Functions::         Functions for manipulating file names.
* Conditional Functions::       Functions that implement conditions.
* Foreach Function::            Repeat some text with controlled variation.
* Call Function::               Expand a user-defined function.
* Value Function::              Return the un-expanded value of a variable.
* Eval Function::               Evaluate the arguments as makefile syntax.
* Origin Function::             Find where a variable got its value.
* Flavor Function::             Find out the flavor of a variable.
* Shell Function::              Substitute the output of a shell command.
* Make Control Functions::      Functions that control how make runs.


File: make.info,  Node: Syntax of Functions,  Next: Text Functions,  Prev: Functions,  Up: Functions

8.1 Function Call Syntax
========================

A function call resembles a variable reference.  It looks like this:

     $(FUNCTION ARGUMENTS)

or like this:

     ${FUNCTION ARGUMENTS}

   Here FUNCTION is a function name; one of a short list of names that
are part of `make'.  You can also essentially create your own functions
by using the `call' builtin function.

   The ARGUMENTS are the arguments of the function.  They are separated
from the function name by one or more spaces or tabs, and if there is
more than one argument, then they are separated by commas.  Such
whitespace and commas are not part of an argument's value.  The
delimiters which you use to surround the function call, whether
parentheses or braces, can appear in an argument only in matching pairs;
the other kind of delimiters may appear singly.  If the arguments
themselves contain other function calls or variable references, it is
wisest to use the same kind of delimiters for all the references; write
`$(subst a,b,$(x))', not `$(subst a,b,${x})'.  This is because it is
clearer, and because only one type of delimiter is matched to find the
end of the reference.

   The text written for each argument is processed by substitution of
variables and function calls to produce the argument value, which is
the text on which the function acts.  The substitution is done in the
order in which the arguments appear.

   Commas and unmatched parentheses or braces cannot appear in the text
of an argument as written; leading spaces cannot appear in the text of
the first argument as written.  These characters can be put into the
argument value by variable substitution.  First define variables
`comma' and `space' whose values are isolated comma and space
characters, then substitute these variables where such characters are
wanted, like this:

     comma:= ,
     empty:=
     space:= $(empty) $(empty)
     foo:= a b c
     bar:= $(subst $(space),$(comma),$(foo))
     # bar is now `a,b,c'.

Here the `subst' function replaces each space with a comma, through the
value of `foo', and substitutes the result.


File: make.info,  Node: Text Functions,  Next: File Name Functions,  Prev: Syntax of Functions,  Up: Functions

8.2 Functions for String Substitution and Analysis
==================================================

Here are some functions that operate on strings:

`$(subst FROM,TO,TEXT)'
     Performs a textual replacement on the text TEXT: each occurrence
     of FROM is replaced by TO.  The result is substituted for the
     function call.  For example,

          $(subst ee,EE,feet on the street)

     substitutes the string `fEEt on the strEEt'.

`$(patsubst PATTERN,REPLACEMENT,TEXT)'
     Finds whitespace-separated words in TEXT that match PATTERN and
     replaces them with REPLACEMENT.  Here PATTERN may contain a `%'
     which acts as a wildcard, matching any number of any characters
     within a word.  If REPLACEMENT also contains a `%', the `%' is
     replaced by the text that matched the `%' in PATTERN.  Only the
     first `%' in the PATTERN and REPLACEMENT is treated this way; any
     subsequent `%' is unchanged.

     `%' characters in `patsubst' function invocations can be quoted
     with preceding backslashes (`\').  Backslashes that would
     otherwise quote `%' characters can be quoted with more backslashes.
     Backslashes that quote `%' characters or other backslashes are
     removed from the pattern before it is compared file names or has a
     stem substituted into it.  Backslashes that are not in danger of
     quoting `%' characters go unmolested.  For example, the pattern
     `the\%weird\\%pattern\\' has `the%weird\' preceding the operative
     `%' character, and `pattern\\' following it.  The final two
     backslashes are left alone because they cannot affect any `%'
     character.

     Whitespace between words is folded into single space characters;
     leading and trailing whitespace is discarded.

     For example,

          $(patsubst %.c,%.o,x.c.c bar.c)

     produces the value `x.c.o bar.o'.

     Substitution references (*note Substitution References:
     Substitution Refs.) are a simpler way to get the effect of the
     `patsubst' function:

          $(VAR:PATTERN=REPLACEMENT)

     is equivalent to

          $(patsubst PATTERN,REPLACEMENT,$(VAR))

     The second shorthand simplifies one of the most common uses of
     `patsubst': replacing the suffix at the end of file names.

          $(VAR:SUFFIX=REPLACEMENT)

     is equivalent to

          $(patsubst %SUFFIX,%REPLACEMENT,$(VAR))

     For example, you might have a list of object files:

          objects = foo.o bar.o baz.o

     To get the list of corresponding source files, you could simply
     write:

          $(objects:.o=.c)

     instead of using the general form:

          $(patsubst %.o,%.c,$(objects))

`$(strip STRING)'
     Removes leading and trailing whitespace from STRING and replaces
     each internal sequence of one or more whitespace characters with a
     single space.  Thus, `$(strip a b  c )' results in `a b c'.

     The function `strip' can be very useful when used in conjunction
     with conditionals.  When comparing something with the empty string
     `' using `ifeq' or `ifneq', you usually want a string of just
     whitespace to match the empty string (*note Conditionals::).

     Thus, the following may fail to have the desired results:

          .PHONY: all
          ifneq   "$(needs_made)" ""
          all: $(needs_made)
          else
          all:;@echo 'Nothing to make!'
          endif

     Replacing the variable reference `$(needs_made)' with the function
     call `$(strip $(needs_made))' in the `ifneq' directive would make
     it more robust.

`$(findstring FIND,IN)'
     Searches IN for an occurrence of FIND.  If it occurs, the value is
     FIND; otherwise, the value is empty.  You can use this function in
     a conditional to test for the presence of a specific substring in
     a given string.  Thus, the two examples,

          $(findstring a,a b c)
          $(findstring a,b c)

     produce the values `a' and `' (the empty string), respectively.
     *Note Testing Flags::, for a practical application of `findstring'.

`$(filter PATTERN...,TEXT)'
     Returns all whitespace-separated words in TEXT that _do_ match any
     of the PATTERN words, removing any words that _do not_ match.  The
     patterns are written using `%', just like the patterns used in the
     `patsubst' function above.

     The `filter' function can be used to separate out different types
     of strings (such as file names) in a variable.  For example:

          sources := foo.c bar.c baz.s ugh.h
          foo: $(sources)
                  cc $(filter %.c %.s,$(sources)) -o foo

     says that `foo' depends of `foo.c', `bar.c', `baz.s' and `ugh.h'
     but only `foo.c', `bar.c' and `baz.s' should be specified in the
     command to the compiler.

`$(filter-out PATTERN...,TEXT)'
     Returns all whitespace-separated words in TEXT that _do not_ match
     any of the PATTERN words, removing the words that _do_ match one
     or more.  This is the exact opposite of the `filter' function.

     For example, given:

          objects=main1.o foo.o main2.o bar.o
          mains=main1.o main2.o

     the following generates a list which contains all the object files
     not in `mains':

          $(filter-out $(mains),$(objects))

`$(sort LIST)'
     Sorts the words of LIST in lexical order, removing duplicate
     words.  The output is a list of words separated by single spaces.
     Thus,

          $(sort foo bar lose)

     returns the value `bar foo lose'.

     Incidentally, since `sort' removes duplicate words, you can use it
     for this purpose even if you don't care about the sort order.

`$(word N,TEXT)'
     Returns the Nth word of TEXT.  The legitimate values of N start
     from 1.  If N is bigger than the number of words in TEXT, the
     value is empty.  For example,

          $(word 2, foo bar baz)

     returns `bar'.

`$(wordlist S,E,TEXT)'
     Returns the list of words in TEXT starting with word S and ending
     with word E (inclusive).  The legitimate values of S start from 1;
     E may start from 0.  If S is bigger than the number of words in
     TEXT, the value is empty.  If E is bigger than the number of words
     in TEXT, words up to the end of TEXT are returned.  If S is
     greater than E, nothing is returned.  For example,

          $(wordlist 2, 3, foo bar baz)

     returns `bar baz'.

`$(words TEXT)'
     Returns the number of words in TEXT.  Thus, the last word of TEXT
     is `$(word $(words TEXT),TEXT)'.

`$(firstword NAMES...)'
     The argument NAMES is regarded as a series of names, separated by
     whitespace.  The value is the first name in the series.  The rest
     of the names are ignored.

     For example,

          $(firstword foo bar)

     produces the result `foo'.  Although `$(firstword TEXT)' is the
     same as `$(word 1,TEXT)', the `firstword' function is retained for
     its simplicity.

`$(lastword NAMES...)'
     The argument NAMES is regarded as a series of names, separated by
     whitespace.  The value is the last name in the series.

     For example,

          $(lastword foo bar)

     produces the result `bar'.  Although `$(lastword TEXT)' is the
     same as `$(word $(words TEXT),TEXT)', the `lastword' function was
     added for its simplicity and better performance.

   Here is a realistic example of the use of `subst' and `patsubst'.
Suppose that a makefile uses the `VPATH' variable to specify a list of
directories that `make' should search for prerequisite files (*note
`VPATH' Search Path for All Prerequisites: General Search.).  This
example shows how to tell the C compiler to search for header files in
the same list of directories.

   The value of `VPATH' is a list of directories separated by colons,
such as `src:../headers'.  First, the `subst' function is used to
change the colons to spaces:

     $(subst :, ,$(VPATH))

This produces `src ../headers'.  Then `patsubst' is used to turn each
directory name into a `-I' flag.  These can be added to the value of
the variable `CFLAGS', which is passed automatically to the C compiler,
like this:

     override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))

The effect is to append the text `-Isrc -I../headers' to the previously
given value of `CFLAGS'.  The `override' directive is used so that the
new value is assigned even if the previous value of `CFLAGS' was
specified with a command argument (*note The `override' Directive:
Override Directive.).


File: make.info,  Node: File Name Functions,  Next: Conditional Functions,  Prev: Text Functions,  Up: Functions

8.3 Functions for File Names
============================

Several of the built-in expansion functions relate specifically to
taking apart file names or lists of file names.

   Each of the following functions performs a specific transformation
on a file name.  The argument of the function is regarded as a series
of file names, separated by whitespace.  (Leading and trailing
whitespace is ignored.)  Each file name in the series is transformed in
the same way and the results are concatenated with single spaces
between them.

`$(dir NAMES...)'
     Extracts the directory-part of each file name in NAMES.  The
     directory-part of the file name is everything up through (and
     including) the last slash in it.  If the file name contains no
     slash, the directory part is the string `./'.  For example,

          $(dir src/foo.c hacks)

     produces the result `src/ ./'.

`$(notdir NAMES...)'
     Extracts all but the directory-part of each file name in NAMES.
     If the file name contains no slash, it is left unchanged.
     Otherwise, everything through the last slash is removed from it.

     A file name that ends with a slash becomes an empty string.  This
     is unfortunate, because it means that the result does not always
     have the same number of whitespace-separated file names as the
     argument had; but we do not see any other valid alternative.

     For example,

          $(notdir src/foo.c hacks)

     produces the result `foo.c hacks'.

`$(suffix NAMES...)'
     Extracts the suffix of each file name in NAMES.  If the file name
     contains a period, the suffix is everything starting with the last
     period.  Otherwise, the suffix is the empty string.  This
     frequently means that the result will be empty when NAMES is not,
     and if NAMES contains multiple file names, the result may contain
     fewer file names.

     For example,

          $(suffix src/foo.c src-1.0/bar.c hacks)

     produces the result `.c .c'.

`$(basename NAMES...)'
     Extracts all but the suffix of each file name in NAMES.  If the
     file name contains a period, the basename is everything starting
     up to (and not including) the last period.  Periods in the
     directory part are ignored.  If there is no period, the basename
     is the entire file name.  For example,

          $(basename src/foo.c src-1.0/bar hacks)

     produces the result `src/foo src-1.0/bar hacks'.

`$(addsuffix SUFFIX,NAMES...)'
     The argument NAMES is regarded as a series of names, separated by
     whitespace; SUFFIX is used as a unit.  The value of SUFFIX is
     appended to the end of each individual name and the resulting
     larger names are concatenated with single spaces between them.
     For example,

          $(addsuffix .c,foo bar)

     produces the result `foo.c bar.c'.

`$(addprefix PREFIX,NAMES...)'
     The argument NAMES is regarded as a series of names, separated by
     whitespace; PREFIX is used as a unit.  The value of PREFIX is
     prepended to the front of each individual name and the resulting
     larger names are concatenated with single spaces between them.
     For example,

          $(addprefix src/,foo bar)

     produces the result `src/foo src/bar'.

`$(join LIST1,LIST2)'
     Concatenates the two arguments word by word: the two first words
     (one from each argument) concatenated form the first word of the
     result, the two second words form the second word of the result,
     and so on.  So the Nth word of the result comes from the Nth word
     of each argument.  If one argument has more words that the other,
     the extra words are copied unchanged into the result.

     For example, `$(join a b,.c .o)' produces `a.c b.o'.

     Whitespace between the words in the lists is not preserved; it is
     replaced with a single space.

     This function can merge the results of the `dir' and `notdir'
     functions, to produce the original list of files which was given
     to those two functions.

`$(wildcard PATTERN)'
     The argument PATTERN is a file name pattern, typically containing
     wildcard characters (as in shell file name patterns).  The result
     of `wildcard' is a space-separated list of the names of existing
     files that match the pattern.  *Note Using Wildcard Characters in
     File Names: Wildcards.

`$(realpath NAMES...)'
     For each file name in NAMES return the canonical absolute name.  A
     canonical name does not contain any `.' or `..' components, nor
     any repeated path separators (`/') or symlinks.  In case of a
     failure the empty string is returned.  Consult the `realpath(3)'
     documentation for a list of possible failure causes.

`$(abspath NAMES...)'
     For each file name in NAMES return an absolute name that does not
     contain any `.' or `..' components, nor any repeated path
     separators (`/').  Note that, in contrast to `realpath' function,
     `abspath' does not resolve symlinks and does not require the file
     names to refer to an existing file or directory.  Use the
     `wildcard' function to test for existence.


File: make.info,  Node: Conditional Functions,  Next: Foreach Function,  Prev: File Name Functions,  Up: Functions

8.4 Functions for Conditionals
==============================

There are three functions that provide conditional expansion.  A key
aspect of these functions is that not all of the arguments are expanded
initially.  Only those arguments which need to be expanded, will be
expanded.

`$(if CONDITION,THEN-PART[,ELSE-PART])'
     The `if' function provides support for conditional expansion in a
     functional context (as opposed to the GNU `make' makefile
     conditionals such as `ifeq' (*note Syntax of Conditionals:
     Conditional Syntax.).

     The first argument, CONDITION, first has all preceding and
     trailing whitespace stripped, then is expanded.  If it expands to
     any non-empty string, then the condition is considered to be true.
     If it expands to an empty string, the condition is considered to
     be false.

     If the condition is true then the second argument, THEN-PART, is
     evaluated and this is used as the result of the evaluation of the
     entire `if' function.

     If the condition is false then the third argument, ELSE-PART, is
     evaluated and this is the result of the `if' function.  If there is
     no third argument, the `if' function evaluates to nothing (the
     empty string).

     Note that only one of the THEN-PART or the ELSE-PART will be
     evaluated, never both.  Thus, either can contain side-effects
     (such as `shell' function calls, etc.)

`$(or CONDITION1[,CONDITION2[,CONDITION3...]])'
     The `or' function provides a "short-circuiting" OR operation.
     Each argument is expanded, in order.  If an argument expands to a
     non-empty string the processing stops and the result of the
     expansion is that string.  If, after all arguments are expanded,
     all of them are false (empty), then the result of the expansion is
     the empty string.

`$(and CONDITION1[,CONDITION2[,CONDITION3...]])'
     The `and' function provides a "short-circuiting" AND operation.
     Each argument is expanded, in order.  If an argument expands to an
     empty string the processing stops and the result of the expansion
     is the empty string.  If all arguments expand to a non-empty
     string then the result of the expansion is the expansion of the
     last argument.



File: make.info,  Node: Foreach Function,  Next: Call Function,  Prev: Conditional Functions,  Up: Functions

8.5 The `foreach' Function
==========================

The `foreach' function is very different from other functions.  It
causes one piece of text to be used repeatedly, each time with a
different substitution performed on it.  It resembles the `for' command
in the shell `sh' and the `foreach' command in the C-shell `csh'.

   The syntax of the `foreach' function is:

     $(foreach VAR,LIST,TEXT)

The first two arguments, VAR and LIST, are expanded before anything
else is done; note that the last argument, TEXT, is *not* expanded at
the same time.  Then for each word of the expanded value of LIST, the
variable named by the expanded value of VAR is set to that word, and
TEXT is expanded.  Presumably TEXT contains references to that
variable, so its expansion will be different each time.

   The result is that TEXT is expanded as many times as there are
whitespace-separated words in LIST.  The multiple expansions of TEXT
are concatenated, with spaces between them, to make the result of
`foreach'.

   This simple example sets the variable `files' to the list of all
files in the directories in the list `dirs':

     dirs := a b c d
     files := $(foreach dir,$(dirs),$(wildcard $(dir)/*))

   Here TEXT is `$(wildcard $(dir)/*)'.  The first repetition finds the
value `a' for `dir', so it produces the same result as `$(wildcard
a/*)'; the second repetition produces the result of `$(wildcard b/*)';
and the third, that of `$(wildcard c/*)'.

   This example has the same result (except for setting `dirs') as the
following example:

     files := $(wildcard a/* b/* c/* d/*)

   When TEXT is complicated, you can improve readability by giving it a
name, with an additional variable:

     find_files = $(wildcard $(dir)/*)
     dirs := a b c d
     files := $(foreach dir,$(dirs),$(find_files))

Here we use the variable `find_files' this way.  We use plain `=' to
define a recursively-expanding variable, so that its value contains an
actual function call to be reexpanded under the control of `foreach'; a
simply-expanded variable would not do, since `wildcard' would be called
only once at the time of defining `find_files'.

   The `foreach' function has no permanent effect on the variable VAR;
its value and flavor after the `foreach' function call are the same as
they were beforehand.  The other values which are taken from LIST are
in effect only temporarily, during the execution of `foreach'.  The
variable VAR is a simply-expanded variable during the execution of
`foreach'.  If VAR was undefined before the `foreach' function call, it
is undefined after the call.  *Note The Two Flavors of Variables:
Flavors.

   You must take care when using complex variable expressions that
result in variable names because many strange things are valid variable
names, but are probably not what you intended.  For example,

     files := $(foreach Esta escrito en espanol!,b c ch,$(find_files))

might be useful if the value of `find_files' references the variable
whose name is `Esta escrito en espanol!' (es un nombre bastante largo,
no?), but it is more likely to be a mistake.


File: make.info,  Node: Call Function,  Next: Value Function,  Prev: Foreach Function,  Up: Functions

8.6 The `call' Function
=======================

The `call' function is unique in that it can be used to create new
parameterized functions.  You can write a complex expression as the
value of a variable, then use `call' to expand it with different values.

   The syntax of the `call' function is:

     $(call VARIABLE,PARAM,PARAM,...)

   When `make' expands this function, it assigns each PARAM to
temporary variables `$(1)', `$(2)', etc.  The variable `$(0)' will
contain VARIABLE.  There is no maximum number of parameter arguments.
There is no minimum, either, but it doesn't make sense to use `call'
with no parameters.

   Then VARIABLE is expanded as a `make' variable in the context of
these temporary assignments.  Thus, any reference to `$(1)' in the
value of VARIABLE will resolve to the first PARAM in the invocation of
`call'.

   Note that VARIABLE is the _name_ of a variable, not a _reference_ to
that variable.  Therefore you would not normally use a `$' or
parentheses when writing it.  (You can, however, use a variable
reference in the name if you want the name not to be a constant.)

   If VARIABLE is the name of a builtin function, the builtin function
is always invoked (even if a `make' variable by that name also exists).

   The `call' function expands the PARAM arguments before assigning
them to temporary variables.  This means that VARIABLE values
containing references to builtin functions that have special expansion
rules, like `foreach' or `if', may not work as you expect.

   Some examples may make this clearer.

   This macro simply reverses its arguments:

     reverse = $(2) $(1)

     foo = $(call reverse,a,b)

Here FOO will contain `b a'.

   This one is slightly more interesting: it defines a macro to search
for the first instance of a program in `PATH':

     pathsearch = $(firstword $(wildcard $(addsuffix /$(1),$(subst :, ,$(PATH)))))

     LS := $(call pathsearch,ls)

Now the variable LS contains `/bin/ls' or similar.

   The `call' function can be nested.  Each recursive invocation gets
its own local values for `$(1)', etc. that mask the values of
higher-level `call'.  For example, here is an implementation of a "map"
function:

     map = $(foreach a,$(2),$(call $(1),$(a)))

   Now you can MAP a function that normally takes only one argument,
such as `origin', to multiple values in one step:

     o = $(call map,origin,o map MAKE)

   and end up with O containing something like `file file default'.

   A final caution: be careful when adding whitespace to the arguments
to `call'.  As with other functions, any whitespace contained in the
second and subsequent arguments is kept; this can cause strange
effects.  It's generally safest to remove all extraneous whitespace when
providing parameters to `call'.


File: make.info,  Node: Value Function,  Next: Eval Function,  Prev: Call Function,  Up: Functions

8.7 The `value' Function
========================

The `value' function provides a way for you to use the value of a
variable _without_ having it expanded.  Please note that this does not
undo expansions which have already occurred; for example if you create
a simply expanded variable its value is expanded during the definition;
in that case the `value' function will return the same result as using
the variable directly.

   The syntax of the `value' function is:

     $(value VARIABLE)

   Note that VARIABLE is the _name_ of a variable; not a _reference_ to
that variable.  Therefore you would not normally use a `$' or
parentheses when writing it.  (You can, however, use a variable
reference in the name if you want the name not to be a constant.)

   The result of this function is a string containing the value of
VARIABLE, without any expansion occurring.  For example, in this
makefile:

     FOO = $PATH

     all:
             @echo $(FOO)
             @echo $(value FOO)

The first output line would be `ATH', since the "$P" would be expanded
as a `make' variable, while the second output line would be the current
value of your `$PATH' environment variable, since the `value' function
avoided the expansion.

   The `value' function is most often used in conjunction with the
`eval' function (*note Eval Function::).


File: make.info,  Node: Eval Function,  Next: Origin Function,  Prev: Value Function,  Up: Functions

8.8 The `eval' Function
=======================

The `eval' function is very special: it allows you to define new
makefile constructs that are not constant; which are the result of
evaluating other variables and functions.  The argument to the `eval'
function is expanded, then the results of that expansion are parsed as
makefile syntax.  The expanded results can define new `make' variables,
targets, implicit or explicit rules, etc.

   The result of the `eval' function is always the empty string; thus,
it can be placed virtually anywhere in a makefile without causing
syntax errors.

   It's important to realize that the `eval' argument is expanded
_twice_; first by the `eval' function, then the results of that
expansion are expanded again when they are parsed as makefile syntax.
This means you may need to provide extra levels of escaping for "$"
characters when using `eval'.  The `value' function (*note Value
Function::) can sometimes be useful in these situations, to circumvent
unwanted expansions.

   Here is an example of how `eval' can be used; this example combines
a number of concepts and other functions.  Although it might seem
overly complex to use `eval' in this example, rather than just writing
out the rules, consider two things: first, the template definition (in
`PROGRAM_template') could need to be much more complex than it is here;
and second, you might put the complex, "generic" part of this example
into another makefile, then include it in all the individual makefiles.
Now your individual makefiles are quite straightforward.

     PROGRAMS    = server client

     server_OBJS = server.o server_priv.o server_access.o
     server_LIBS = priv protocol

     client_OBJS = client.o client_api.o client_mem.o
     client_LIBS = protocol

     # Everything after this is generic

     .PHONY: all
     all: $(PROGRAMS)

     define PROGRAM_template
      $(1): $$($(1)_OBJS) $$($(1)_LIBS:%=-l%)
      ALL_OBJS   += $$($(1)_OBJS)
     endef

     $(foreach prog,$(PROGRAMS),$(eval $(call PROGRAM_template,$(prog))))

     $(PROGRAMS):
             $(LINK.o) $^ $(LDLIBS) -o $@

     clean:
             rm -f $(ALL_OBJS) $(PROGRAMS)


File: make.info,  Node: Origin Function,  Next: Flavor Function,  Prev: Eval Function,  Up: Functions

8.9 The `origin' Function
=========================

The `origin' function is unlike most other functions in that it does
not operate on the values of variables; it tells you something _about_
a variable.  Specifically, it tells you where it came from.

   The syntax of the `origin' function is:

     $(origin VARIABLE)

   Note that VARIABLE is the _name_ of a variable to inquire about; not
a _reference_ to that variable.  Therefore you would not normally use a
`$' or parentheses when writing it.  (You can, however, use a variable
reference in the name if you want the name not to be a constant.)

   The result of this function is a string telling you how the variable
VARIABLE was defined:

`undefined'
     if VARIABLE was never defined.

`default'
     if VARIABLE has a default definition, as is usual with `CC' and so
     on.  *Note Variables Used by Implicit Rules: Implicit Variables.
     Note that if you have redefined a default variable, the `origin'
     function will return the origin of the later definition.

`environment'
     if VARIABLE was defined as an environment variable and the `-e'
     option is _not_ turned on (*note Summary of Options: Options
     Summary.).

`environment override'
     if VARIABLE was defined as an environment variable and the `-e'
     option _is_ turned on (*note Summary of Options: Options Summary.).

`file'
     if VARIABLE was defined in a makefile.

`command line'
     if VARIABLE was defined on the command line.

`override'
     if VARIABLE was defined with an `override' directive in a makefile
     (*note The `override' Directive: Override Directive.).

`automatic'
     if VARIABLE is an automatic variable defined for the execution of
     the commands for each rule (*note Automatic Variables::).

   This information is primarily useful (other than for your curiosity)
to determine if you want to believe the value of a variable.  For
example, suppose you have a makefile `foo' that includes another
makefile `bar'.  You want a variable `bletch' to be defined in `bar' if
you run the command `make -f bar', even if the environment contains a
definition of `bletch'.  However, if `foo' defined `bletch' before
including `bar', you do not want to override that definition.  This
could be done by using an `override' directive in `foo', giving that
definition precedence over the later definition in `bar';
unfortunately, the `override' directive would also override any command
line definitions.  So, `bar' could include:

     ifdef bletch
     ifeq "$(origin bletch)" "environment"
     bletch = barf, gag, etc.
     endif
     endif

If `bletch' has been defined from the environment, this will redefine
it.

   If you want to override a previous definition of `bletch' if it came
from the environment, even under `-e', you could instead write:

     ifneq "$(findstring environment,$(origin bletch))" ""
     bletch = barf, gag, etc.
     endif

   Here the redefinition takes place if `$(origin bletch)' returns
either `environment' or `environment override'.  *Note Functions for
String Substitution and Analysis: Text Functions.


File: make.info,  Node: Flavor Function,  Next: Shell Function,  Prev: Origin Function,  Up: Functions

8.10 The `flavor' Function
==========================

The `flavor' function is unlike most other functions (and like `origin'
function) in that it does not operate on the values of variables; it
tells you something _about_ a variable.  Specifically, it tells you the
flavor of a variable (*note The Two Flavors of Variables: Flavors.).

   The syntax of the `flavor' function is:

     $(flavor VARIABLE)

   Note that VARIABLE is the _name_ of a variable to inquire about; not
a _reference_ to that variable.  Therefore you would not normally use a
`$' or parentheses when writing it.  (You can, however, use a variable
reference in the name if you want the name not to be a constant.)

   The result of this function is a string that identifies the flavor
of the variable VARIABLE:

`undefined'
     if VARIABLE was never defined.

`recursive'
     if VARIABLE is a recursively expanded variable.

`simple'
     if VARIABLE is a simply expanded variable.



File: make.info,  Node: Shell Function,  Next: Make Control Functions,  Prev: Flavor Function,  Up: Functions

8.11 The `shell' Function
=========================

The `shell' function is unlike any other function other than the
`wildcard' function (*note The Function `wildcard': Wildcard Function.)
in that it communicates with the world outside of `make'.

   The `shell' function performs the same function that backquotes
(``') perform in most shells: it does "command expansion".  This means
that it takes as an argument a shell command and evaluates to the
output of the command.  The only processing `make' does on the result
is to convert each newline (or carriage-return / newline pair) to a
single space.  If there is a trailing (carriage-return and) newline it
will simply be removed.

   The commands run by calls to the `shell' function are run when the
function calls are expanded (*note How `make' Reads a Makefile: Reading
Makefiles.).  Because this function involves spawning a new shell, you
should carefully consider the performance implications of using the
`shell' function within recursively expanded variables vs. simply
expanded variables (*note The Two Flavors of Variables: Flavors.).

   Here are some examples of the use of the `shell' function:

     contents := $(shell cat foo)

sets `contents' to the contents of the file `foo', with a space (rather
than a newline) separating each line.

     files := $(shell echo *.c)

sets `files' to the expansion of `*.c'.  Unless `make' is using a very
strange shell, this has the same result as `$(wildcard *.c)' (as long
as at least one `.c' file exists).


File: make.info,  Node: Make Control Functions,  Prev: Shell Function,  Up: Functions

8.12 Functions That Control Make
================================

These functions control the way make runs.  Generally, they are used to
provide information to the user of the makefile or to cause make to stop
if some sort of environmental error is detected.

`$(error TEXT...)'
     Generates a fatal error where the message is TEXT.  Note that the
     error is generated whenever this function is evaluated.  So, if
     you put it inside a command script or on the right side of a
     recursive variable assignment, it won't be evaluated until later.
     The TEXT will be expanded before the error is generated.

     For example,

          ifdef ERROR1
          $(error error is $(ERROR1))
          endif

     will generate a fatal error during the read of the makefile if the
     `make' variable `ERROR1' is defined.  Or,

          ERR = $(error found an error!)

          .PHONY: err
          err: ; $(ERR)

     will generate a fatal error while `make' is running, if the `err'
     target is invoked.

`$(warning TEXT...)'
     This function works similarly to the `error' function, above,
     except that `make' doesn't exit.  Instead, TEXT is expanded and
     the resulting message is displayed, but processing of the makefile
     continues.

     The result of the expansion of this function is the empty string.

`$(info TEXT...)'
     This function does nothing more than print its (expanded)
     argument(s) to standard output.  No makefile name or line number
     is added.  The result of the expansion of this function is the
     empty string.


File: make.info,  Node: Running,  Next: Implicit Rules,  Prev: Functions,  Up: Top

9 How to Run `make'
*******************

A makefile that says how to recompile a program can be used in more
than one way.  The simplest use is to recompile every file that is out
of date.  Usually, makefiles are written so that if you run `make' with
no arguments, it does just that.

   But you might want to update only some of the files; you might want
to use a different compiler or different compiler options; you might
want just to find out which files are out of date without changing them.

   By giving arguments when you run `make', you can do any of these
things and many others.

   The exit status of `make' is always one of three values:
`0'
     The exit status is zero if `make' is successful.

`2'
     The exit status is two if `make' encounters any errors.  It will
     print messages describing the particular errors.

`1'
     The exit status is one if you use the `-q' flag and `make'
     determines that some target is not already up to date.  *Note
     Instead of Executing the Commands: Instead of Execution.

* Menu:

* Makefile Arguments::          How to specify which makefile to use.
* Goals::                       How to use goal arguments to specify which
                                  parts of the makefile to use.
* Instead of Execution::        How to use mode flags to specify what
                                  kind of thing to do with the commands
                                  in the makefile other than simply
                                  execute them.
* Avoiding Compilation::        How to avoid recompiling certain files.
* Overriding::                  How to override a variable to specify
                                  an alternate compiler and other things.
* Testing::                     How to proceed past some errors, to
                                  test compilation.
* Options Summary::             Summary of Options


File: make.info,  Node: Makefile Arguments,  Next: Goals,  Prev: Running,  Up: Running

9.1 Arguments to Specify the Makefile
=====================================

The way to specify the name of the makefile is with the `-f' or
`--file' option (`--makefile' also works).  For example, `-f altmake'
says to use the file `altmake' as the makefile.

   If you use the `-f' flag several times and follow each `-f' with an
argument, all the specified files are used jointly as makefiles.

   If you do not use the `-f' or `--file' flag, the default is to try
`GNUmakefile', `makefile', and `Makefile', in that order, and use the
first of these three which exists or can be made (*note Writing
Makefiles: Makefiles.).


File: make.info,  Node: Goals,  Next: Instead of Execution,  Prev: Makefile Arguments,  Up: Running

9.2 Arguments to Specify the Goals
==================================

The "goals" are the targets that `make' should strive ultimately to
update.  Other targets are updated as well if they appear as
prerequisites of goals, or prerequisites of prerequisites of goals, etc.

   By default, the goal is the first target in the makefile (not
counting targets that start with a period).  Therefore, makefiles are
usually written so that the first target is for compiling the entire
program or programs they describe.  If the first rule in the makefile
has several targets, only the first target in the rule becomes the
default goal, not the whole list.  You can manage the selection of the
default goal from within your makefile using the `.DEFAULT_GOAL'
variable (*note Other Special Variables: Special Variables.).

   You can also specify a different goal or goals with command-line
arguments to `make'.  Use the name of the goal as an argument.  If you
specify several goals, `make' processes each of them in turn, in the
order you name them.

   Any target in the makefile may be specified as a goal (unless it
starts with `-' or contains an `=', in which case it will be parsed as
a switch or variable definition, respectively).  Even targets not in
the makefile may be specified, if `make' can find implicit rules that
say how to make them.

   `Make' will set the special variable `MAKECMDGOALS' to the list of
goals you specified on the command line.  If no goals were given on the
command line, this variable is empty.  Note that this variable should
be used only in special circumstances.

   An example of appropriate use is to avoid including `.d' files
during `clean' rules (*note Automatic Prerequisites::), so `make' won't
create them only to immediately remove them again:

     sources = foo.c bar.c

     ifneq ($(MAKECMDGOALS),clean)
     include $(sources:.c=.d)
     endif

   One use of specifying a goal is if you want to compile only a part of
the program, or only one of several programs.  Specify as a goal each
file that you wish to remake.  For example, consider a directory
containing several programs, with a makefile that starts like this:

     .PHONY: all
     all: size nm ld ar as

   If you are working on the program `size', you might want to say
`make size' so that only the files of that program are recompiled.

   Another use of specifying a goal is to make files that are not
normally made.  For example, there may be a file of debugging output,
or a version of the program that is compiled specially for testing,
which has a rule in the makefile but is not a prerequisite of the
default goal.

   Another use of specifying a goal is to run the commands associated
with a phony target (*note Phony Targets::) or empty target (*note
Empty Target Files to Record Events: Empty Targets.).  Many makefiles
contain a phony target named `clean' which deletes everything except
source files.  Naturally, this is done only if you request it
explicitly with `make clean'.  Following is a list of typical phony and
empty target names.  *Note Standard Targets::, for a detailed list of
all the standard target names which GNU software packages use.

`all'
     Make all the top-level targets the makefile knows about.

`clean'
     Delete all files that are normally created by running `make'.

`mostlyclean'
     Like `clean', but may refrain from deleting a few files that people
     normally don't want to recompile.  For example, the `mostlyclean'
     target for GCC does not delete `libgcc.a', because recompiling it
     is rarely necessary and takes a lot of time.

`distclean'
`realclean'
`clobber'
     Any of these targets might be defined to delete _more_ files than
     `clean' does.  For example, this would delete configuration files
     or links that you would normally create as preparation for
     compilation, even if the makefile itself cannot create these files.

`install'
     Copy the executable file into a directory that users typically
     search for commands; copy any auxiliary files that the executable
     uses into the directories where it will look for them.

`print'
     Print listings of the source files that have changed.

`tar'
     Create a tar file of the source files.

`shar'
     Create a shell archive (shar file) of the source files.

`dist'
     Create a distribution file of the source files.  This might be a
     tar file, or a shar file, or a compressed version of one of the
     above, or even more than one of the above.

`TAGS'
     Update a tags table for this program.

`check'
`test'
     Perform self tests on the program this makefile builds.


File: make.info,  Node: Instead of Execution,  Next: Avoiding Compilation,  Prev: Goals,  Up: Running

9.3 Instead of Executing the Commands
=====================================

The makefile tells `make' how to tell whether a target is up to date,
and how to update each target.  But updating the targets is not always
what you want.  Certain options specify other activities for `make'.

`-n'
`--just-print'
`--dry-run'
`--recon'
     "No-op".  The activity is to print what commands would be used to
     make the targets up to date, but not actually execute them.

`-t'
`--touch'
     "Touch".  The activity is to mark the targets as up to date without
     actually changing them.  In other words, `make' pretends to compile
     the targets but does not really change their contents.

`-q'
`--question'
     "Question".  The activity is to find out silently whether the
     targets are up to date already; but execute no commands in either
     case.  In other words, neither compilation nor output will occur.

`-W FILE'
`--what-if=FILE'
`--assume-new=FILE'
`--new-file=FILE'
     "What if".  Each `-W' flag is followed by a file name.  The given
     files' modification times are recorded by `make' as being the
     present time, although the actual modification times remain the
     same.  You can use the `-W' flag in conjunction with the `-n' flag
     to see what would happen if you were to modify specific files.

   With the `-n' flag, `make' prints the commands that it would
normally execute but does not execute them.

   With the `-t' flag, `make' ignores the commands in the rules and
uses (in effect) the command `touch' for each target that needs to be
remade.  The `touch' command is also printed, unless `-s' or `.SILENT'
is used.  For speed, `make' does not actually invoke the program
`touch'.  It does the work directly.

   With the `-q' flag, `make' prints nothing and executes no commands,
but the exit status code it returns is zero if and only if the targets
to be considered are already up to date.  If the exit status is one,
then some updating needs to be done.  If `make' encounters an error,
the exit status is two, so you can distinguish an error from a target
that is not up to date.

   It is an error to use more than one of these three flags in the same
invocation of `make'.

   The `-n', `-t', and `-q' options do not affect command lines that
begin with `+' characters or contain the strings `$(MAKE)' or
`${MAKE}'.  Note that only the line containing the `+' character or the
strings `$(MAKE)' or `${MAKE}' is run regardless of these options.
Other lines in the same rule are not run unless they too begin with `+'
or contain `$(MAKE)' or `${MAKE}' (*Note How the `MAKE' Variable Works:
MAKE Variable.)

   The `-W' flag provides two features:

   * If you also use the `-n' or `-q' flag, you can see what `make'
     would do if you were to modify some files.

   * Without the `-n' or `-q' flag, when `make' is actually executing
     commands, the `-W' flag can direct `make' to act as if some files
     had been modified, without actually modifying the files.

   Note that the options `-p' and `-v' allow you to obtain other
information about `make' or about the makefiles in use (*note Summary
of Options: Options Summary.).


File: make.info,  Node: Avoiding Compilation,  Next: Overriding,  Prev: Instead of Execution,  Up: Running

9.4 Avoiding Recompilation of Some Files
========================================

Sometimes you may have changed a source file but you do not want to
recompile all the files that depend on it.  For example, suppose you add
a macro or a declaration to a header file that many other files depend
on.  Being conservative, `make' assumes that any change in the header
file requires recompilation of all dependent files, but you know that
they do not need to be recompiled and you would rather not waste the
time waiting for them to compile.

   If you anticipate the problem before changing the header file, you
can use the `-t' flag.  This flag tells `make' not to run the commands
in the rules, but rather to mark the target up to date by changing its
last-modification date.  You would follow this procedure:

  1. Use the command `make' to recompile the source files that really
     need recompilation, ensuring that the object files are up-to-date
     before you begin.

  2. Make the changes in the header files.

  3. Use the command `make -t' to mark all the object files as up to
     date.  The next time you run `make', the changes in the header
     files will not cause any recompilation.

   If you have already changed the header file at a time when some files
do need recompilation, it is too late to do this.  Instead, you can use
the `-o FILE' flag, which marks a specified file as "old" (*note
Summary of Options: Options Summary.).  This means that the file itself
will not be remade, and nothing else will be remade on its account.
Follow this procedure:

  1. Recompile the source files that need compilation for reasons
     independent of the particular header file, with `make -o
     HEADERFILE'.  If several header files are involved, use a separate
     `-o' option for each header file.

  2. Touch all the object files with `make -t'.


File: make.info,  Node: Overriding,  Next: Testing,  Prev: Avoiding Compilation,  Up: Running

9.5 Overriding Variables
========================

An argument that contains `=' specifies the value of a variable: `V=X'
sets the value of the variable V to X.  If you specify a value in this
way, all ordinary assignments of the same variable in the makefile are
ignored; we say they have been "overridden" by the command line
argument.

   The most common way to use this facility is to pass extra flags to
compilers.  For example, in a properly written makefile, the variable
`CFLAGS' is included in each command that runs the C compiler, so a
file `foo.c' would be compiled something like this:

     cc -c $(CFLAGS) foo.c

   Thus, whatever value you set for `CFLAGS' affects each compilation
that occurs.  The makefile probably specifies the usual value for
`CFLAGS', like this:

     CFLAGS=-g

   Each time you run `make', you can override this value if you wish.
For example, if you say `make CFLAGS='-g -O'', each C compilation will
be done with `cc -c -g -O'.  (This also illustrates how you can use
quoting in the shell to enclose spaces and other special characters in
the value of a variable when you override it.)

   The variable `CFLAGS' is only one of many standard variables that
exist just so that you can change them this way.  *Note Variables Used
by Implicit Rules: Implicit Variables, for a complete list.

   You can also program the makefile to look at additional variables of
your own, giving the user the ability to control other aspects of how
the makefile works by changing the variables.

   When you override a variable with a command argument, you can define
either a recursively-expanded variable or a simply-expanded variable.
The examples shown above make a recursively-expanded variable; to make a
simply-expanded variable, write `:=' instead of `='.  But, unless you
want to include a variable reference or function call in the _value_
that you specify, it makes no difference which kind of variable you
create.

   There is one way that the makefile can change a variable that you
have overridden.  This is to use the `override' directive, which is a
line that looks like this: `override VARIABLE = VALUE' (*note The
`override' Directive: Override Directive.).


File: make.info,  Node: Testing,  Next: Options Summary,  Prev: Overriding,  Up: Running

9.6 Testing the Compilation of a Program
========================================

Normally, when an error happens in executing a shell command, `make'
gives up immediately, returning a nonzero status.  No further commands
are executed for any target.  The error implies that the goal cannot be
correctly remade, and `make' reports this as soon as it knows.

   When you are compiling a program that you have just changed, this is
not what you want.  Instead, you would rather that `make' try compiling
every file that can be tried, to show you as many compilation errors as
possible.

   On these occasions, you should use the `-k' or `--keep-going' flag.
This tells `make' to continue to consider the other prerequisites of
the pending targets, remaking them if necessary, before it gives up and
returns nonzero status.  For example, after an error in compiling one
object file, `make -k' will continue compiling other object files even
though it already knows that linking them will be impossible.  In
addition to continuing after failed shell commands, `make -k' will
continue as much as possible after discovering that it does not know
how to make a target or prerequisite file.  This will always cause an
error message, but without `-k', it is a fatal error (*note Summary of
Options: Options Summary.).

   The usual behavior of `make' assumes that your purpose is to get the
goals up to date; once `make' learns that this is impossible, it might
as well report the failure immediately.  The `-k' flag says that the
real purpose is to test as much as possible of the changes made in the
program, perhaps to find several independent problems so that you can
correct them all before the next attempt to compile.  This is why Emacs'
`M-x compile' command passes the `-k' flag by default.


File: make.info,  Node: Options Summary,  Prev: Testing,  Up: Running

9.7 Summary of Options
======================

Here is a table of all the options `make' understands:

`-b'
`-m'
     These options are ignored for compatibility with other versions of
     `make'.

`-B'
`--always-make'
     Consider all targets out-of-date.  GNU `make' proceeds to consider
     targets and their prerequisites using the normal algorithms;
     however, all targets so considered are always remade regardless of
     the status of their prerequisites.  To avoid infinite recursion, if
     `MAKE_RESTARTS' (*note Other Special Variables: Special
     Variables.) is set to a number greater than 0 this option is
     disabled when considering whether to remake makefiles (*note How
     Makefiles Are Remade: Remaking Makefiles.).

`-C DIR'
`--directory=DIR'
     Change to directory DIR before reading the makefiles.  If multiple
     `-C' options are specified, each is interpreted relative to the
     previous one: `-C / -C etc' is equiv