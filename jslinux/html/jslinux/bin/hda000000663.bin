2 "general_operand" "dKs,dmKs")))]
       ...)

 The first alternative has `m' (memory) for operand 0, `0' for operand
1 (meaning it must match operand 0), and `dKs' for operand 2.  The
second alternative has `d' (data register) for operand 0, `0' for
operand 1, and `dmKs' for operand 2.  The `=' and `%' in the
constraints apply to all the alternatives; their meaning is explained
in the next section (*note Class Preferences::).

 If all the operands fit any one alternative, the instruction is valid.
Otherwise, for each alternative, the compiler counts how many
instructions must be added to copy the operands so that that
alternative applies.  The alternative requiring the least copying is
chosen.  If two alternatives need the same amount of copying, the one
that comes first is chosen.  These choices can be altered with the `?'
and `!' characters:

`?'
     Disparage slightly the alternative that the `?' appears in, as a
     choice when no alternative applies exactly.  The compiler regards
     this alternative as one unit more costly for each `?' that appears
     in it.

`!'
     Disparage severely the alternative that the `!' appears in.  This
     alternative can still be used if it fits without reloading, but if
     reloading is needed, some other alternative will be used.

 When an insn pattern has multiple alternatives in its constraints,
often the appearance of the assembler code is determined mostly by which
alternative was matched.  When this is so, the C code for writing the
assembler code can use the variable `which_alternative', which is the
ordinal number of the alternative that was actually satisfied (0 for
the first, 1 for the second alternative, etc.).  *Note Output
Statement::.


File: gccint.info,  Node: Class Preferences,  Next: Modifiers,  Prev: Multi-Alternative,  Up: Constraints

14.8.3 Register Class Preferences
---------------------------------

The operand constraints have another function: they enable the compiler
to decide which kind of hardware register a pseudo register is best
allocated to.  The compiler examines the constraints that apply to the
insns that use the pseudo register, looking for the machine-dependent
letters such as `d' and `a' that specify classes of registers.  The
pseudo register is put in whichever class gets the most "votes".  The
constraint letters `g' and `r' also vote: they vote in favor of a
general register.  The machine description says which registers are
considered general.

 Of course, on some machines all registers are equivalent, and no
register classes are defined.  Then none of this complexity is relevant.


File: gccint.info,  Node: Modifiers,  Next: Machine Constraints,  Prev: Class Preferences,  Up: Constraints

14.8.4 Constraint Modifier Characters
-------------------------------------

Here are constraint modifier characters.

`='
     Means that this operand is write-only for this instruction: the
     previous value is discarded and replaced by output data.

`+'
     Means that this operand is both read and written by the
     instruction.

     When the compiler fixes up the operands to satisfy the constraints,
     it needs to know which operands are inputs to the instruction and
     which are outputs from it.  `=' identifies an output; `+'
     identifies an operand that is both input and output; all other
     operands are assumed to be input only.

     If you specify `=' or `+' in a constraint, you put it in the first
     character of the constraint string.

`&'
     Means (in a particular alternative) that this operand is an
     "earlyclobber" operand, which is modified before the instruction is
     finished using the input operands.  Therefore, this operand may
     not lie in a register that is used as an input operand or as part
     of any memory address.

     `&' applies only to the alternative in which it is written.  In
     constraints with multiple alternatives, sometimes one alternative
     requires `&' while others do not.  See, for example, the `movdf'
     insn of the 68000.

     An input operand can be tied to an earlyclobber operand if its only
     use as an input occurs before the early result is written.  Adding
     alternatives of this form often allows GCC to produce better code
     when only some of the inputs can be affected by the earlyclobber.
     See, for example, the `mulsi3' insn of the ARM.

     `&' does not obviate the need to write `='.

`%'
     Declares the instruction to be commutative for this operand and the
     following operand.  This means that the compiler may interchange
     the two operands if that is the cheapest way to make all operands
     fit the constraints.  This is often used in patterns for addition
     instructions that really have only two operands: the result must
     go in one of the arguments.  Here for example, is how the 68000
     halfword-add instruction is defined:

          (define_insn "addhi3"
            [(set (match_operand:HI 0 "general_operand" "=m,r")
               (plus:HI (match_operand:HI 1 "general_operand" "%0,0")
                        (match_operand:HI 2 "general_operand" "di,g")))]
            ...)
     GCC can only handle one commutative pair in an asm; if you use
     more, the compiler may fail.  Note that you need not use the
     modifier if the two alternatives are strictly identical; this
     would only waste time in the reload pass.  The modifier is not
     operational after register allocation, so the result of
     `define_peephole2' and `define_split's performed after reload
     cannot rely on `%' to make the intended insn match.

`#'
     Says that all following characters, up to the next comma, are to be
     ignored as a constraint.  They are significant only for choosing
     register preferences.

`*'
     Says that the following character should be ignored when choosing
     register preferences.  `*' has no effect on the meaning of the
     constraint as a constraint, and no effect on reloading.

     Here is an example: the 68000 has an instruction to sign-extend a
     halfword in a data register, and can also sign-extend a value by
     copying it into an address register.  While either kind of
     register is acceptable, the constraints on an address-register
     destination are less strict, so it is best if register allocation
     makes an address register its goal.  Therefore, `*' is used so
     that the `d' constraint letter (for data register) is ignored when
     computing register preferences.

          (define_insn "extendhisi2"
            [(set (match_operand:SI 0 "general_operand" "=*d,a")
                  (sign_extend:SI
                   (match_operand:HI 1 "general_operand" "0,g")))]
            ...)


File: gccint.info,  Node: Machine Constraints,  Next: Define Constraints,  Prev: Modifiers,  Up: Constraints

14.8.5 Constraints for Particular Machines
------------------------------------------

Whenever possible, you should use the general-purpose constraint letters
in `asm' arguments, since they will convey meaning more readily to
people reading your code.  Failing that, use the constraint letters
that usually have very similar meanings across architectures.  The most
commonly used constraints are `m' and `r' (for memory and
general-purpose registers respectively; *note Simple Constraints::), and
`I', usually the letter indicating the most common immediate-constant
format.

 Each architecture defines additional constraints.  These constraints
are used by the compiler itself for instruction generation, as well as
for `asm' statements; therefore, some of the constraints are not
particularly useful for `asm'.  Here is a summary of some of the
machine-dependent constraints available on some particular machines; it
includes both constraints that are useful for `asm' and constraints
that aren't.  The compiler source file mentioned in the table heading
for each architecture is the definitive reference for the meanings of
that architecture's constraints.

_ARM family--`config/arm/arm.h'_

    `f'
          Floating-point register

    `w'
          VFP floating-point register

    `F'
          One of the floating-point constants 0.0, 0.5, 1.0, 2.0, 3.0,
          4.0, 5.0 or 10.0

    `G'
          Floating-point constant that would satisfy the constraint `F'
          if it were negated

    `I'
          Integer that is valid as an immediate operand in a data
          processing instruction.  That is, an integer in the range 0
          to 255 rotated by a multiple of 2

    `J'
          Integer in the range -4095 to 4095

    `K'
          Integer that satisfies constraint `I' when inverted (ones
          complement)

    `L'
          Integer that satisfies constraint `I' when negated (twos
          complement)

    `M'
          Integer in the range 0 to 32

    `Q'
          A memory reference where the exact address is in a single
          register (``m'' is preferable for `asm' statements)

    `R'
          An item in the constant pool

    `S'
          A symbol in the text segment of the current file

    `Uv'
          A memory reference suitable for VFP load/store insns
          (reg+constant offset)

    `Uy'
          A memory reference suitable for iWMMXt load/store
          instructions.

    `Uq'
          A memory reference suitable for the ARMv4 ldrsb instruction.

_AVR family--`config/avr/constraints.md'_

    `l'
          Registers from r0 to r15

    `a'
          Registers from r16 to r23

    `d'
          Registers from r16 to r31

    `w'
          Registers from r24 to r31.  These registers can be used in
          `adiw' command

    `e'
          Pointer register (r26-r31)

    `b'
          Base pointer register (r28-r31)

    `q'
          Stack pointer register (SPH:SPL)

    `t'
          Temporary register r0

    `x'
          Register pair X (r27:r26)

    `y'
          Register pair Y (r29:r28)

    `z'
          Register pair Z (r31:r30)

    `I'
          Constant greater than -1, less than 64

    `J'
          Constant greater than -64, less than 1

    `K'
          Constant integer 2

    `L'
          Constant integer 0

    `M'
          Constant that fits in 8 bits

    `N'
          Constant integer -1

    `O'
          Constant integer 8, 16, or 24

    `P'
          Constant integer 1

    `G'
          A floating point constant 0.0

    `R'
          Integer constant in the range -6 ... 5.

    `Q'
          A memory address based on Y or Z pointer with displacement.

_CRX Architecture--`config/crx/crx.h'_

    `b'
          Registers from r0 to r14 (registers without stack pointer)

    `l'
          Register r16 (64-bit accumulator lo register)

    `h'
          Register r17 (64-bit accumulator hi register)

    `k'
          Register pair r16-r17. (64-bit accumulator lo-hi pair)

    `I'
          Constant that fits in 3 bits

    `J'
          Constant that fits in 4 bits

    `K'
          Constant that fits in 5 bits

    `L'
          Constant that is one of -1, 4, -4, 7, 8, 12, 16, 20, 32, 48

    `G'
          Floating point constant that is legal for store immediate

_Hewlett-Packard PA-RISC--`config/pa/pa.h'_

    `a'
          General register 1

    `f'
          Floating point register

    `q'
          Shift amount register

    `x'
          Floating point register (deprecated)

    `y'
          Upper floating point register (32-bit), floating point
          register (64-bit)

    `Z'
          Any register

    `I'
          Signed 11-bit integer constant

    `J'
          Signed 14-bit integer constant

    `K'
          Integer constant that can be deposited with a `zdepi'
          instruction

    `L'
          Signed 5-bit integer constant

    `M'
          Integer constant 0

    `N'
          Integer constant that can be loaded with a `ldil' instruction

    `O'
          Integer constant whose value plus one is a power of 2

    `P'
          Integer constant that can be used for `and' operations in
          `depi' and `extru' instructions

    `S'
          Integer constant 31

    `U'
          Integer constant 63

    `G'
          Floating-point constant 0.0

    `A'
          A `lo_sum' data-linkage-table memory operand

    `Q'
          A memory operand that can be used as the destination operand
          of an integer store instruction

    `R'
          A scaled or unscaled indexed memory operand

    `T'
          A memory operand for floating-point loads and stores

    `W'
          A register indirect memory operand

_PowerPC and IBM RS6000--`config/rs6000/rs6000.h'_

    `b'
          Address base register

    `f'
          Floating point register

    `v'
          Vector register

    `h'
          `MQ', `CTR', or `LINK' register

    `q'
          `MQ' register

    `c'
          `CTR' register

    `l'
          `LINK' register

    `x'
          `CR' register (condition register) number 0

    `y'
          `CR' register (condition register)

    `z'
          `FPMEM' stack memory for FPR-GPR transfers

    `I'
          Signed 16-bit constant

    `J'
          Unsigned 16-bit constant shifted left 16 bits (use `L'
          instead for `SImode' constants)

    `K'
          Unsigned 16-bit constant

    `L'
          Signed 16-bit constant shifted left 16 bits

    `M'
          Constant larger than 31

    `N'
          Exact power of 2

    `O'
          Zero

    `P'
          Constant whose negation is a signed 16-bit constant

    `G'
          Floating point constant that can be loaded into a register
          with one instruction per word

    `H'
          Integer/Floating point constant that can be loaded into a
          register using three instructions

    `Q'
          Memory operand that is an offset from a register (`m' is
          preferable for `asm' statements)

    `Z'
          Memory operand that is an indexed or indirect from a register
          (`m' is preferable for `asm' statements)

    `R'
          AIX TOC entry

    `a'
          Address operand that is an indexed or indirect from a
          register (`p' is preferable for `asm' statements)

    `S'
          Constant suitable as a 64-bit mask operand

    `T'
          Constant suitable as a 32-bit mask operand

    `U'
          System V Release 4 small data area reference

    `t'
          AND masks that can be performed by two rldic{l, r}
          instructions

    `W'
          Vector constant that does not require memory


_MorphoTech family--`config/mt/mt.h'_

    `I'
          Constant for an arithmetic insn (16-bit signed integer).

    `J'
          The constant 0.

    `K'
          Constant for a logical insn (16-bit zero-extended integer).

    `L'
          A constant that can be loaded with `lui' (i.e. the bottom 16
          bits are zero).

    `M'
          A constant that takes two words to load (i.e. not matched by
          `I', `K', or `L').

    `N'
          Negative 16-bit constants other than -65536.

    `O'
          A 15-bit signed integer constant.

    `P'
          A positive 16-bit constant.

_Intel 386--`config/i386/constraints.md'_

    `R'
          Legacy register--the eight integer registers available on all
          i386 processors (`a', `b', `c', `d', `si', `di', `bp', `sp').

    `q'
          Any register accessible as `Rl'.  In 32-bit mode, `a', `b',
          `c', and `d'; in 64-bit mode, any integer register.

    `Q'
          Any register accessible as `Rh': `a', `b', `c', and `d'.

    `l'
          Any register that can be used as the index in a base+index
          memory access: that is, any general register except the stack
          pointer.

    `a'
          The `a' register.

    `b'
          The `b' register.

    `c'
          The `c' register.

    `d'
          The `d' register.

    `S'
          The `si' register.

    `D'
          The `di' register.

    `A'
          The `a' and `d' registers, as a pair (for instructions that
          return half the result in one and half in the other).

    `f'
          Any 80387 floating-point (stack) register.

    `t'
          Top of 80387 floating-point stack (`%st(0)').

    `u'
          Second from top of 80387 floating-point stack (`%st(1)').

    `y'
          Any MMX register.

    `x'
          Any SSE register.

    `Yz'
          First SSE register (`%xmm0').

    `Y2'
          Any SSE register, when SSE2 is enabled.

    `Yi'
          Any SSE register, when SSE2 and inter-unit moves are enabled.

    `Ym'
          Any MMX register, when inter-unit moves are enabled.

    `I'
          Integer constant in the range 0 ... 31, for 32-bit shifts.

    `J'
          Integer constant in the range 0 ... 63, for 64-bit shifts.

    `K'
          Signed 8-bit integer constant.

    `L'
          `0xFF' or `0xFFFF', for andsi as a zero-extending move.

    `M'
          0, 1, 2, or 3 (shifts for the `lea' instruction).

    `N'
          Unsigned 8-bit integer constant (for `in' and `out'
          instructions).

    `O'
          Integer constant in the range 0 ... 127, for 128-bit shifts.

    `G'
          Standard 80387 floating point constant.

    `C'
          Standard SSE floating point constant.

    `e'
          32-bit signed integer constant, or a symbolic reference known
          to fit that range (for immediate operands in sign-extending
          x86-64 instructions).

    `Z'
          32-bit unsigned integer constant, or a symbolic reference
          known to fit that range (for immediate operands in
          zero-extending x86-64 instructions).


_Intel IA-64--`config/ia64/ia64.h'_

    `a'
          General register `r0' to `r3' for `addl' instruction

    `b'
          Branch register

    `c'
          Predicate register (`c' as in "conditional")

    `d'
          Application register residing in M-unit

    `e'
          Application register residing in I-unit

    `f'
          Floating-point register

    `m'
          Memory operand.  Remember that `m' allows postincrement and
          postdecrement which require printing with `%Pn' on IA-64.
          Use `S' to disallow postincrement and postdecrement.

    `G'
          Floating-point constant 0.0 or 1.0

    `I'
          14-bit signed integer constant

    `J'
          22-bit signed integer constant

    `K'
          8-bit signed integer constant for logical instructions

    `L'
          8-bit adjusted signed integer constant for compare pseudo-ops

    `M'
          6-bit unsigned integer constant for shift counts

    `N'
          9-bit signed integer constant for load and store
          postincrements

    `O'
          The constant zero

    `P'
          0 or -1 for `dep' instruction

    `Q'
          Non-volatile memory for floating-point loads and stores

    `R'
          Integer constant in the range 1 to 4 for `shladd' instruction

    `S'
          Memory operand except postincrement and postdecrement

_FRV--`config/frv/frv.h'_

    `a'
          Register in the class `ACC_REGS' (`acc0' to `acc7').

    `b'
          Register in the class `EVEN_ACC_REGS' (`acc0' to `acc7').

    `c'
          Register in the class `CC_REGS' (`fcc0' to `fcc3' and `icc0'
          to `icc3').

    `d'
          Register in the class `GPR_REGS' (`gr0' to `gr63').

    `e'
          Register in the class `EVEN_REGS' (`gr0' to `gr63').  Odd
          registers are excluded not in the class but through the use
          of a machine mode larger than 4 bytes.

    `f'
          Register in the class `FPR_REGS' (`fr0' to `fr63').

    `h'
          Register in the class `FEVEN_REGS' (`fr0' to `fr63').  Odd
          registers are excluded not in the class but through the use
          of a machine mode larger than 4 bytes.

    `l'
          Register in the class `LR_REG' (the `lr' register).

    `q'
          Register in the class `QUAD_REGS' (`gr2' to `gr63').
          Register numbers not divisible by 4 are excluded not in the
          class but through the use of a machine mode larger than 8
          bytes.

    `t'
          Register in the class `ICC_REGS' (`icc0' to `icc3').

    `u'
          Register in the class `FCC_REGS' (`fcc0' to `fcc3').

    `v'
          Register in the class `ICR_REGS' (`cc4' to `cc7').

    `w'
          Register in the class `FCR_REGS' (`cc0' to `cc3').

    `x'
          Register in the class `QUAD_FPR_REGS' (`fr0' to `fr63').
          Register numbers not divisible by 4 are excluded not in the
          class but through the use of a machine mode larger than 8
          bytes.

    `z'
          Register in the class `SPR_REGS' (`lcr' and `lr').

    `A'
          Register in the class `QUAD_ACC_REGS' (`acc0' to `acc7').

    `B'
          Register in the class `ACCG_REGS' (`accg0' to `accg7').

    `C'
          Register in the class `CR_REGS' (`cc0' to `cc7').

    `G'
          Floating point constant zero

    `I'
          6-bit signed integer constant

    `J'
          10-bit signed integer constant

    `L'
          16-bit signed integer constant

    `M'
          16-bit unsigned integer constant

    `N'
          12-bit signed integer constant that is negative--i.e. in the
          range of -2048 to -1

    `O'
          Constant zero

    `P'
          12-bit signed integer constant that is greater than
          zero--i.e. in the range of 1 to 2047.


_Blackfin family--`config/bfin/bfin.h'_

    `a'
          P register

    `d'
          D register

    `z'
          A call clobbered P register.

    `qN'
          A single register.  If N is in the range 0 to 7, the
          corresponding D register.  If it is `A', then the register P0.

    `D'
          Even-numbered D register

    `W'
          Odd-numbered D register

    `e'
          Accumulator register.

    `A'
          Even-numbered accumulator register.

    `B'
          Odd-numbered accumulator register.

    `b'
          I register

    `v'
          B register

    `f'
          M register

    `c'
          Registers used for circular buffering, i.e. I, B, or L
          registers.

    `C'
          The CC register.

    `t'
          LT0 or LT1.

    `k'
          LC0 or LC1.

    `u'
          LB0 or LB1.

    `x'
          Any D, P, B, M, I or L register.

    `y'
          Additional registers typically used only in prologues and
          epilogues: RETS, RETN, RETI, RETX, RETE, ASTAT, SEQSTAT and
          USP.

    `w'
          Any register except accumulators or CC.

    `Ksh'
          Signed 16 bit integer (in the range -32768 to 32767)

    `Kuh'
          Unsigned 16 bit integer (in the range 0 to 65535)

    `Ks7'
          Signed 7 bit integer (in the range -64 to 63)

    `Ku7'
          Unsigned 7 bit integer (in the range 0 to 127)

    `Ku5'
          Unsigned 5 bit integer (in the range 0 to 31)

    `Ks4'
          Signed 4 bit integer (in the range -8 to 7)

    `Ks3'
          Signed 3 bit integer (in the range -3 to 4)

    `Ku3'
          Unsigned 3 bit integer (in the range 0 to 7)

    `PN'
          Constant N, where N is a single-digit constant in the range 0
          to 4.

    `PA'
          An integer equal to one of the MACFLAG_XXX constants that is
          suitable for use with either accumulator.

    `PB'
          An integer equal to one of the MACFLAG_XXX constants that is
          suitable for use only with accumulator A1.

    `M1'
          Constant 255.

    `M2'
          Constant 65535.

    `J'
          An integer constant with exactly a single bit set.

    `L'
          An integer constant with all bits set except exactly one.

    `H'

    `Q'
          Any SYMBOL_REF.

_M32C--`config/m32c/m32c.c'_

    `Rsp'
    `Rfb'
    `Rsb'
          `$sp', `$fb', `$sb'.

    `Rcr'
          Any control register, when they're 16 bits wide (nothing if
          control registers are 24 bits wide)

    `Rcl'
          Any control register, when they're 24 bits wide.

    `R0w'
    `R1w'
    `R2w'
    `R3w'
          $r0, $r1, $r2, $r3.

    `R02'
          $r0 or $r2, or $r2r0 for 32 bit values.

    `R13'
          $r1 or $r3, or $r3r1 for 32 bit values.

    `Rdi'
          A register that can hold a 64 bit value.

    `Rhl'
          $r0 or $r1 (registers with addressable high/low bytes)

    `R23'
          $r2 or $r3

    `Raa'
          Address registers

    `Raw'
          Address registers when they're 16 bits wide.

    `Ral'
          Address registers when they're 24 bits wide.

    `Rqi'
          Registers that can hold QI values.

    `Rad'
          Registers that can be used with displacements ($a0, $a1, $sb).

    `Rsi'
          Registers that can hold 32 bit values.

    `Rhi'
          Registers that can hold 16 bit values.

    `Rhc'
          Registers chat can hold 16 bit values, including all control
          registers.

    `Rra'
          $r0 through R1, plus $a0 and $a1.

    `Rfl'
          The flags register.

    `Rmm'
          The memory-based pseudo-registers $mem0 through $mem15.

    `Rpi'
          Registers that can hold pointers (16 bit registers for r8c,
          m16c; 24 bit registers for m32cm, m32c).

    `Rpa'
          Matches multiple registers in a PARALLEL to form a larger
          register.  Used to match function return values.

    `Is3'
          -8 ... 7

    `IS1'
          -128 ... 127

    `IS2'
          -32768 ... 32767

    `IU2'
          0 ... 65535

    `In4'
          -8 ... -1 or 1 ... 8

    `In5'
          -16 ... -1 or 1 ... 16

    `In6'
          -32 ... -1 or 1 ... 32

    `IM2'
          -65536 ... -1

    `Ilb'
          An 8 bit value with exactly one bit set.

    `Ilw'
          A 16 bit value with exactly one bit set.

    `Sd'
          The common src/dest memory addressing modes.

    `Sa'
          Memory addressed using $a0 or $a1.

    `Si'
          Memory addressed with immediate addresses.

    `Ss'
          Memory addressed using the stack pointer ($sp).

    `Sf'
          Memory addressed using the frame base register ($fb).

    `Ss'
          Memory addressed using the small base register ($sb).

    `S1'
          $r1h

_MIPS--`config/mips/constraints.md'_

    `d'
          An address register.  This is equivalent to `r' unless
          generating MIPS16 code.

    `f'
          A floating-point register (if available).

    `h'
          The `hi' register.

    `l'
          The `lo' register.

    `x'
          The `hi' and `lo' registers.

    `c'
          A register suitable for use in an indirect jump.  This will
          always be `$25' for `-mabicalls'.

    `v'
          Register `$3'.  Do not use this constraint in new code; it is
          retained only for compatibility with glibc.

    `y'
          Equivalent to `r'; retained for backwards compatibility.

    `z'
          A floating-point condition code register.

    `I'
          A signed 16-bit constant (for arithmetic instructions).

    `J'
          Integer zero.

    `K'
          An unsigned 16-bit constant (for logic instructions).

    `L'
          A signed 32-bit constant in which the lower 16 bits are zero.
          Such constants can be loaded using `lui'.

    `M'
          A constant that cannot be loaded using `lui', `addiu' or
          `ori'.

    `N'
          A constant in the range -65535 to -1 (inclusive).

    `O'
          A signed 15-bit constant.

    `P'
          A constant in the range 1 to 65535 (inclusive).

    `G'
          Floating-point zero.

    `R'
          An address that can be used in a non-macro load or store.

_Motorola 680x0--`config/m68k/constraints.md'_

    `a'
          Address register

    `d'
          Data register

    `f'
          68881 floating-point register, if available

    `I'
          Integer in the range 1 to 8

    `J'
          16-bit signed number

    `K'
          Signed number whose magnitude is greater than 0x80

    `L'
          Integer in the range -8 to -1

    `M'
          Signed number whose magnitude is greater than 0x100

    `N'
          Range 24 to 31, rotatert:SI 8 to 1 expressed as rotate

    `O'
          16 (for rotate using swap)

    `P'
          Range 8 to 15, rotatert:HI 8 to 1 expressed as rotate

    `R'
          Numbers that mov3q can handle

    `G'
          Floating point constant that is not a 68881 constant

    `S'
          Operands that satisfy 'm' when -mpcrel is in effect

    `T'
          Operands that satisfy 's' when -mpcrel is not in effect

    `Q'
          Address register indirect addressing mode

    `U'
          Register offset addressing

    `W'
          const_call_operand

    `Cs'
          symbol_ref or const

    `Ci'
          const_int

    `C0'
          const_int 0

    `Cj'
          Range of signed numbers that don't fit in 16 bits

    `Cmvq'
          Integers valid for mvq

    `Capsw'
          Integers valid for a moveq followed by a swap

    `Cmvz'
          Integers valid for mvz

    `Cmvs'
          Integers valid for mvs

    `Ap'
          push_operand

    `Ac'
          Non-register operands allowed in clr


_Motorola 68HC11 & 68HC12 families--`config/m68hc11/m68hc11.h'_

    `a'
          Register `a'

    `b'
          Register `b'

    `d'
          Register `d'

    `q'
          An 8-bit register

    `t'
          Temporary soft register _.tmp

    `u'
          A soft register _.d1 to _.d31

    `w'
          Stack pointer register

    `x'
          Register `x'

    `y'
          Register `y'

    `z'
          Pseudo register `z' (replaced by `x' or `y' at the end)

    `A'
          An address register: x, y or z

    `B'
          An address register: x or y

    `D'
          Register pair (x:d) to form a 32-bit value

    `L'
          Constants in the range -65536 to 65535

    `M'
          Constants whose 16-bit low part is zero

    `N'
          Constant integer 1 or -1

    `O'
          Constant integer 16

    `P'
          Constants in the range -8 to 2


_SPARC--`config/sparc/sparc.h'_

    `f'
          Floating-point register on the SPARC-V8 architecture and
          lower floating-point register on the SPARC-V9 architecture.

    `e'
          Floating-point register.  It is equivalent to `f' on the
          SPARC-V8 architecture and contains both lower and upper
          floating-point registers on the SPARC-V9 architecture.

    `c'
          Floating-point condition code register.

    `d'
          Lower floating-point register.  It is only valid on the
          SPARC-V9 architecture when the Visual Instruction Set is
          available.

    `b'
          Floating-point register.  It is only valid on the SPARC-V9
          architecture when the Visual Instruction Set is available.

    `h'
          64-bit global or out register for the SPARC-V8+ architecture.

    `D'
          A vector constant

    `I'
          Signed 13-bit constant

    `J'
          Zero

    `K'
          32-bit constant with the low 12 bits clear (a constant that
          can be loaded with the `sethi' instruction)

    `L'
          A constant in the range supported by `movcc' instructions

    `M'
          A constant in the range supported by `movrcc' instructions

    `N'
          Same as `K', except that it verifies that bits that are not
          in the lower 32-bit range are all zero.  Must be used instead
          of `K' for modes wider than `SImode'

    `O'
          The constant 4096

    `G'
          Floating-point zero

    `H'
          Signed 13-bit constant, sign-extended to 32 or 64 bits

    `Q'
          Floating-point constant whose integral representation can be
          moved into an integer register using a single sethi
          instruction

    `R'
          Floating-point constant whose integral representation can be
          moved into an integer register using a single mov instruction

    `S'
          Floating-point constant whose integral representation can be
          moved into an integer register using a high/lo_sum
          instruction sequence

    `T'
          Memory address aligned to an 8-byte boundary

    `U'
          Even register

    `W'
          Memory address for `e' constraint registers

    `Y'
          Vector zero


_SPU--`config/spu/spu.h'_

    `a'
          An immediate which can be loaded with the il/ila/ilh/ilhu
          instructions.  const_int is treated as a 64 bit value.

    `c'
          An immediate for and/xor/or instructions.  const_int is
          treated as a 64 bit value.

    `d'
          An immediate for the `iohl' instruction.  const_int is
          treated as a 64 bit value.

    `f'
          An immediate which can be loaded with `fsmbi'.

    `A'
          An immediate which can be loaded with the il/ila/ilh/ilhu
          instructions.  const_int is treated as a 32 bit value.

    `B'
          An immediate for most arithmetic instructions.  const_int is
          treated as a 32 bit value.

    `C'
          An immediate for and/xor/or instructions.  const_int is
          treated as a 32 bit value.

    `D'
          An immediate for the `iohl' instruction.  const_int is
          treated as a 32 bit value.

    `I'
          A constant in the range [-64, 63] for shift/rotate
          instructions.

    `J'
          An unsigned 7-bit constant for conversion/nop/channel
          instructions.

    `K'
          A signed 10-bit constant for most arithmetic instructions.

    `M'
          A signed 16 bit immediate for `stop'.

    `N'
          An unsigned 16-bit constant for `iohl' and `fsmbi'.

    `O'
          An unsigned 7-bit constant whose 3 least significant bits are
          0.

    `P'
          An unsigned 3-bit constant for 16-byte rotates and shifts

    `R'
          Call operand, reg, for indirect calls

    `S'
          Call operand, symbol, for relative calls.

    `T'
          Call operand, const_int, for absolute calls.

    `U'
          An immediate which can be loaded with the il/ila/ilh/ilhu
          instructions.  const_int is sign extended to 128 bit.

    `W'
          An immediate for shift and rotate instructions.  const_int is
          treated as a 32 bit value.

    `Y'
          An immediate for and/xor/or instructions.  const_int is sign
          extended as a 128 bit.

    `Z'
          An immediate for the `iohl' instruction.  const_int is sign
          extended to 128 bit.


_S/390 and zSeries--`config/s390/s390.h'_

    `a'
          Address register (general purpose register except r0)

    `c'
          Condition code register

    `d'
          Data register (arbitrary general purpose register)

    `f'
          Floating-point register

    `I'
          Unsigned 8-bit constant (0-255)

    `J'
          Unsigned 12-bit constant (0-4095)

    `K'
          Signed 16-bit constant (-32768-32767)

    `L'
          Value appropriate as displacement.
         `(0..4095)'
               for short displacement

         `(-524288..524287)'
               for long displacement

    `M'
          Constant integer with a value of 0x7fffffff.

    `N'
          Multiple letter constraint followed by 4 parameter letters.
         `0..9:'
               number of the part counting from most to least
               significant

         `H,Q:'
               mode of the part

         `D,S,H:'
               mode of the containing operand

         `0,F:'
               value of the other parts (F--all bits set)
          The constraint matches if the specified part of a constant
          has a value different from its other parts.

    `Q'
          Memory reference without index register and with short
          displacement.

    `R'
          Memory reference with index register and short displacement.

    `S'
          Memory reference without index register but with long
          displacement.

    `T'
          Memory reference with index register and long displacement.

    `U'
          Pointer with short displacement.

    `W'
          Pointer with long displacement.

    `Y'
          Shift count operand.


_Score family--`config/score/score.h'_

    `d'
          Registers from r0 to r32.

    `e'
          Registers from r0 to r16.

    `t'
          r8--r11 or r22--r27 registers.

    `h'
          hi register.

    `l'
          lo register.

    `x'
          hi + lo register.

    `q'
          cnt register.

    `y'
          lcb register.

    `z'
          scb register.

    `a'
          cnt + lcb + scb register.

    `c'
          cr0--cr15 register.

    `b'
          cp1 registers.

    `f'
          cp2 registers.

    `i'
          cp3 registers.

    `j'
          cp1 + cp2 + cp3 registers.

    `I'
          High 16-bit constant (32-bit constant with 16 LSBs zero).

    `J'
          Unsigned 5 bit integer (in the range 0 to 31).

    `K'
          Unsigned 16 bit integer (in the range 0 to 65535).

    `L'
          Signed 16 bit integer (in the range -32768 to 32767).

    `M'
          Unsigned 14 bit integer (in the range 0 to 16383).

    `N'
          Signed 14 bit integer (in the range -8192 to 8191).

    `Z'
          Any SYMBOL_REF.

_Xstormy16--`config/stormy16/stormy16.h'_

    `a'
          Register r0.

    `b'
          Register r1.

    `c'
          Register r2.

    `d'
          Register r8.

    `e'
          Registers r0 through r7.

    `t'
          Registers r0 and r1.

    `y'
          The carry register.

    `z'
          Registers r8 and r9.

    `I'
          A constant between 0 and 3 inclusive.

    `J'
          A constant that has exactly one bit set.

    `K'
          A constant that has exactly one bit clear.

    `L'
          A constant between 0 and 255 inclusive.

    `M'
          A constant between -255 and 0 inclusive.

    `N'
          A constant between -3 and 0 inclusive.

    `O'
          A constant between 1 and 4 inclusive.

    `P'
          A constant between -4 and -1 inclusive.

    `Q'
          A memory reference that is a stack push.

    `R'
          A memory reference that is a stack pop.

    `S'
          A memory reference that refers to a constant address of known
          value.

    `T'
          The register indicated by Rx (not implemented yet).

    `U'
          A constant that is not between 2 and 15 inclusive.

    `Z'
          The constant 0.


_Xtensa--`config/xtensa/constraints.md'_

    `a'
          General-purpose 32-bit register

    `b'
          One-bit boolean register

    `A'
          MAC16 40-bit accumulator register

    `I'
          Signed 12-bit integer constant, for use in MOVI instructions

    `J'
          Signed 8-bit integer constant, for use in ADDI instructions

    `K'
          Integer constant valid for BccI instructions

    `L'
          Unsigned constant valid for BccUI instructions




File: gccint.info,  Node: Define Constraints,  Next: C Constraint Interface,  Prev: Machine Constraints,  Up: Constraints

14.8.6 Defining Machine-Specific Constraints
--------------------------------------------

Machine-specific constraints fall into two categories: register and
non-register constraints.  Within the latter category, constraints
which allow subsets of all possible memory or address operands should
be specially marked, to give `reload' more information.

 Machine-specific constraints can be given names of arbitrary length,
but they must be entirely composed of letters, digits, underscores
(`_'), and angle brackets (`< >').  Like C identifiers, they must begin
with a letter or underscore.

 In order to avoid ambiguity in operand constraint strings, no
constraint can have a name that begins with any other constraint's
name.  For example, if `x' is defined as a constraint name, `xy' may
not be, and vice versa.  As a consequence of this rule, no constraint
may begin with one of the generic constraint letters: `E F V X g i m n
o p r s'.

 Register constraints correspond directly to register classes.  *Note
Register Classes::.  There is thus not much flexibility in their
definitions.

 -- MD Expression: define_register_constraint name regclass docstring
     All three arguments are string constants.  NAME is the name of the
     constraint, as it will appear in `match_operand' expressions.  If
     NAME is a multi-letter constraint its length shall be the same for
     all constraints starting with the same letter.  REGCLASS can be
     either the name of the corresponding register class (*note
     Register Classes::), or a C expression which evaluates to the
     appropriate register class.  If it is an expression, it must have
     no side effects, and it cannot look at the operand.  The usual use
     of expressions is to map some register constraints to `NO_REGS'
     when the register class is not available on a given
     subarchitecture.

     DOCSTRING is a sentence documenting the meaning of the constraint.
     Docstrings are explained further below.

 Non-register constraints are more like predicates: the constraint
definition gives a Boolean expression which indicates whether the
constraint matches.

 -- MD Expression: define_constraint name docstring exp
     The NAME and DOCSTRING arguments are the same as for
     `define_register_constraint', but note that the docstring comes
     immediately after the name for these expressions.  EXP is an RTL
     expression, obeying the same rules as the RTL expressions in
     predicate definitions.  *Note Defining Predicates::, for details.
     If it evaluates true, the constraint matches; if it evaluates
     false, it doesn't. Constraint expressions should indicate which
     RTL codes they might match, just like predicate expressions.

     `match_test' C expressions have access to the following variables:

    OP
          The RTL object defining the operand.

    MODE
          The machine mode of OP.

    IVAL
          `INTVAL (OP)', if OP is a `const_int'.

    HVAL
          `CONST_DOUBLE_HIGH (OP)', if OP is an integer `const_double'.

    LVAL
          `CONST_DOUBLE_LOW (OP)', if OP is an integer `const_double'.

    RVAL
          `CONST_DOUBLE_REAL_VALUE (OP)', if OP is a floating-point
          `const_double'.

     The *VAL variables should only be used once another piece of the
     expression has verified that OP is the appropriate kind of RTL
     object.

 Most non-register constraints should be defined with
`define_constraint'.  The remaining two definition expressions are only
appropriate for constraints that should be handled specially by
`reload' if they fail to match.

 -- MD Expression: define_memory_constraint name docstring exp
     Use this expression for constraints that match a subset of all
     memory operands: that is, `reload' can make them match by
     converting the operand to the form `(mem (reg X))', where X is a
     base register (from the register class specified by
     `BASE_REG_CLASS', *note Register Classes::).

     For example, on the S/390, some instructions do not accept
     arbitrary memory references, but only those that do not make use
     of an index register.  The constraint letter `Q' is defined to
     represent a memory address of this type.  If `Q' is defined with
     `define_memory_constraint', a `Q' constraint can handle any memory
     operand, because `reload' knows it can simply copy the memory
     address into a base register if required.  This is analogous to
     the way a `o' constraint can handle any memory operand.

     The syntax and semantics are otherwise identical to
     `define_constraint'.

 -- MD Expression: define_address_constraint name docstring exp
     Use this expression for constraints that match a subset of all
     address operands: that is, `reload' can make the constraint match
     by converting the operand to the form `(reg X)', again with X a
     base register.

     Constraints defined with `define_address_constraint' can only be
     used with the `address_operand' predicate, or machine-specific
     predicates that work the same way.  They are treated analogously to
     the generic `p' constraint.

     The syntax and semantics are otherwise identical to
     `define_constraint'.

 For historical reasons, names beginning with the letters `G H' are
reserved for constraints that match only `const_double's, and names
beginning with the letters `I J K L M N O P' are reserved for
constraints that match only `const_int's.  This may change in the
future.  For the time being, constraints with these names must be
written in a stylized form, so that `genpreds' can tell you did it
correctly:

     (define_constraint "[GHIJKLMNOP]..."
       "DOC..."
       (and (match_code "const_int")  ; `const_double' for G/H
            CONDITION...))            ; usually a `match_test'

 It is fine to use names beginning with other letters for constraints
that match `const_double's or `const_int's.

 Each docstring in a constraint definition should be one or more
complete sentences, marked up in Texinfo format.  _They are currently
unused._ In the future they will be copied into the GCC manual, in
*note Machine Constraints::, replacing the hand-maintained tables
currently found in that section.  Also, in the future the compiler may
use this to give more helpful diagnostics when poor choice of `asm'
constraints causes a reload failure.

 If you put the pseudo-Texinfo directive `@internal' at the beginning
of a docstring, then (in the future) it will appear only in the
internals manual's version of the machine-specific constraint tables.
Use this for constraints that should not appear in `asm' statements.


File: gccint.info,  Node: C Constraint Interface,  Prev: Define Constraints,  Up: Constraints

14.8.7 Testing constraints from C
---------------------------------

It is occasionally useful to test a constraint from C code rather than
implicitly via the constraint string in a `match_operand'.  The
generated file `tm_p.h' declares a few interfaces for working with
machine-specific constraints.  None of these interfaces work with the
generic constraints described in *note Simple Constraints::.  This may
change in the future.

 *Warning:* `tm_p.h' may declare other functions that operate on
constraints, besides the ones documented here.  Do not use those
functions from machine-dependent code.  They exist to implement the old
constraint interface that machine-independent components of the
compiler still expect.  They will change or disappear in the future.

 Some valid constraint names are not valid C identifiers, so there is a
mangling scheme for referring to them from C.  Constraint names that do
not contain angle brackets or underscores are left unchanged.
Underscores are doubled, each `<' is replaced with `_l', and each `>'
with `_g'.  Here are some examples:

     *Original* *Mangled*
     `x'        `x'
     `P42x'     `P42x'
     `P4_x'     `P4__x'
     `P4>x'     `P4_gx'
     `P4>>'     `P4_g_g'
     `P4_g>'    `P4__g_g'

 Throughout this section, the variable C is either a constraint in the
abstract sense, or a constant from `enum constraint_num'; the variable
M is a mangled constraint name (usually as part of a larger identifier).

 -- Enum: constraint_num
     For each machine-specific constraint, there is a corresponding
     enumeration constant: `CONSTRAINT_' plus the mangled name of the
     constraint.  Functions that take an `enum constraint_num' as an
     argument expect one of these constants.

     Machine-independent constraints do not have associated constants.
     This may change in the future.

 -- Function: inline bool satisfies_constraint_M (rtx EXP)
     For each machine-specific, non-register constraint M, there is one
     of these functions; it returns `true' if EXP satisfies the
     constraint.  These functions are only visible if `rtl.h' was
     included before `tm_p.h'.

 -- Function: bool constraint_satisfied_p (rtx EXP, enum constraint_num
          C)
     Like the `satisfies_constraint_M' functions, but the constraint to
     test is given as an argument, C.  If C specifies a register
     constraint, this function will always return `false'.

 -- Function: enum reg_class regclass_for_constraint (enum
          constraint_num C)
     Returns the register class associated with C.  If C is not a
     register constraint, or those registers are not available for the
     currently selected subtarget, returns `NO_REGS'.

 Here is an example use of `satisfies_constraint_M'.  In peephole
optimizations (*note Peephole Definitions::), operand constraint
strings are ignored, so if there are relevant constraints, they must be
tested in the C condition.  In the example, the optimization is applied
if operand 2 does _not_ satisfy the `K' constraint.  (This is a
simplified version of a peephole definition from the i386 machine
description.)

     (define_peephole2
       [(match_scratch:SI 3 "r")
        (set (match_operand:SI 0 "register_operand" "")
     	(mult:SI (match_operand:SI 1 "memory_operand" "")
     		 (match_operand:SI 2 "immediate_operand" "")))]

       "!satisfies_constraint_K (operands[2])"

       [(set (match_dup 3) (match_dup 1))
        (set (match_dup 0) (mult:SI (match_dup 3) (match_dup 2)))]

       "")


File: gccint.info,  Node: Standard Names,  Next: Pattern Ordering,  Prev: Constraints,  Up: Machine Desc

14.9 Standard Pattern Names For Generation
==========================================

Here is a table of the instruction names that are meaningful in the RTL
generation pass of the compiler.  Giving one of these names to an
instruction pattern tells the RTL generation pass that it can use the
pattern to accomplish a certain task.

`movM'
     Here M stands for a two-letter machine mode name, in lowercase.
     This instruction pattern moves data with that machine mode from
     operand 1 to operand 0.  For example, `movsi' moves full-word data.

     If operand 0 is a `subreg' with mode M of a register whose own
     mode is wider than M, the effect of this instruction is to store
     the specified value in the part of the register that corresponds
     to mode M.  Bits outside of M, but which are within the same
     target word as the `subreg' are undefined.  Bits which are outside
     the target word are left unchanged.

     This class of patterns is special in several ways.  First of all,
     each of these names up to and including full word size _must_ be
     defined, because there is no other way to copy a datum from one
     place to another.  If there are patterns accepting operands in
     larger modes, `movM' must be defined for integer modes of those
     sizes.

     Second, these patterns are not used solely in the RTL generation
     pass.  Even the reload pass can generate move insns to copy values
     from stack slots into temporary registers.  When it does so, one
     of the operands is a hard register and the other is an operand
     that can need to be reloaded into a register.

     Therefore, when given such a pair of operands, the pattern must
     generate RTL which needs no reloading and needs no temporary
     registers--no registers other than the operands.  For example, if
     you support the pattern with a `define_expand', then in such a
     case the `define_expand' mustn't call `force_reg' or any other such
     function which might generate new pseudo registers.

     This requirement exists even for subword modes on a RISC machine
     where fetching those modes from memory normally requires several
     insns and some temporary registers.

     During reload a memory reference with an invalid address may be
     passed as an operand.  Such an address will be replaced with a
     valid address later in the reload pass.  In this case, nothing may
     be done with the address except to use it as it stands.  If it is
     copied, it will not be replaced with a valid address.  No attempt
     should be made to make such an address into a valid address and no
     routine (such as `change_address') that will do so may be called.
     Note that `general_operand' will fail when applied to such an
     address.

     The global variable `reload_in_progress' (which must be explicitly
     declared if required) can be used to determine whether such special
     handling is required.

     The variety of operands that have reloads depends on the rest of
     the machine description, but typically on a RISC machine these can
     only be pseudo registers that did not get hard registers, while on
     other machines explicit memory references will get optional
     reloads.

     If a scratch register is required to move an object to or from
     memory, it can be allocated using `gen_reg_rtx' prior to life
     analysis.

     If there are cases which need scratch registers during or after
     reload, you must provide an appropriate secondary_reload target
     hook.

     The macro `can_create_pseudo_p' can be used to determine if it is
     unsafe to create new pseudo registers.  If this variable is
     nonzero, then it is unsafe to call `gen_reg_rtx' to allocate a new
     pseudo.

     The constraints on a `movM' must permit moving any hard register
     to any other hard register provided that `HARD_REGNO_MODE_OK'
     permits mode M in both registers and `REGISTER_MOVE_COST' applied
     to their classes returns a value of 2.

     It is obligatory to support floating point `movM' instructions
     into and out of any registers that can hold fixed point values,
     because unions and structures (which have modes `SImode' or
     `DImode') can be in those registers and they may have floating
     point members.

     There may also be a need to support fixed point `movM'
     instructions in and out of floating point registers.
     Unfortunately, I have forgotten why this was so, and I don't know
     whether it is still true.  If `HARD_REGNO_MODE_OK' rejects fixed
     point values in floating point registers, then the constraints of
     the fixed point `movM' instructions must be designed to avoid ever
     trying to reload into a floating point register.

`reload_inM'
`reload_outM'
     These named patterns have been obsoleted by the target hook
     `secondary_reload'.

     Like `movM', but used when a scratch register is required to move
     between operand 0 and operand 1.  Operand 2 describes the scratch
     register.  See the discussion of the `SECONDARY_RELOAD_CLASS'
     macro in *note Register Classes::.

     There are special restrictions on the form of the `match_operand's
     used in these patterns.  First, only the predicate for the reload
     operand is examined, i.e., `reload_in' examines operand 1, but not
     the predicates for operand 0 or 2.  Second, there may be only one
     alternative in the constraints.  Third, only a single register
     class letter may be used for the constraint; subsequent constraint
     letters are ignored.  As a special exception, an empty constraint
     string matches the `ALL_REGS' register class.  This may relieve
     ports of the burden of defining an `ALL_REGS' constraint letter
     just for these patterns.

`movstrictM'
     Like `movM' except that if operand 0 is a `subreg' with mode M of
     a register whose natural mode is wider, the `movstrictM'
     instruction is guaranteed not to alter any of the register except
     the part which belongs to mode M.

`movmisalignM'
     This variant of a move pattern is designed to load or store a value
     from a memory address that is not naturally aligned for its mode.
     For a store, the memory will be in operand 0; for a load, the
     memory will be in operand 1.  The other operand is guaranteed not
     to be a memory, so that it's easy to tell whether this is a load
     or store.

     This pattern is used by the autovectorizer, and when expanding a
     `MISALIGNED_INDIRECT_REF' expression.

`load_multiple'
     Load several consecutive memory locations into consecutive
     registers.  Operand 0 is the first of the consecutive registers,
     operand 1 is the first memory location, and operand 2 is a
     constant: the number of consecutive registers.

     Define this only if the target machine really has such an
     instruction; do not define this if the most efficient way of
     loading consecutive registers from memory is to do them one at a
     time.

     On some machines, there are restrictions as to which consecutive
     registers can be stored into memory, such as particular starting or
     ending register numbers or only a range of valid counts.  For those
     machines, use a `define_expand' (*note Expander Definitions::) and
     make the pattern fail if the restrictions are not met.

     Write the generated insn as a `parallel' with elements being a
     `set' of one register from the appropriate memory location (you may
     also need `use' or `clobber' elements).  Use a `match_parallel'
     (*note RTL Template::) to recognize the insn.  See `rs6000.md' for
     examples of the use of this insn pattern.

`store_multiple'
     Similar to `load_multiple', but store several consecutive registers
     into consecutive memory locations.  Operand 0 is the first of the
     consecutive memory locations, operand 1 is the first register, and
     operand 2 is a constant: the number of consecutive registers.

`vec_setM'
     Set given field in the vector value.  Operand 0 is the vector to
     modify, operand 1 is new value of field and operand 2 specify the
     field index.

`vec_extractM'
     Extract given field from the vector value.  Operand 1 is the
     vector, operand 2 specify field index and operand 0 place to store
     value into.

`vec_extract_evenM'
     Extract even elements from the input vectors (operand 1 and
     operand 2).  The even elements of operand 2 are concatenated to
     the even elements of operand 1 in their original order. The result
     is stored in operand 0.  The output and input vectors should have
     the same modes.

`vec_extract_oddM'
     Extract odd elements from the input vectors (operand 1 and operand
     2).  The odd elements of operand 2 are concatenated to the odd
     elements of operand 1 in their original order. The result is
     stored in operand 0.  The output and input vectors should have the
     same modes.

`vec_interleave_highM'
     Merge high elements of the two input vectors into the output
     vector. The output and input vectors should have the same modes
     (`N' elements). The high `N/2' elements of the first input vector
     are interleaved with the high `N/2' elements of the second input
     vector.

`vec_interleave_lowM'
     Merge low elements of the two input vectors into the output
     vector. The output and input vectors should have the same modes
     (`N' elements). The low `N/2' elements of the first input vector
     are interleaved with the low `N/2' elements of the second input
     vector.

`vec_initM'
     Initialize the vector to given values.  Operand 0 is the vector to
     initialize and operand 1 is parallel containing values for
     individual fields.

`pushM1'
     Output a push instruction.  Operand 0 is value to push.  Used only
     when `PUSH_ROUNDING' is defined.  For historical reason, this
     pattern may be missing and in such case an `mov' expander is used
     instead, with a `MEM' expression forming the push operation.  The
     `mov' expander method is deprecated.

`addM3'
     Add operand 2 and operand 1, storing the result in operand 0.  All
     operands must have mode M.  This can be used even on two-address
     machines, by means of constraints requiring operands 1 and 0 to be
     the same location.

`ssaddM3', `usaddM3'

`subM3', `sssubM3', `ussubM3'

`mulM3', `ssmulM3', `usmulM3'
`divM3', `ssdivM3'
`udivM3', `usdivM3'
`modM3', `umodM3'
`uminM3', `umaxM3'
`andM3', `iorM3', `xorM3'
     Similar, for other arithmetic operations.

`sminM3', `smaxM3'
     Signed minimum and maximum operations.  When used with floating
     point, if both operands are zeros, or if either operand is `NaN',
     then it is unspecified which of the two operands is returned as
     the result.

`reduc_smin_M', `reduc_smax_M'
     Find the signed minimum/maximum of the elements of a vector. The
     vector is operand 1, and the scalar result is stored in the least
     significant bits of operand 0 (also a vector). The output and
     input vector should have the same modes.

`reduc_umin_M', `reduc_umax_M'
     Find the unsigned minimum/maximum of the elements of a vector. The
     vector is operand 1, and the scalar result is stored in the least
     significant bits of operand 0 (also a vector). The output and
     input vector should have the same modes.

`reduc_splus_M'
     Compute the sum of the signed elements of a vector. The vector is
     operand 1, and the scalar result is stored in the least
     significant bits of operand 0 (also a vector). The output and
     input vector should have the same modes.

`reduc_uplus_M'
     Compute the sum of the unsigned elements of a vector. The vector
     is operand 1, and the scalar result is stored in the least
     significant bits of operand 0 (also a vector). The output and
     input vector should have the same modes.

`sdot_prodM'

`udot_prodM'
     Compute the sum of the products of two signed/unsigned elements.
     Operand 1 and operand 2 are of the same mode. Their product, which
     is of a wider mode, is computed and added to operand 3. Operand 3
     is of a mode equal or wider than the mode of the product. The
     result is placed in operand 0, which is of the same mode as
     operand 3.

`ssum_widenM3'

`usum_widenM3'
     Operands 0 and 2 are of the same mode, which is wider than the
     mode of operand 1. Add operand 1 to operand 2 and place the
     widened result in operand 0. (This is used express accumulation of
     elements into an accumulator of a wider mode.)

`vec_shl_M', `vec_shr_M'
     Whole vector left/right shift in bits.  Operand 1 is a vector to
     be shifted.  Operand 2 is an integer shift amount in bits.
     Operand 0 is where the resulting shifted vector is stored.  The
     output and input vectors should have the same modes.

`vec_pack_trunc_M'
     Narrow (demote) and merge the elements of two vectors. Operands 1
     and 2 are vectors of the same mode having N integral or floating
     point elements of size S.  Operand 0 is the resulting vector in
     which 2*N elements of size N/2 are concatenated after narrowing
     them down using truncation.

`vec_pack_ssat_M', `vec_pack_usat_M'
     Narrow (demote) and merge the elements of two vectors.  Operands 1
     and 2 are vectors of the same mode having N integral elements of
     size S.  Operand 0 is the resulting vector in which the elements
     of the two input vectors are concatenated after narrowing them
     down using signed/unsigned saturating arithmetic.

`vec_pack_sfix_trunc_M', `vec_pack_ufix_trunc_M'
     Narrow, convert to signed/unsigned integral type and merge the
     elements of two vectors.  Operands 1 and 2 are vectors of the same
     mode having N floating point elements of size S.  Operand 0 is the
     resulting vector in which 2*N elements of size N/2 are
     concatenated.

`vec_unpacks_hi_M', `vec_unpacks_lo_M'
     Extract and widen (promote) the high/low part of a vector of signed
     integral or floating point elements.  The input vector (operand 1)
     has N elements of size S.  Widen (promote) the high/low elements
     of the vector using signed or floating point extension and place
     the resulting N/2 values of size 2*S in the output vector (operand
     0).

`vec_unpacku_hi_M', `vec_unpacku_lo_M'
     Extract and widen (promote) the high/low part of a vector of
     unsigned integral elements.  The input vector (operand 1) has N
     elements of size S.  Widen (promote) the high/low elements of the
     vector using zero extension and place the resulting N/2 values of
     size 2*S in the output vector (operand 0).

`vec_unpacks_float_hi_M', `vec_unpacks_float_lo_M'
`vec_unpacku_float_hi_M', `vec_unpacku_float_lo_M'
     Extract, convert to floating point type and widen the high/low
     part of a vector of signed/unsigned integral elements.  The input
     vector (operand 1) has N elements of size S.  Convert the high/low
     elements of the vector using floating point conversion and place
     the resulting N/2 values of size 2*S in the output vector (operand
     0).

`vec_widen_umult_hi_M', `vec_widen_umult_lo_M'
`vec_widen_smult_hi_M', `vec_widen_smult_lo_M'
     Signed/Unsigned widening multiplication.  The two inputs (operands
     1 and 2) are vectors with N signed/unsigned elements of size S.
     Multiply the high/low elements of the two vectors, and put the N/2
     products of size 2*S in the output vector (operand 0).

`mulhisi3'
     Multiply operands 1 and 2, which have mode `HImode', and store a
     `SImode' product in operand 0.

`mulqihi3', `mulsidi3'
     Similar widening-multiplication instructions of other widths.

`umulqihi3', `umulhisi3', `umulsidi3'
     Similar widening-multiplication instructions that do unsigned
     multiplication.

`usmulqihi3', `usmulhisi3', `usmulsidi3'
     Similar widening-multiplication instructions that interpret the
     first operand as unsigned and the second operand as signed, then
     do a signed multiplication.

`smulM3_hi