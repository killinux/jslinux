Function: int mpfr_si_sub (mpfr_t ROP, long int OP1, mpfr_t OP2,
          mpfr_rnd_t RND)
 -- Function: int mpfr_sub_si (mpfr_t ROP, mpfr_t OP1, long int OP2,
          mpfr_rnd_t RND)
 -- Function: int mpfr_d_sub (mpfr_t ROP, double OP1, mpfr_t OP2,
          mpfr_rnd_t RND)
 -- Function: int mpfr_sub_d (mpfr_t ROP, mpfr_t OP1, double OP2,
          mpfr_rnd_t RND)
 -- Function: int mpfr_sub_z (mpfr_t ROP, mpfr_t OP1, mpz_t OP2,
          mpfr_rnd_t RND)
 -- Function: int mpfr_sub_q (mpfr_t ROP, mpfr_t OP1, mpq_t OP2,
          mpfr_rnd_t RND)
     Set ROP to OP1 - OP2 rounded in the direction RND. For types
     having no signed zero, it is considered unsigned (i.e., (+0) - 0 =
     (+0), (-0) - 0 = (-0), 0 - (+0) = (-0) and 0 - (-0) = (+0)).  The
     same restrictions than for `mpfr_add_d' apply to `mpfr_d_sub' and
     `mpfr_sub_d'.

 -- Function: int mpfr_mul (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
          mpfr_rnd_t RND)
 -- Function: int mpfr_mul_ui (mpfr_t ROP, mpfr_t OP1, unsigned long
          int OP2, mpfr_rnd_t RND)
 -- Function: int mpfr_mul_si (mpfr_t ROP, mpfr_t OP1, long int OP2,
          mpfr_rnd_t RND)
 -- Function: int mpfr_mul_d (mpfr_t ROP, mpfr_t OP1, double OP2,
          mpfr_rnd_t RND)
 -- Function: int mpfr_mul_z (mpfr_t ROP, mpfr_t OP1, mpz_t OP2,
          mpfr_rnd_t RND)
 -- Function: int mpfr_mul_q (mpfr_t ROP, mpfr_t OP1, mpq_t OP2,
          mpfr_rnd_t RND)
     Set ROP to OP1 times OP2 rounded in the direction RND.  When a
     result is zero, its sign is the product of the signs of the
     operands (for types having no signed zero, it is considered
     positive).  The same restrictions than for `mpfr_add_d' apply to
     `mpfr_mul_d'.

 -- Function: int mpfr_sqr (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
     Set ROP to the square of OP rounded in the direction RND.

 -- Function: int mpfr_div (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
          mpfr_rnd_t RND)
 -- Function: int mpfr_ui_div (mpfr_t ROP, unsigned long int OP1,
          mpfr_t OP2, mpfr_rnd_t RND)
 -- Function: int mpfr_div_ui (mpfr_t ROP, mpfr_t OP1, unsigned long
          int OP2, mpfr_rnd_t RND)
 -- Function: int mpfr_si_div (mpfr_t ROP, long int OP1, mpfr_t OP2,
          mpfr_rnd_t RND)
 -- Function: int mpfr_div_si (mpfr_t ROP, mpfr_t OP1, long int OP2,
          mpfr_rnd_t RND)
 -- Function: int mpfr_d_div (mpfr_t ROP, double OP1, mpfr_t OP2,
          mpfr_rnd_t RND)
 -- Function: int mpfr_div_d (mpfr_t ROP, mpfr_t OP1, double OP2,
          mpfr_rnd_t RND)
 -- Function: int mpfr_div_z (mpfr_t ROP, mpfr_t OP1, mpz_t OP2,
          mpfr_rnd_t RND)
 -- Function: int mpfr_div_q (mpfr_t ROP, mpfr_t OP1, mpq_t OP2,
          mpfr_rnd_t RND)
     Set ROP to OP1/OP2 rounded in the direction RND.  When a result is
     zero, its sign is the product of the signs of the operands (for
     types having no signed zero, it is considered positive).  The same
     restrictions than for `mpfr_add_d' apply to `mpfr_d_div' and
     `mpfr_div_d'.

 -- Function: int mpfr_sqrt (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_sqrt_ui (mpfr_t ROP, unsigned long int OP,
          mpfr_rnd_t RND)
     Set ROP to the square root of OP rounded in the direction RND (set
     ROP to -0 if OP is -0, to be consistent with the IEEE 754
     standard).  Set ROP to NaN if OP is negative.

 -- Function: int mpfr_rec_sqrt (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
     Set ROP to the reciprocal square root of OP rounded in the
     direction RND. Set ROP to +Inf if OP is ±0, +0 if OP is +Inf, and
     NaN if OP is negative.

 -- Function: int mpfr_cbrt (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_root (mpfr_t ROP, mpfr_t OP, unsigned long int
          K, mpfr_rnd_t RND)
     Set ROP to the cubic root (resp. the Kth root) of OP rounded in
     the direction RND.  For K odd (resp. even) and OP negative
     (including -Inf), set ROP to a negative number (resp. NaN).  The
     Kth root of -0 is defined to be -0, whatever the parity of K.

 -- Function: int mpfr_pow (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
          mpfr_rnd_t RND)
 -- Function: int mpfr_pow_ui (mpfr_t ROP, mpfr_t OP1, unsigned long
          int OP2, mpfr_rnd_t RND)
 -- Function: int mpfr_pow_si (mpfr_t ROP, mpfr_t OP1, long int OP2,
          mpfr_rnd_t RND)
 -- Function: int mpfr_pow_z (mpfr_t ROP, mpfr_t OP1, mpz_t OP2,
          mpfr_rnd_t RND)
 -- Function: int mpfr_ui_pow_ui (mpfr_t ROP, unsigned long int OP1,
          unsigned long int OP2, mpfr_rnd_t RND)
 -- Function: int mpfr_ui_pow (mpfr_t ROP, unsigned long int OP1,
          mpfr_t OP2, mpfr_rnd_t RND)
     Set ROP to OP1 raised to OP2, rounded in the direction RND.
     Special values are handled as described in the ISO C99 and IEEE
     754-2008 standards for the `pow' function:
        * `pow(±0, Y)' returns plus or minus infinity for Y a negative
          odd integer.

        * `pow(±0, Y)' returns plus infinity for Y negative and not an
          odd integer.

        * `pow(±0, Y)' returns plus or minus zero for Y a positive odd
          integer.

        * `pow(±0, Y)' returns plus zero for Y positive and not an odd
          integer.

        * `pow(-1, ±Inf)' returns 1.

        * `pow(+1, Y)' returns 1 for any Y, even a NaN.

        * `pow(X, ±0)' returns 1 for any X, even a NaN.

        * `pow(X, Y)' returns NaN for finite negative X and finite
          non-integer Y.

        * `pow(X, -Inf)' returns plus infinity for 0 < abs(x) < 1, and
          plus zero for abs(x) > 1.

        * `pow(X, +Inf)' returns plus zero for 0 < abs(x) < 1, and plus
          infinity for abs(x) > 1.

        * `pow(-Inf, Y)' returns minus zero for Y a negative odd
          integer.

        * `pow(-Inf, Y)' returns plus zero for Y negative and not an
          odd integer.

        * `pow(-Inf, Y)' returns minus infinity for Y a positive odd
          integer.

        * `pow(-Inf, Y)' returns plus infinity for Y positive and not
          an odd integer.

        * `pow(+Inf, Y)' returns plus zero for Y negative, and plus
          infinity for Y positive.

 -- Function: int mpfr_neg (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_abs (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
     Set ROP to -OP and the absolute value of OP respectively, rounded
     in the direction RND.  Just changes or adjusts the sign if ROP and
     OP are the same variable, otherwise a rounding might occur if the
     precision of ROP is less than that of OP.

 -- Function: int mpfr_dim (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
          mpfr_rnd_t RND)
     Set ROP to the positive difference of OP1 and OP2, i.e., OP1 - OP2
     rounded in the direction RND if OP1 > OP2, +0 if OP1 <= OP2, and
     NaN if OP1 or OP2 is NaN.

 -- Function: int mpfr_mul_2ui (mpfr_t ROP, mpfr_t OP1, unsigned long
          int OP2, mpfr_rnd_t RND)
 -- Function: int mpfr_mul_2si (mpfr_t ROP, mpfr_t OP1, long int OP2,
          mpfr_rnd_t RND)
     Set ROP to OP1 times 2 raised to OP2 rounded in the direction RND.
     Just increases the exponent by OP2 when ROP and OP1 are identical.

 -- Function: int mpfr_div_2ui (mpfr_t ROP, mpfr_t OP1, unsigned long
          int OP2, mpfr_rnd_t RND)
 -- Function: int mpfr_div_2si (mpfr_t ROP, mpfr_t OP1, long int OP2,
          mpfr_rnd_t RND)
     Set ROP to OP1 divided by 2 raised to OP2 rounded in the direction
     RND. Just decreases the exponent by OP2 when ROP and OP1 are
     identical.


File: mpfr.info,  Node: Comparison Functions,  Next: Special Functions,  Prev: Basic Arithmetic Functions,  Up: MPFR Interface

5.6 Comparison Functions
========================

 -- Function: int mpfr_cmp (mpfr_t OP1, mpfr_t OP2)
 -- Function: int mpfr_cmp_ui (mpfr_t OP1, unsigned long int OP2)
 -- Function: int mpfr_cmp_si (mpfr_t OP1, long int OP2)
 -- Function: int mpfr_cmp_d (mpfr_t OP1, double OP2)
 -- Function: int mpfr_cmp_ld (mpfr_t OP1, long double OP2)
 -- Function: int mpfr_cmp_z (mpfr_t OP1, mpz_t OP2)
 -- Function: int mpfr_cmp_q (mpfr_t OP1, mpq_t OP2)
 -- Function: int mpfr_cmp_f (mpfr_t OP1, mpf_t OP2)
     Compare OP1 and OP2.  Return a positive value if OP1 > OP2, zero
     if OP1 = OP2, and a negative value if OP1 < OP2.  Both OP1 and OP2
     are considered to their full own precision, which may differ.  If
     one of the operands is NaN, set the _erange_ flag and return zero.

     Note: These functions may be useful to distinguish the three
     possible cases.  If you need to distinguish two cases only, it is
     recommended to use the predicate functions (e.g., `mpfr_equal_p'
     for the equality) described below; they behave like the IEEE 754
     comparisons, in particular when one or both arguments are NaN. But
     only floating-point numbers can be compared (you may need to do a
     conversion first).

 -- Function: int mpfr_cmp_ui_2exp (mpfr_t OP1, unsigned long int OP2,
          mpfr_exp_t E)
 -- Function: int mpfr_cmp_si_2exp (mpfr_t OP1, long int OP2,
          mpfr_exp_t E)
     Compare OP1 and OP2 multiplied by two to the power E. Similar as
     above.

 -- Function: int mpfr_cmpabs (mpfr_t OP1, mpfr_t OP2)
     Compare |OP1| and |OP2|.  Return a positive value if |OP1| >
     |OP2|, zero if |OP1| = |OP2|, and a negative value if |OP1| <
     |OP2|.  If one of the operands is NaN, set the _erange_ flag and
     return zero.

 -- Function: int mpfr_nan_p (mpfr_t OP)
 -- Function: int mpfr_inf_p (mpfr_t OP)
 -- Function: int mpfr_number_p (mpfr_t OP)
 -- Function: int mpfr_zero_p (mpfr_t OP)
 -- Function: int mpfr_regular_p (mpfr_t OP)
     Return non-zero if OP is respectively NaN, an infinity, an ordinary
     number (i.e., neither NaN nor an infinity), zero, or a regular
     number (i.e., neither NaN, nor an infinity nor zero). Return zero
     otherwise.

 -- Macro: int mpfr_sgn (mpfr_t OP)
     Return a positive value if OP > 0, zero if OP = 0, and a negative
     value if OP < 0.  If the operand is NaN, set the _erange_ flag and
     return zero.  This is equivalent to `mpfr_cmp_ui (op, 0)', but
     more efficient.

 -- Function: int mpfr_greater_p (mpfr_t OP1, mpfr_t OP2)
 -- Function: int mpfr_greaterequal_p (mpfr_t OP1, mpfr_t OP2)
 -- Function: int mpfr_less_p (mpfr_t OP1, mpfr_t OP2)
 -- Function: int mpfr_lessequal_p (mpfr_t OP1, mpfr_t OP2)
 -- Function: int mpfr_equal_p (mpfr_t OP1, mpfr_t OP2)
     Return non-zero if OP1 > OP2,                    OP1 >= OP2,
                 OP1 < OP2,                    OP1 <= OP2,
          OP1 = OP2 respectively, and zero otherwise.  Those functions
     return zero whenever OP1 and/or OP2 is NaN.

 -- Function: int mpfr_lessgreater_p (mpfr_t OP1, mpfr_t OP2)
     Return non-zero if OP1 < OP2 or OP1 > OP2 (i.e., neither OP1, nor
     OP2 is NaN, and OP1 <> OP2), zero otherwise (i.e., OP1 and/or OP2
     is NaN, or OP1 = OP2).

 -- Function: int mpfr_unordered_p (mpfr_t OP1, mpfr_t OP2)
     Return non-zero if OP1 or OP2 is a NaN (i.e., they cannot be
     compared), zero otherwise.


File: mpfr.info,  Node: Special Functions,  Next: Input and Output Functions,  Prev: Comparison Functions,  Up: MPFR Interface

5.7 Special Functions
=====================

All those functions, except explicitly stated (for example
`mpfr_sin_cos'), return a ternary value as defined in Section "Rounding
Modes", i.e., zero for an exact return value, a positive value for a
return value larger than the exact result, and a negative value
otherwise.

   Important note: in some domains, computing special functions (either
with correct or incorrect rounding) is expensive, even for small
precision, for example the trigonometric and Bessel functions for large
argument.

 -- Function: int mpfr_log (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_log2 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_log10 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
     Set ROP to the natural logarithm of OP, log2(OP) or log10(OP),
     respectively, rounded in the direction RND.  Set ROP to -Inf if OP
     is -0 (i.e., the sign of the zero has no influence on the result).

 -- Function: int mpfr_exp (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_exp2 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_exp10 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
     Set ROP to the exponential of OP,  to 2 power of OP or to 10 power
     of OP, respectively, rounded in the direction RND.

 -- Function: int mpfr_cos (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_sin (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_tan (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
     Set ROP to the cosine of OP, sine of OP, tangent of OP, rounded in
     the direction RND.

 -- Function: int mpfr_sin_cos (mpfr_t SOP, mpfr_t COP, mpfr_t OP,
          mpfr_rnd_t RND)
     Set simultaneously SOP to the sine of OP and COP to the cosine of
     OP, rounded in the direction RND with the corresponding precisions
     of SOP and COP, which must be different variables.  Return 0 iff
     both results are exact, more precisely it returns s+4c where s=0
     if SOP is exact, s=1 if SOP is larger than the sine of OP, s=2 if
     SOP is smaller than the sine of OP, and similarly for c and the
     cosine of OP.

 -- Function: int mpfr_sec (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_csc (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_cot (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
     Set ROP to the secant of OP, cosecant of OP, cotangent of OP,
     rounded in the direction RND.

 -- Function: int mpfr_acos (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_asin (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_atan (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
     Set ROP to the arc-cosine, arc-sine or arc-tangent of OP, rounded
     in the direction RND.  Note that since `acos(-1)' returns the
     floating-point number closest to Pi according to the given
     rounding mode, this number might not be in the output range 0 <=
     ROP < \pi of the arc-cosine function; still, the result lies in
     the image of the output range by the rounding function.  The same
     holds for `asin(-1)', `asin(1)', `atan(-Inf)', `atan(+Inf)' or for
     `atan(op)' with large OP and small precision of ROP.

 -- Function: int mpfr_atan2 (mpfr_t ROP, mpfr_t Y, mpfr_t X,
          mpfr_rnd_t RND)
     Set ROP to the arc-tangent2 of Y and X, rounded in the direction
     RND: if `x > 0', `atan2(y, x) = atan (y/x)'; if `x < 0', `atan2(y,
     x) = sign(y)*(Pi - atan (abs(y/x)))', thus a number from -Pi to Pi.
     As for `atan', in case the exact mathematical result is +Pi or -Pi,
     its rounded result might be outside the function output range.

     `atan2(y, 0)' does not raise any floating-point exception.
     Special values are handled as described in the ISO C99 and IEEE
     754-2008 standards for the `atan2' function:
        * `atan2(+0, -0)' returns +Pi.

        * `atan2(-0, -0)' returns -Pi.

        * `atan2(+0, +0)' returns +0.

        * `atan2(-0, +0)' returns -0.

        * `atan2(+0, x)' returns +Pi for x < 0.

        * `atan2(-0, x)' returns -Pi for x < 0.

        * `atan2(+0, x)' returns +0 for x > 0.

        * `atan2(-0, x)' returns -0 for x > 0.

        * `atan2(y, 0)' returns -Pi/2 for y < 0.

        * `atan2(y, 0)' returns +Pi/2 for y > 0.

        * `atan2(+Inf, -Inf)' returns +3*Pi/4.

        * `atan2(-Inf, -Inf)' returns -3*Pi/4.

        * `atan2(+Inf, +Inf)' returns +Pi/4.

        * `atan2(-Inf, +Inf)' returns -Pi/4.

        * `atan2(+Inf, x)' returns +Pi/2 for finite x.

        * `atan2(-Inf, x)' returns -Pi/2 for finite x.

        * `atan2(y, -Inf)' returns +Pi for finite y > 0.

        * `atan2(y, -Inf)' returns -Pi for finite y < 0.

        * `atan2(y, +Inf)' returns +0 for finite y > 0.

        * `atan2(y, +Inf)' returns -0 for finite y < 0.

 -- Function: int mpfr_cosh (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_sinh (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_tanh (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
     Set ROP to the hyperbolic cosine, sine or tangent of OP, rounded
     in the direction RND.

 -- Function: int mpfr_sinh_cosh (mpfr_t SOP, mpfr_t COP, mpfr_t OP,
          mpfr_rnd_t RND)
     Set simultaneously SOP to the hyperbolic sine of OP and COP to the
     hyperbolic cosine of OP, rounded in the direction RND with the
     corresponding precision of SOP and COP, which must be different
     variables.  Return 0 iff both results are exact (see
     `mpfr_sin_cos' for a more detailed description of the return
     value).

 -- Function: int mpfr_sech (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_csch (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_coth (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
     Set ROP to the hyperbolic secant of OP, cosecant of OP, cotangent
     of OP, rounded in the direction RND.

 -- Function: int mpfr_acosh (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_asinh (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_atanh (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
     Set ROP to the inverse hyperbolic cosine, sine or tangent of OP,
     rounded in the direction RND.

 -- Function: int mpfr_fac_ui (mpfr_t ROP, unsigned long int OP,
          mpfr_rnd_t RND)
     Set ROP to the factorial of OP, rounded in the direction RND.

 -- Function: int mpfr_log1p (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
     Set ROP to the logarithm of one plus OP, rounded in the direction
     RND.

 -- Function: int mpfr_expm1 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
     Set ROP to the exponential of OP followed by a subtraction by one,
     rounded in the direction RND.

 -- Function: int mpfr_eint (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
     Set ROP to the exponential integral of OP, rounded in the
     direction RND.  For positive OP, the exponential integral is the
     sum of Euler's constant, of the logarithm of OP, and of the sum
     for k from 1 to infinity of OP to the power k, divided by k and
     factorial(k).  For negative OP, ROP is set to NaN.

 -- Function: int mpfr_li2 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
     Set ROP to real part of the dilogarithm of OP, rounded in the
     direction RND. MPFR defines the dilogarithm function as the
     integral of -log(1-t)/t from 0 to OP.

 -- Function: int mpfr_gamma (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
     Set ROP to the value of the Gamma function on OP, rounded in the
     direction RND. When OP is a negative integer, ROP is set to NaN.

 -- Function: int mpfr_lngamma (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
     Set ROP to the value of the logarithm of the Gamma function on OP,
     rounded in the direction RND.  When -2K-1 <= OP <= -2K, K being a
     non-negative integer, ROP is set to NaN.  See also `mpfr_lgamma'.

 -- Function: int mpfr_lgamma (mpfr_t ROP, int *SIGNP, mpfr_t OP,
          mpfr_rnd_t RND)
     Set ROP to the value of the logarithm of the absolute value of the
     Gamma function on OP, rounded in the direction RND. The sign (1 or
     -1) of Gamma(OP) is returned in the object pointed to by SIGNP.
     When OP is an infinity or a non-positive integer, set ROP to +Inf.
     When OP is NaN, -Inf or a negative integer, *SIGNP is undefined,
     and when OP is ±0, *SIGNP is the sign of the zero.

 -- Function: int mpfr_digamma (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
     Set ROP to the value of the Digamma (sometimes also called Psi)
     function on OP, rounded in the direction RND.  When OP is a
     negative integer, set ROP to NaN.

 -- Function: int mpfr_zeta (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_zeta_ui (mpfr_t ROP, unsigned long OP,
          mpfr_rnd_t RND)
     Set ROP to the value of the Riemann Zeta function on OP, rounded
     in the direction RND.

 -- Function: int mpfr_erf (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_erfc (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
     Set ROP to the value of the error function on OP (resp. the
     complementary error function on OP) rounded in the direction RND.

 -- Function: int mpfr_j0 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_j1 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_jn (mpfr_t ROP, long N, mpfr_t OP, mpfr_rnd_t
          RND)
     Set ROP to the value of the first kind Bessel function of order 0,
     (resp. 1 and N) on OP, rounded in the direction RND. When OP is
     NaN, ROP is always set to NaN. When OP is plus or minus Infinity,
     ROP is set to +0. When OP is zero, and N is not zero, ROP is set
     to +0 or -0 depending on the parity and sign of N, and the sign of
     OP.

 -- Function: int mpfr_y0 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_y1 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_yn (mpfr_t ROP, long N, mpfr_t OP, mpfr_rnd_t
          RND)
     Set ROP to the value of the second kind Bessel function of order 0
     (resp. 1 and N) on OP, rounded in the direction RND. When OP is
     NaN or negative, ROP is always set to NaN. When OP is +Inf, ROP is
     set to +0. When OP is zero, ROP is set to +Inf or -Inf depending
     on the parity and sign of N.

 -- Function: int mpfr_fma (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2, mpfr_t
          OP3, mpfr_rnd_t RND)
 -- Function: int mpfr_fms (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2, mpfr_t
          OP3, mpfr_rnd_t RND)
     Set ROP to (OP1 times OP2) + OP3 (resp. (OP1 times OP2) - OP3)
     rounded in the direction RND.

 -- Function: int mpfr_agm (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
          mpfr_rnd_t RND)
     Set ROP to the arithmetic-geometric mean of OP1 and OP2, rounded
     in the direction RND.  The arithmetic-geometric mean is the common
     limit of the sequences U_N and V_N, where U_0=OP1, V_0=OP2,
     U_(N+1) is the arithmetic mean of U_N and V_N, and V_(N+1) is the
     geometric mean of U_N and V_N.  If any operand is negative, set
     ROP to NaN.

 -- Function: int mpfr_hypot (mpfr_t ROP, mpfr_t X, mpfr_t Y,
          mpfr_rnd_t RND)
     Set ROP to the Euclidean norm of X and Y, i.e., the square root of
     the sum of the squares of X and Y, rounded in the direction RND.
     Special values are handled as described in Section F.9.4.3 of the
     ISO C99 and IEEE 754-2008 standards: If X or Y is an infinity,
     then +Inf is returned in ROP, even if the other number is NaN.

 -- Function: int mpfr_ai (mpfr_t ROP, mpfr_t X, mpfr_rnd_t RND)
     Set ROP to the value of the Airy function Ai  on X, rounded in the
     direction RND.  When X is NaN, ROP is always set to NaN. When X is
     +Inf or -Inf, ROP is +0.  The current implementation is not
     intended to be used with large arguments.  It works with abs(X)
     typically smaller than 500. For larger arguments, other methods
     should be used and will be implemented in a future version.

 -- Function: int mpfr_const_log2 (mpfr_t ROP, mpfr_rnd_t RND)
 -- Function: int mpfr_const_pi (mpfr_t ROP, mpfr_rnd_t RND)
 -- Function: int mpfr_const_euler (mpfr_t ROP, mpfr_rnd_t RND)
 -- Function: int mpfr_const_catalan (mpfr_t ROP, mpfr_rnd_t RND)
     Set ROP to the logarithm of 2, the value of Pi, of Euler's
     constant 0.577..., of Catalan's constant 0.915..., respectively,
     rounded in the direction RND. These functions cache the computed
     values to avoid other calculations if a lower or equal precision
     is requested. To free these caches, use `mpfr_free_cache'.

 -- Function: void mpfr_free_cache (void)
     Free various caches used by MPFR internally, in particular the
     caches used by the functions computing constants
     (`mpfr_const_log2', `mpfr_const_pi', `mpfr_const_euler' and
     `mpfr_const_catalan').  You should call this function before
     terminating a thread, even if you did not call these functions
     directly (they could have been called internally).

 -- Function: int mpfr_sum (mpfr_t ROP, mpfr_ptr const TAB[], unsigned
          long int N, mpfr_rnd_t RND)
     Set ROP to the sum of all elements of TAB, whose size is N,
     rounded in the direction RND. Warning: for efficiency reasons, TAB
     is an array of pointers to `mpfr_t', not an array of `mpfr_t'.  If
     the returned `int' value is zero, ROP is guaranteed to be the
     exact sum; otherwise ROP might be smaller than, equal to, or
     larger than the exact sum (in accordance to the rounding mode).
     However, `mpfr_sum' does guarantee the result is correctly rounded.


File: mpfr.info,  Node: Input and Output Functions,  Next: Formatted Output Functions,  Prev: Special Functions,  Up: MPFR Interface

5.8 Input and Output Functions
==============================

This section describes functions that perform input from an input/output
stream, and functions that output to an input/output stream.  Passing a
null pointer for a `stream' to any of these functions will make them
read from `stdin' and write to `stdout', respectively.

   When using any of these functions, you must include the `<stdio.h>'
standard header before `mpfr.h', to allow `mpfr.h' to define prototypes
for these functions.

 -- Function: size_t mpfr_out_str (FILE *STREAM, int BASE, size_t N,
          mpfr_t OP, mpfr_rnd_t RND)
     Output OP on stream STREAM, as a string of digits in base BASE,
     rounded in the direction RND.  The base may vary from 2 to 62.
     Print N significant digits exactly, or if N is 0, enough digits so
     that OP can be read back exactly (see `mpfr_get_str').

     In addition to the significant digits, a decimal point (defined by
     the current locale) at the right of the first digit and a trailing
     exponent in base 10, in the form `eNNN', are printed. If BASE is
     greater than 10, `@' will be used instead of `e' as exponent
     delimiter.

     Return the number of characters written, or if an error occurred,
     return 0.

 -- Function: size_t mpfr_inp_str (mpfr_t ROP, FILE *STREAM, int BASE,
          mpfr_rnd_t RND)
     Input a string in base BASE from stream STREAM, rounded in the
     direction RND, and put the read float in ROP.

     This function reads a word (defined as a sequence of characters
     between whitespace) and parses it using `mpfr_set_str'.  See the
     documentation of `mpfr_strtofr' for a detailed description of the
     valid string formats.

     Return the number of bytes read, or if an error occurred, return 0.


File: mpfr.info,  Node: Formatted Output Functions,  Next: Integer Related Functions,  Prev: Input and Output Functions,  Up: MPFR Interface

5.9 Formatted Output Functions
==============================

5.9.1 Requirements
------------------

The class of `mpfr_printf' functions provides formatted output in a
similar manner as the standard C `printf'. These functions are defined
only if your system supports ISO C variadic functions and the
corresponding argument access macros.

   When using any of these functions, you must include the `<stdio.h>'
standard header before `mpfr.h', to allow `mpfr.h' to define prototypes
for these functions.

5.9.2 Format String
-------------------

The format specification accepted by `mpfr_printf' is an extension of
the `printf' one. The conversion specification is of the form:
     % [flags] [width] [.[precision]] [type] [rounding] conv
   `flags', `width', and `precision' have the same meaning as for the
standard `printf' (in particular, notice that the `precision' is
related to the number of digits displayed in the base chosen by `conv'
and not related to the internal precision of the `mpfr_t' variable).
`mpfr_printf' accepts the same `type' specifiers as GMP (except the
non-standard and deprecated `q', use `ll' instead), namely the length
modifiers defined in the C standard:

     `h'       `short'
     `hh'      `char'
     `j'       `intmax_t' or `uintmax_t'
     `l'       `long' or `wchar_t'
     `ll'      `long long'
     `L'       `long double'
     `t'       `ptrdiff_t'
     `z'       `size_t'

   and the `type' specifiers defined in GMP plus `R' and `P' specific
to MPFR (the second column in the table below shows the type of the
argument read in the argument list and the kind of `conv' specifier to
use after the `type' specifier):

     `F'       `mpf_t', float conversions
     `Q'       `mpq_t', integer conversions
     `M'       `mp_limb_t', integer conversions
     `N'       `mp_limb_t' array, integer conversions
     `Z'       `mpz_t', integer conversions
     `P'       `mpfr_prec_t', integer conversions
     `R'       `mpfr_t', float conversions

   The `type' specifiers have the same restrictions as those mentioned
in the GMP documentation: *note Formatted Output Strings:
(gmp.info)Formatted Output Strings.  In particular, the `type'
specifiers (except `R' and `P') are supported only if they are
supported by `gmp_printf' in your GMP build; this implies that the
standard specifiers, such as `t', must _also_ be supported by your C
library if you want to use them.

   The `rounding' field is specific to `mpfr_t' arguments and should
not be used with other types.

   With conversion specification not involving `P' and `R' types,
`mpfr_printf' behaves exactly as `gmp_printf'.

   The `P' type specifies that a following `o', `u', `x', or `X'
conversion specifier applies to a `mpfr_prec_t' argument.  It is needed
because the `mpfr_prec_t' type does not necessarily correspond to an
`unsigned int' or any fixed standard type.  The `precision' field
specifies the minimum number of digits to appear. The default
`precision' is 1.  For example:
     mpfr_t x;
     mpfr_prec_t p;
     mpfr_init (x);
     ...
     p = mpfr_get_prec (x);
     mpfr_printf ("variable x with %Pu bits", p);

   The `R' type specifies that a following `a', `A', `b', `e', `E',
`f', `F', `g', `G', or `n' conversion specifier applies to a `mpfr_t'
argument.  The `R' type can be followed by a `rounding' specifier
denoted by one of the following characters:

     `U'       round toward plus infinity
     `D'       round toward minus infinity
     `Y'       round away from zero
     `Z'       round toward zero
     `N'       round to nearest
     `*'       rounding mode indicated by the
               `mpfr_rnd_t' argument just before the
               corresponding `mpfr_t' variable.

   The default rounding mode is rounding to nearest.  The following
three examples are equivalent:
     mpfr_t x;
     mpfr_init (x);
     ...
     mpfr_printf ("%.128Rf", x);
     mpfr_printf ("%.128RNf", x);
     mpfr_printf ("%.128R*f", MPFR_RNDN, x);

   Note that the rounding away from zero mode is specified with `Y'
because ISO C reserves the `A' specifier for hexadecimal output (see
below).

   The output `conv' specifiers allowed with `mpfr_t' parameter are:

     `a' `A'   hex float, C99 style
     `b'       binary output
     `e' `E'   scientific format float
     `f' `F'   fixed point float
     `g' `G'   fixed or scientific float

   The conversion specifier `b' which displays the argument in binary is
specific to `mpfr_t' arguments and should not be used with other types.
Other conversion specifiers have the same meaning as for a `double'
argument.

   In case of non-decimal output, only the significand is written in the
specified base, the exponent is always displayed in decimal.  Special
values are always displayed as `nan', `-inf', and `inf' for `a', `b',
`e', `f', and `g' specifiers and `NAN', `-INF', and `INF' for `A', `E',
`F', and `G' specifiers.

   If the `precision' field is not empty, the `mpfr_t' number is
rounded to the given precision in the direction specified by the
rounding mode.  If the precision is zero with rounding to nearest mode
and one of the following `conv' specifiers: `a', `A', `b', `e', `E',
tie case is rounded to even when it lies between two consecutive values
at the wanted precision which have the same exponent, otherwise, it is
rounded away from zero.  For instance, 85 is displayed as "8e+1" and 95
is displayed as "1e+2" with the format specification `"%.0RNe"'.  This
also applies when the `g' (resp. `G') conversion specifier uses the `e'
(resp. `E') style.  If the precision is set to a value greater than the
maximum value for an `int', it will be silently reduced down to
`INT_MAX'.

   If the `precision' field is empty (as in `%Re' or `%.RE') with
`conv' specifier `e' and `E', the number is displayed with enough
digits so that it can be read back exactly, assuming that the input and
output variables have the same precision and that the input and output
rounding modes are both rounding to nearest (as for `mpfr_get_str').
The default precision for an empty `precision' field with `conv'
specifiers `f', `F', `g', and `G' is 6.

5.9.3 Functions
---------------

For all the following functions, if the number of characters which
ought to be written appears to exceed the maximum limit for an `int',
nothing is written in the stream (resp. to `stdout', to BUF, to STR),
the function returns -1, sets the _erange_ flag, and (in POSIX system
only) `errno' is set to `EOVERFLOW'.

 -- Function: int mpfr_fprintf (FILE *STREAM, const char *TEMPLATE, ...)
 -- Function: int mpfr_vfprintf (FILE *STREAM, const char *TEMPLATE,
          va_list AP)
     Print to the stream STREAM the optional arguments under the
     control of the template string TEMPLATE.  Return the number of
     characters written or a negative value if an error occurred.

 -- Function: int mpfr_printf (const char *TEMPLATE, ...)
 -- Function: int mpfr_vprintf (const char *TEMPLATE, va_list AP)
     Print to `stdout' the optional arguments under the control of the
     template string TEMPLATE.  Return the number of characters written
     or a negative value if an error occurred.

 -- Function: int mpfr_sprintf (char *BUF, const char *TEMPLATE, ...)
 -- Function: int mpfr_vsprintf (char *BUF, const char *TEMPLATE,
          va_list AP)
     Form a null-terminated string corresponding to the optional
     arguments under the control of the template string TEMPLATE, and
     print it in BUF. No overlap is permitted between BUF and the other
     arguments.  Return the number of characters written in the array
     BUF _not counting_ the terminating null character or a negative
     value if an error occurred.

 -- Function: int mpfr_snprintf (char *BUF, size_t N, const char
          *TEMPLATE, ...)
 -- Function: int mpfr_vsnprintf (char *BUF, size_t N, const char
          *TEMPLATE, va_list AP)
     Form a null-terminated string corresponding to the optional
     arguments under the control of the template string TEMPLATE, and
     print it in BUF. If N is zero, nothing is written and BUF may be a
     null pointer, otherwise, the N-1 first characters are written in
     BUF and the N-th is a null character.  Return the number of
     characters that would have been written had N be sufficiently
     large, _not counting_ the terminating null character, or a
     negative value if an error occurred.

 -- Function: int mpfr_asprintf (char **STR, const char *TEMPLATE, ...)
 -- Function: int mpfr_vasprintf (char **STR, const char *TEMPLATE,
          va_list AP)
     Write their output as a null terminated string in a block of
     memory allocated using the current allocation function. A pointer
     to the block is stored in STR. The block of memory must be freed
     using `mpfr_free_str'.  The return value is the number of
     characters written in the string, excluding the null-terminator,
     or a negative value if an error occurred.


File: mpfr.info,  Node: Integer Related Functions,  Next: Rounding Related Functions,  Prev: Formatted Output Functions,  Up: MPFR Interface

5.10 Integer and Remainder Related Functions
============================================

 -- Function: int mpfr_rint (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_ceil (mpfr_t ROP, mpfr_t OP)
 -- Function: int mpfr_floor (mpfr_t ROP, mpfr_t OP)
 -- Function: int mpfr_round (mpfr_t ROP, mpfr_t OP)
 -- Function: int mpfr_trunc (mpfr_t ROP, mpfr_t OP)
     Set ROP to OP rounded to an integer.  `mpfr_rint' rounds to the
     nearest representable integer in the given direction RND,
     `mpfr_ceil' rounds to the next higher or equal representable
     integer, `mpfr_floor' to the next lower or equal representable
     integer, `mpfr_round' to the nearest representable integer,
     rounding halfway cases away from zero (as in the roundTiesToAway
     mode of IEEE 754-2008), and `mpfr_trunc' to the next representable
     integer toward zero.

     The returned value is zero when the result is exact, positive when
     it is greater than the original value of OP, and negative when it
     is smaller.  More precisely, the returned value is 0 when OP is an
     integer representable in ROP, 1 or -1 when OP is an integer that
     is not representable in ROP, 2 or -2 when OP is not an integer.

     Note that `mpfr_round' is different from `mpfr_rint' called with
     the rounding to nearest mode (where halfway cases are rounded to
     an even integer or significand). Note also that no double rounding
     is performed; for instance, 10.5 (1010.1 in binary) is rounded by
     `mpfr_rint' with rounding to nearest to 12 (1100 in binary) in
     2-bit precision, because the two enclosing numbers representable
     on two bits are 8 and 12, and the closest is 12.  (If one first
     rounded to an integer, one would round 10.5 to 10 with even
     rounding, and then 10 would be rounded to 8 again with even
     rounding.)

 -- Function: int mpfr_rint_ceil (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_rint_floor (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t
          RND)
 -- Function: int mpfr_rint_round (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t
          RND)
 -- Function: int mpfr_rint_trunc (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t
          RND)
     Set ROP to OP rounded to an integer.  `mpfr_rint_ceil' rounds to
     the next higher or equal integer, `mpfr_rint_floor' to the next
     lower or equal integer, `mpfr_rint_round' to the nearest integer,
     rounding halfway cases away from zero, and `mpfr_rint_trunc' to
     the next integer toward zero.  If the result is not representable,
     it is rounded in the direction RND.  The returned value is the
     ternary value associated with the considered round-to-integer
     function (regarded in the same way as any other mathematical
     function).  Contrary to `mpfr_rint', those functions do perform a
     double rounding: first OP is rounded to the nearest integer in the
     direction given by the function name, then this nearest integer
     (if not representable) is rounded in the given direction RND.  For
     example, `mpfr_rint_round' with rounding to nearest and a precision
     of two bits rounds 6.5 to 7 (halfway cases away from zero), then 7
     is rounded to 8 by the round-even rule, despite the fact that 6 is
     also representable on two bits, and is closer to 6.5 than 8.

 -- Function: int mpfr_frac (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
     Set ROP to the fractional part of OP, having the same sign as OP,
     rounded in the direction RND (unlike in `mpfr_rint', RND affects
     only how the exact fractional part is rounded, not how the
     fractional part is generated).

 -- Function: int mpfr_modf (mpfr_t IOP, mpfr_t FOP, mpfr_t OP,
          mpfr_rnd_t RND)
     Set simultaneously IOP to the integral part of OP and FOP to the
     fractional part of OP, rounded in the direction RND with the
     corresponding precision of IOP and FOP (equivalent to
     `mpfr_trunc(IOP, OP, RND)' and `mpfr_frac(FOP, OP, RND)'). The
     variables IOP and FOP must be different. Return 0 iff both results
     are exact (see `mpfr_sin_cos' for a more detailed description of
     the return value).

 -- Function: int mpfr_fmod (mpfr_t R, mpfr_t X, mpfr_t Y, mpfr_rnd_t
          RND)
 -- Function: int mpfr_remainder (mpfr_t R, mpfr_t X, mpfr_t Y,
          mpfr_rnd_t RND)
 -- Function: int mpfr_remquo (mpfr_t R, long* Q, mpfr_t X, mpfr_t Y,
          mpfr_rnd_t RND)
     Set R to the value of X - NY, rounded according to the direction
     RND, where N is the integer quotient of X divided by Y, defined as
     follows: N is rounded toward zero for `mpfr_fmod', and to the
     nearest integer (ties rounded to even) for `mpfr_remainder' and
     `mpfr_remquo'.

     Special values are handled as described in Section F.9.7.1 of the
     ISO C99 standard: If X is infinite or Y is zero, R is NaN.  If Y
     is infinite and X is finite, R is X rounded to the precision of R.
     If R is zero, it has the sign of X.  The return value is the
     ternary value corresponding to R.

     Additionally, `mpfr_remquo' stores the low significant bits from
     the quotient N in *Q (more precisely the number of bits in a
     `long' minus one), with the sign of X divided by Y (except if
     those low bits are all zero, in which case zero is returned).
     Note that X may be so large in magnitude relative to Y that an
     exact representation of the quotient is not practical.  The
     `mpfr_remainder' and `mpfr_remquo' functions are useful for
     additive argument reduction.

 -- Function: int mpfr_integer_p (mpfr_t OP)
     Return non-zero iff OP is an integer.


File: mpfr.info,  Node: Rounding Related Functions,  Next: Miscellaneous Functions,  Prev: Integer Related Functions,  Up: MPFR Interface

5.11 Rounding Related Functions
===============================

 -- Function: void mpfr_set_default_rounding_mode (mpfr_rnd_t RND)
     Set the default rounding mode to RND.  The default rounding mode
     is to nearest initially.

 -- Function: mpfr_rnd_t mpfr_get_default_rounding_mode (void)
     Get the default rounding mode.

 -- Function: int mpfr_prec_round (mpfr_t X, mpfr_prec_t PREC,
          mpfr_rnd_t RND)
     Round X according to RND with precision PREC, which must be an
     integer between `MPFR_PREC_MIN' and `MPFR_PREC_MAX' (otherwise the
     behavior is undefined).  If PREC is greater or equal to the
     precision of X, then new space is allocated for the significand,
     and it is filled with zeros.  Otherwise, the significand is
     rounded to precision PREC with the given direction. In both cases,
     the precision of X is changed to PREC.

     Here is an example of how to use `mpfr_prec_round' to implement
     Newton's algorithm to compute the inverse of A, assuming X is
     already an approximation to N bits:
            mpfr_set_prec (t, 2 * n);
            mpfr_set (t, a, MPFR_RNDN);         /* round a to 2n bits */
            mpfr_mul (t, t, x, MPFR_RNDN);      /* t is correct to 2n bits */
            mpfr_ui_sub (t, 1, t, MPFR_RNDN);   /* high n bits cancel with 1 */
            mpfr_prec_round (t, n, MPFR_RNDN);  /* t is correct to n bits */
            mpfr_mul (t, t, x, MPFR_RNDN);      /* t is correct to n bits */
            mpfr_prec_round (x, 2 * n, MPFR_RNDN); /* exact */
            mpfr_add (x, x, t, MPFR_RNDN);      /* x is correct to 2n bits */

 -- Function: int mpfr_can_round (mpfr_t B, mpfr_exp_t ERR, mpfr_rnd_t
          RND1, mpfr_rnd_t RND2, mpfr_prec_t PREC)
     Assuming B is an approximation of an unknown number X in the
     direction RND1 with error at most two to the power E(b)-ERR where
     E(b) is the exponent of B, return a non-zero value if one is able
     to round correctly X to precision PREC with the direction RND2,
     and 0 otherwise (including for NaN and Inf).  This function *does
     not modify* its arguments.

     If RND1 is `MPFR_RNDN', then the sign of the error is unknown, but
     its absolute value is the same, so that the possible range is
     twice as large as with a directed rounding for RND1.

     Note: if one wants to also determine the correct ternary value
     when rounding B to precision PREC with rounding mode RND, a useful
     trick is the following: if (mpfr_can_round (b, err, MPFR_RNDN, MPFR_RNDZ, prec + (rnd == MPFR_RNDN)))
        ...
      Indeed, if RND is `MPFR_RNDN', this will check if one can round
     to PREC+1 bits with a directed rounding: if so, one can surely
     round to nearest to PREC bits, and in addition one can determine
     the correct ternary value, which would not be the case when B is
     near from a value exactly representable on PREC bits.

 -- Function: mpfr_prec_t mpfr_min_prec (mpfr_t X)
     Return the minimal number of bits required to store the
     significand of X, and 0 for special values, including 0. (Warning:
     the returned value can be less than `MPFR_PREC_MIN'.)

     The function name is subject to change.

 -- Function: const char * mpfr_print_rnd_mode (mpfr_rnd_t RND)
     Return a string ("MPFR_RNDD", "MPFR_RNDU", "MPFR_RNDN",
     "MPFR_RNDZ", "MPFR_RNDA") corresponding to the rounding mode RND,
     or a null pointer if RND is an invalid rounding mode.


File: mpfr.info,  Node: Miscellaneous Functions,  Next: Exception Related Functions,  Prev: Rounding Related Functions,  Up: MPFR Interface

5.12 Miscellaneous Functions
============================

 -- Function: void mpfr_nexttoward (mpfr_t X, mpfr_t Y)
     If X or Y is NaN, set X to NaN. If X and Y are equal, X is
     unchanged. Otherwise, if X is different from Y, replace X by the
     next floating-point number (with the precision of X and the
     current exponent range) in the direction of Y (the infinite values
     are seen as the smallest and largest floating-point numbers). If
     the result is zero, it keeps the same sign. No underflow or
     overflow is generated.

 -- Function: void mpfr_nextabove (mpfr_t X)
 -- Function: void mpfr_nextbelow (mpfr_t X)
     Equivalent to `mpfr_nexttoward' where Y is plus infinity (resp.
     minus infinity).

 -- Function: int mpfr_min (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
          mpfr_rnd_t RND)
 -- Function: int mpfr_max (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
          mpfr_rnd_t RND)
     Set ROP to the minimum (resp. maximum) of OP1 and OP2. If OP1 and
     OP2 are both NaN, then ROP is set to NaN. If OP1 or OP2 is NaN,
     then ROP is set to the numeric value. If OP1 and OP2 are zeros of
     different signs, then ROP is set to -0 (resp. +0).

 -- Function: int mpfr_urandomb (mpfr_t ROP, gmp_randstate_t STATE)
     Generate a uniformly distributed random float in the interval 0 <=
     ROP < 1. More precisely, the number can be seen as a float with a
     random non-normalized significand and exponent 0, which is then
     normalized (thus if E denotes the exponent after normalization,
     then the least -E significant bits of the significand are always
     0).

     Return 0, unless the exponent is not in the current exponent
     range, in which case ROP is set to NaN and a non-zero value is
     returned (this should never happen in practice, except in very
     specific cases). The second argument is a `gmp_randstate_t'
     structure which should be created using the GMP `gmp_randinit'
     function (see the GMP manual).

 -- Function: int mpfr_urandom (mpfr_t ROP, gmp_randstate_t STATE,
          mpfr_rnd_t RND)
     Generate a uniformly distributed random float.  The floating-point
     number ROP can be seen as if a random real number is generated
     according to the continuous uniform distribution on the interval
     [0, 1] and then rounded in the direction RND.

     The second argument is a `gmp_randstate_t' structure which should
     be created using the GMP `gmp_randinit' function (see the GMP
     manual).

 -- Function: mpfr_exp_t mpfr_get_exp (mpfr_t X)
     Return the exponent of X, assuming that X is a non-zero ordinary
     number and the significand is considered in [1/2,1). The behavior
     for NaN, infinity or zero is undefined.

 -- Function: int mpfr_set_exp (mpfr_t X, mpfr_exp_t E)
     Set the exponent of X if E is in the current exponent range, and
     return 0 (even if X is not a non-zero ordinary number); otherwise,
     return a non-zero value.  The significand is assumed to be in
     [1/2,1).

 -- Function: int mpfr_signbit (mpfr_t OP)
     Return a non-zero value iff OP has its sign bit set (i.e., if it is
     negative, -0, or a NaN whose representation has its sign bit set).

 -- Function: int mpfr_setsign (mpfr_t ROP, mpfr_t OP, int S,
          mpfr_rnd_t RND)
     Set the value of ROP from OP, rounded toward the given direction
     RND, then set (resp. clear) its sign bit if S is non-zero (resp.
     zero), even when OP is a NaN.

 -- Function: int mpfr_copysign (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
          mpfr_rnd_t RND)
     Set the value of ROP from OP1, rounded toward the given direction
     RND, then set its sign bit to that of OP2 (even when OP1 or OP2 is
     a NaN). This function is equivalent to `mpfr_setsign (ROP, OP1,
     mpfr_signbit (OP2), RND)'.

 -- Function: const char * mpfr_get_version (void)
     Return the MPFR version, as a null-terminated string.

 -- Macro: MPFR_VERSION
 -- Macro: MPFR_VERSION_MAJOR
 -- Macro: MPFR_VERSION_MINOR
 -- Macro: MPFR_VERSION_PATCHLEVEL
 -- Macro: MPFR_VERSION_STRING
     `MPFR_VERSION' is the version of MPFR as a preprocessing constant.
     `MPFR_VERSION_MAJOR', `MPFR_VERSION_MINOR' and
     `MPFR_VERSION_PATCHLEVEL' are respectively the major, minor and
     patch level of MPFR version, as preprocessing constants.
     `MPFR_VERSION_STRING' is the version (with an optional suffix, used
     in development and pre-release versions) as a string constant,
     which can be compared to the result of `mpfr_get_version' to check
     at run time the header file and library used match:
          if (strcmp (mpfr_get_version (), MPFR_VERSION_STRING))
            fprintf (stderr, "Warning: header and library do not match\n");
     Note: Obtaining different strings is not necessarily an error, as
     in general, a program compiled with some old MPFR version can be
     dynamically linked with a newer MPFR library version (if allowed
     by the library versioning system).

 -- Macro: long MPFR_VERSION_NUM (MAJOR, MINOR, PATCHLEVEL)
     Create an integer in the same format as used by `MPFR_VERSION'
     from the given MAJOR, MINOR and PATCHLEVEL.  Here is an example of
     how to check the MPFR version at compile time:
          #if (!defined(MPFR_VERSION) || (MPFR_VERSION<MPFR_VERSION_NUM(3,0,0)))
          # error "Wrong MPFR version."
          #endif

 -- Function: const char * mpfr_get_patches (void)
     Return a null-terminated string containing the ids of the patches
     applied to the MPFR library (contents of the `PATCHES' file),
     separated by spaces.  Note: If the program has been compiled with
     an older MPFR version and is dynamically linked with a new MPFR
     library version, the identifiers of the patches applied to the old
     (compile-time) MPFR version are not available (however this
     information should not have much interest in general).

 -- Function: int mpfr_buildopt_tls_p (void)
     Return a non-zero value if MPFR was compiled as thread safe using
     compiler-level Thread Local Storage (that is MPFR was built with
     the `--enable-thread-safe' configure option, see `INSTALL' file),
     return zero otherwise.

 -- Function: int mpfr_buildopt_decimal_p (void)
     Return a non-zero value if MPFR was compiled with decimal float
     support (that is MPFR was built with the `--enable-decimal-float'
     configure option), return zero otherwise.


File: mpfr.info,  Node: Exception Related Functions,  Next: Compatibility with MPF,  Prev: Miscellaneous Functions,  Up: MPFR Interface

5.13 Exception Related Functions
================================

 -- Function: mpfr_exp_t mpfr_get_emin (void)
 -- Function: mpfr_exp_t mpfr_get_emax (void)
     Return the (current) smallest and largest exponents allowed for a
     floating-point variable. The smallest positive value of a
     floating-point variable is one half times 2 raised to the smallest
     exponent and the largest value has the form (1 - epsilon) times 2
     raised to the largest exponent, where epsilon depends on the
     precision of the considered variable.

 -- Function: int mpfr_set_emin (mpfr_exp_t EXP)
 -- Function: int mpfr_set_emax (mpfr_exp_t EXP)
     Set the smallest and largest exponents allowed for a
     floating-point variable.  Return a non-zero value when EXP is not
     in the range accepted by the implementation (in that case the
     smallest or largest exponent is not changed), and zero otherwise.
     If the user changes the exponent range, it is her/his
     responsibility to check that all current floating-point variables
     are in the new allowed range (for example using
     `mpfr_check_range'), otherwise the subsequent behavior will be
     undefined, in the sense of the ISO C standard.

 -- Function: mpfr_exp_t mpfr_get_emin_min (void)
 -- Function: mpfr_exp_t mpfr_get_emin_max (void)
 -- Function: mpfr_exp_t mpfr_get_emax_min (void)
 -- Function: mpfr_exp_t mpfr_get_emax_max (void)
     Return the minimum and maximum of the exponents allowed for
     `mpfr_set_emin' and `mpfr_set_emax' respectively.  These values
     are implementation dependent, thus a program using
     `mpfr_set_emax(mpfr_get_emax_max())' or
     `mpfr_set_emin(mpfr_get_emin_min())' may not be portable.

 -- Function: int mpfr_check_range (mpfr_t X, int T, mpfr_rnd_t RND)
     This function assumes that X is the correctly-rounded value of some
     real value Y in the direction RND and some extended exponent
     range, and that T is the corresponding ternary value.  For
     example, one performed `t = mpfr_log (x, u, rnd)', and Y is the
     exact logarithm of U.  Thus T is negative if X is smaller than Y,
     positive if X is larger than Y, and zero if X equals Y.  This
     function modifies X if needed to be in the current range of
     acceptable values: It generates an underflow or an overflow if the
     exponent of X is outside the current allowed range; the value of T
     may be used to avoid a double rounding. This function returns zero
     if the new value of X equals the exact one Y, a positive value if
     that new value is larger than Y, and a negative value if it is
     smaller than Y.  Note that unlike most functions, the new result X
     is compared to the (unknown) exact one Y, not the input value X,
     i.e., the ternary value is propagated.

     Note: If X is an infinity and T is different from zero (i.e., if
     the rounded result is an inexact infinity), then the overflow flag
     is set. This is useful because `mpfr_check_range' is typically
     called (at least in MPFR functions) after restoring the flags that
     could have been set due to internal computations.

 -- Function: int mpfr_subnormalize (mpfr_t X, int T, mpfr_rnd_t RND)
     This function rounds X emulating subnormal number arithmetic: if X
     is outside the subnormal exponent range, it just propagates the
     ternary value T; otherwise, it rounds X to precision
     `EXP(x)-emin+1' according to rounding mode RND and previous
     ternary value T, avoiding double rounding problems.  More
     precisely in the subnormal domain, denoting by E the value of
     `emin', X is rounded in fixed-point arithmetic to an integer
     multiple of two to the power E-1; as a consequence, 1.5 multiplied
     by two to the power E-1 when T is zero is rounded to two to the
     power E with rounding to nearest.

     `PREC(x)' is not modified by this function.  RND and T must be the
     rounding mode and the returned ternary value used when computing X
     (as in `mpfr_check_range').  The subnormal exponent range is from
     `emin' to `emin+PREC(x)-1'.  If the result cannot be represented
     in the current exponent range (due to a too small `emax'), the
     behavior is undefined.  Note that unlike most functions, the
     result is compared to the exact one, not the input value X, i.e.,
     the ternary value is propagated.

   This is an example of how to emulate binary double IEEE 754
arithmetic (binary64 in IEEE 754-2008) using MPFR:

     {
       mpfr_t xa, xb; int i; volatile double a, b;

       mpfr_set_default_prec (53);
       mpfr_set_emin (-1073); mpfr_set_emax (1024);

       mpfr_init (xa); mpfr_init (xb);

       b = 34.3; mpfr_set_d (xb, b, MPFR_RNDN);
       a = 0x1.1235P-1021; mpfr_set_d (xa, a, MPFR_RNDN);

       a /= b;
       i = mpfr_div (xa, xa, xb, MPFR_RNDN);
       i = mpfr_subnormalize (xa, i, MPFR_RNDN); /* new ternary value */

       mpfr_clear (xa); mpfr_clear (xb);
     }

   Warning: this emulates a double IEEE 754 arithmetic with correct
rounding in the subnormal range, which may not be the case for your
hardware.

 -- Function: void mpfr_clear_underflow (void)
 -- Function: void mpfr_clear_overflow (void)
 -- Function: void mpfr_clear_nanflag (void)
 -- Function: void mpfr_clear_inexflag (void)
 -- Function: void mpfr_clear_erangeflag (void)
     Clear the underflow, overflow, invalid, inexact and _erange_ flags.

 -- Function: void mpfr_set_underflow (void)
 -- Function: void mpfr_set_overflow (void)
 -- Function: void mpfr_set_nanflag (void)
 -- Function: void mpfr_set_inexflag (void)
 -- Function: void mpfr_set_erangeflag (void)
     Set the underflow, overflow, invalid, inexact and _erange_ flags.

 -- Function: void mpfr_clear_flags (void)
     Clear all global flags (underflow, overflow, invalid, inexact,
     _erange_).

 -- Function: int mpfr_underflow_p (void)
 -- Function: int mpfr_overflow_p (void)
 -- Function: int mpfr_nanflag_p (void)
 -- Function: int mpfr_inexflag_p (void)
 -- Function: int mpfr_erangeflag_p (void)
     Return the corresponding (underflow, overflow, invalid, inexact,
     _erange_) flag, which is non-zero iff the flag is set.


File: mpfr.info,  Node: Compatibility with MPF,  Next: Custom Interface,  Prev: Exception Related Functions,  Up: MPFR Interface

5.14 Compatibility With MPF
===========================

A header file `mpf2mpfr.h' is included in the distribution of MPFR for
compatibility with the GNU MP class MPF.  By inserting the following
two lines after the `#include <gmp.h>' line,
#include <mpfr.h>
#include <mpf2mpfr.h>
 any program written for MPF can be compiled directly with MPFR without
any changes (except the `gmp_printf' functions will not work for
arguments of type `mpfr_t').  All operations are then performed with
the default MPFR rounding mode, which can be reset with
`mpfr_set_default_rounding_mode'.

   Warning: the `mpf_init' and `mpf_init2' functions initialize to
zero, whereas the corresponding MPFR functions initialize to NaN: this
is useful to detect uninitialized values, but is slightly incompatible
with MPF.

 -- Function: void mpfr_set_prec_raw (mpfr_t X, mpfr_prec_t PREC)
     Reset the precision of X to be *exactly* PREC bits.  The only
     difference with `mpfr_set_prec' is that PREC is assumed to be
     small enough so that the significand fits into the current
     allocated memory space for X. Otherwise the behavior is undefined.

 -- Function: int mpfr_eq (mpfr_t OP1, mpfr_t OP2, unsigned long int
          OP3)
     Return non-zero if OP1 and OP2 are both non-zero ordinary numbers
     with the same exponent and the same first OP3 bits, both zero, or
     both infinities of the same sign. Return zero otherwise.  This
     function is defined for compatibility with MPF, we do not recommend
     to use it otherwise.  Do not use it either if you want to know
     whether two numbers are close to each other; for instance,
     1.011111 and 1.100000 are regarded as different for any value of
     OP3 larger than 1.

 -- Function: void mpfr_reldiff (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
          mpfr_rnd_t RND)
     Compute the relative difference between OP1 and OP2 and store the
     result in ROP.  This function does not guarantee the correct
     rounding on the relative difference; it just computes
     |OP1-OP2|/OP1, using the precision of ROP and the rounding mode
     RND for all operations.

 -- Function: int mpfr_mul_2exp (mpfr_t ROP, mpfr_t OP1, unsigned long
          int OP2, mpfr_rnd_t RND)
 -- Function: int mpfr_div_2exp (mpfr_t ROP, mpfr_t OP1, unsigned long
          int OP2, mpfr_rnd_t RND)
     These functions are identical to `mpfr_mul_2ui' and `mpfr_div_2ui'
     respectively.  These functions are only kept for compatibility
     with MPF, one should prefer `mpfr_mul_2ui' and `mpfr_div_2ui'
     otherwise.


File: mpfr.info,  Node: Custom Interface,  Next: Internals,  Prev: Compatibility with MPF,  Up: MPFR Interface

5.15 Custom Interface
=====================

Some applications use a stack to handle the memory and their objects.
However, the MPFR memory design is not well suited for such a thing. So
that such applications are able to use MPFR, an auxiliary memory
interface has been created: the Custom Interface.

   The following interface allows one to use MPFR in two ways:
   * Either directly store a floating-point number as a `mpfr_t' on the
     stack.

   * Either store its own representation on the stack and construct a
     new temporary `mpfr_t' each time it is needed.
   Nothing has to be done to destroy the floating-point numbers except
garbaging the used memory: all the memory management (allocating,
destroying, garbaging) is left to the application.

   Each function in this interface is also implemented as a macro for
efficiency reasons: for example `mpfr_custom_init (s, p)' uses the
macro, while `(mpfr_custom_init) (s, p)' uses the function.

   Note 1: MPFR functions may still initialize temporary floating-point
numbers using `mpfr_init' and similar functions. See Custom Allocation
(GNU MP).

   Note 2: MPFR functions may use the cached functions (`mpfr_const_pi'
for example), even if they are not explicitly called. You have to call
`mpfr_free_cache' each time you garbage the memory iff `mpfr_init',
through GMP Custom Allocation, allocates its memory on the application
stack.

 -- Function: size_t mpfr_custom_get_size (mpfr_prec_t PREC)
     Return the needed size in bytes to store the significand of a
     floating-point number of precision PREC.

 -- Function: void mpfr_custom_init (void *SIGNIFICAND, mpfr_prec_t
          PREC)
     Initialize a significand of precision PREC, where SIGNIFICAND must
     be an area of `mpfr_custom_get_size (prec)' bytes at least and be
     suitably aligned for an array of `mp_limb_t' (GMP type, *note
     Internals::).

 -- Function: void mpfr_custom_init_set (mpfr_t X, int KIND, mpfr_exp_t
          EXP, mpfr_prec_t PREC, void *SIGNIFICAND)
     Perform a dummy initialization of a `mpfr_t' and set it to:
        * if `ABS(kind) == MPFR_NAN_KIND', X is set to NaN;

        * if `ABS(kind) == MPFR_INF_KIND', X is set to the infinity of
          sign `sign(kind)';

        * if `ABS(kind) == MPFR_ZERO_KIND', X is set to the zero of
          sign `sign(kind)';

        * if `ABS(kind) == MPFR_REGULAR_KIND', X is set to a regular
          number: `x = sign(kind)*significand*2^exp'.
     In all cases, it uses SIGNIFICAND directly for further computing
     involving X. It will not allocate anything.  A floating-point
     number initialized with this function cannot be resized using
     `mpfr_set_prec' or `mpfr_prec_round', or cleared using
     `mpfr_clear'!  The SIGNIFICAND must have been initialized with
     `mpfr_custom_init' using the same precision PREC.

 -- Function: int mpfr_custom_get_kind (mpfr_t X)
     Return the current kind of a `mpfr_t' as created by
     `mpfr_custom_init_set'.  The behavior of this function for any
     `mpfr_t' not initialized with `mpfr_custom_init_set' is undefined.

 -- Function: void * mpfr_custom_get_significand (mpfr_t X)
     Return a pointer to the significand used by a `mpfr_t' initialized
     with `mpfr_custom_init_set'.  The behavior of this function for
     any `mpfr_t' not initialized with `mpfr_custom_init_set' is
     undefined.

 -- Function: mpfr_exp_t mpfr_custom_get_exp (mpfr_t X)
     Return the exponent of X, assuming that X is a non-zero ordinary
     number. The return value for NaN, Infinity or zero is unspecified
     but does not produce any trap.  The behavior of this function for
     any `mpfr_t' not initialized with `mpfr_custom_init_set' is
     undefined.

 -- Function: void mpfr_custom_move (mpfr_t X, void *NEW_POSITION)
     Inform MPFR that the significand of X has moved due to a garbage
     collect and update its new position to `new_position'.  However
     the application has to move the significand and the `mpfr_t'
     itself.  The behavior of this function for any `mpfr_t' not
     initialized with `mpfr_custom_init_set' is undefined.


File: mpfr.info,  Node: Internals,  Prev: Custom Interface,  Up: MPFR Interface

5.16 Internals
==============

A "limb" means the part of a multi-precision number that fits in a
single word. Usually a limb contains 32 or 64 bits.  The C data type
for a limb is `mp_limb_t'.

   The `mpfr_t' type is internally defined as a one-element array of a
structure, and `mpfr_ptr' is the C data type representing a pointer to
this structure.  The `mpfr_t' type consists of four fields:

   * The `_mpfr_prec' field is used to store the precision of the
     variable (in bits); this is not less than `MPFR_PREC_MIN'.

   * The `_mpfr_sign' field is used to store the sign of the variable.

   * The `_mpfr_exp' field stores the exponent.  An e