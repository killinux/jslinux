fR.
.IP "\fB\-mbig\fR" 4
.IX Item "-mbig"
.PD 0
.IP "\fB\-mbig\-endian\fR" 4
.IX Item "-mbig-endian"
.PD
On System V.4 and embedded PowerPC systems compile code for the
processor in big endian mode.  The \fB\-mbig\-endian\fR option is
the same as \fB\-mbig\fR.
.IP "\fB\-mdynamic\-no\-pic\fR" 4
.IX Item "-mdynamic-no-pic"
On Darwin and Mac \s-1OS\s0 X systems, compile code so that it is not
relocatable, but that its external references are relocatable.  The
resulting code is suitable for applications, but not shared
libraries.
.IP "\fB\-mprioritize\-restricted\-insns=\fR\fIpriority\fR" 4
.IX Item "-mprioritize-restricted-insns=priority"
This option controls the priority that is assigned to
dispatch-slot restricted instructions during the second scheduling
pass.  The argument \fIpriority\fR takes the value \fI0/1/2\fR to assign
\&\fIno/highest/second\-highest\fR priority to dispatch slot restricted
instructions.
.IP "\fB\-msched\-costly\-dep=\fR\fIdependence_type\fR" 4
.IX Item "-msched-costly-dep=dependence_type"
This option controls which dependences are considered costly
by the target during instruction scheduling.  The argument
\&\fIdependence_type\fR takes one of the following values:
\&\fIno\fR: no dependence is costly,
\&\fIall\fR: all dependences are costly,
\&\fItrue_store_to_load\fR: a true dependence from store to load is costly,
\&\fIstore_to_load\fR: any dependence from store to load is costly,
\&\fInumber\fR: any dependence which latency >= \fInumber\fR is costly.
.IP "\fB\-minsert\-sched\-nops=\fR\fIscheme\fR" 4
.IX Item "-minsert-sched-nops=scheme"
This option controls which nop insertion scheme will be used during
the second scheduling pass.  The argument \fIscheme\fR takes one of the
following values:
\&\fIno\fR: Don't insert nops.
\&\fIpad\fR: Pad with nops any dispatch group which has vacant issue slots,
according to the scheduler's grouping.
\&\fIregroup_exact\fR: Insert nops to force costly dependent insns into
separate groups.  Insert exactly as many nops as needed to force an insn
to a new group, according to the estimated processor grouping.
\&\fInumber\fR: Insert nops to force costly dependent insns into
separate groups.  Insert \fInumber\fR nops to force an insn to a new group.
.IP "\fB\-mcall\-sysv\fR" 4
.IX Item "-mcall-sysv"
On System V.4 and embedded PowerPC systems compile code using calling
conventions that adheres to the March 1995 draft of the System V
Application Binary Interface, PowerPC processor supplement.  This is the
default unless you configured \s-1GCC\s0 using \fBpowerpc\-*\-eabiaix\fR.
.IP "\fB\-mcall\-sysv\-eabi\fR" 4
.IX Item "-mcall-sysv-eabi"
Specify both \fB\-mcall\-sysv\fR and \fB\-meabi\fR options.
.IP "\fB\-mcall\-sysv\-noeabi\fR" 4
.IX Item "-mcall-sysv-noeabi"
Specify both \fB\-mcall\-sysv\fR and \fB\-mno\-eabi\fR options.
.IP "\fB\-mcall\-solaris\fR" 4
.IX Item "-mcall-solaris"
On System V.4 and embedded PowerPC systems compile code for the Solaris
operating system.
.IP "\fB\-mcall\-linux\fR" 4
.IX Item "-mcall-linux"
On System V.4 and embedded PowerPC systems compile code for the
Linux-based \s-1GNU\s0 system.
.IP "\fB\-mcall\-gnu\fR" 4
.IX Item "-mcall-gnu"
On System V.4 and embedded PowerPC systems compile code for the
Hurd-based \s-1GNU\s0 system.
.IP "\fB\-mcall\-netbsd\fR" 4
.IX Item "-mcall-netbsd"
On System V.4 and embedded PowerPC systems compile code for the
NetBSD operating system.
.IP "\fB\-maix\-struct\-return\fR" 4
.IX Item "-maix-struct-return"
Return all structures in memory (as specified by the \s-1AIX\s0 \s-1ABI\s0).
.IP "\fB\-msvr4\-struct\-return\fR" 4
.IX Item "-msvr4-struct-return"
Return structures smaller than 8 bytes in registers (as specified by the
\&\s-1SVR4\s0 \s-1ABI\s0).
.IP "\fB\-mabi=\fR\fIabi-type\fR" 4
.IX Item "-mabi=abi-type"
Extend the current \s-1ABI\s0 with a particular extension, or remove such extension.
Valid values are \fIaltivec\fR, \fIno-altivec\fR, \fIspe\fR,
\&\fIno-spe\fR, \fIibmlongdouble\fR, \fIieeelongdouble\fR.
.IP "\fB\-mabi=spe\fR" 4
.IX Item "-mabi=spe"
Extend the current \s-1ABI\s0 with \s-1SPE\s0 \s-1ABI\s0 extensions.  This does not change
the default \s-1ABI\s0, instead it adds the \s-1SPE\s0 \s-1ABI\s0 extensions to the current
\&\s-1ABI\s0.
.IP "\fB\-mabi=no\-spe\fR" 4
.IX Item "-mabi=no-spe"
Disable Booke \s-1SPE\s0 \s-1ABI\s0 extensions for the current \s-1ABI\s0.
.IP "\fB\-mabi=ibmlongdouble\fR" 4
.IX Item "-mabi=ibmlongdouble"
Change the current \s-1ABI\s0 to use \s-1IBM\s0 extended precision long double.
This is a PowerPC 32\-bit \s-1SYSV\s0 \s-1ABI\s0 option.
.IP "\fB\-mabi=ieeelongdouble\fR" 4
.IX Item "-mabi=ieeelongdouble"
Change the current \s-1ABI\s0 to use \s-1IEEE\s0 extended precision long double.
This is a PowerPC 32\-bit Linux \s-1ABI\s0 option.
.IP "\fB\-mprototype\fR" 4
.IX Item "-mprototype"
.PD 0
.IP "\fB\-mno\-prototype\fR" 4
.IX Item "-mno-prototype"
.PD
On System V.4 and embedded PowerPC systems assume that all calls to
variable argument functions are properly prototyped.  Otherwise, the
compiler must insert an instruction before every non prototyped call to
set or clear bit 6 of the condition code register (\fI\s-1CR\s0\fR) to
indicate whether floating point values were passed in the floating point
registers in case the function takes a variable arguments.  With
\&\fB\-mprototype\fR, only calls to prototyped variable argument functions
will set or clear the bit.
.IP "\fB\-msim\fR" 4
.IX Item "-msim"
On embedded PowerPC systems, assume that the startup module is called
\&\fIsim\-crt0.o\fR and that the standard C libraries are \fIlibsim.a\fR and
\&\fIlibc.a\fR.  This is the default for \fBpowerpc\-*\-eabisim\fR
configurations.
.IP "\fB\-mmvme\fR" 4
.IX Item "-mmvme"
On embedded PowerPC systems, assume that the startup module is called
\&\fIcrt0.o\fR and the standard C libraries are \fIlibmvme.a\fR and
\&\fIlibc.a\fR.
.IP "\fB\-mads\fR" 4
.IX Item "-mads"
On embedded PowerPC systems, assume that the startup module is called
\&\fIcrt0.o\fR and the standard C libraries are \fIlibads.a\fR and
\&\fIlibc.a\fR.
.IP "\fB\-myellowknife\fR" 4
.IX Item "-myellowknife"
On embedded PowerPC systems, assume that the startup module is called
\&\fIcrt0.o\fR and the standard C libraries are \fIlibyk.a\fR and
\&\fIlibc.a\fR.
.IP "\fB\-mvxworks\fR" 4
.IX Item "-mvxworks"
On System V.4 and embedded PowerPC systems, specify that you are
compiling for a VxWorks system.
.IP "\fB\-mwindiss\fR" 4
.IX Item "-mwindiss"
Specify that you are compiling for the WindISS simulation environment.
.IP "\fB\-memb\fR" 4
.IX Item "-memb"
On embedded PowerPC systems, set the \fI\s-1PPC_EMB\s0\fR bit in the \s-1ELF\s0 flags
header to indicate that \fBeabi\fR extended relocations are used.
.IP "\fB\-meabi\fR" 4
.IX Item "-meabi"
.PD 0
.IP "\fB\-mno\-eabi\fR" 4
.IX Item "-mno-eabi"
.PD
On System V.4 and embedded PowerPC systems do (do not) adhere to the
Embedded Applications Binary Interface (eabi) which is a set of
modifications to the System V.4 specifications.  Selecting \fB\-meabi\fR
means that the stack is aligned to an 8 byte boundary, a function
\&\f(CW\*(C`_\|_eabi\*(C'\fR is called to from \f(CW\*(C`main\*(C'\fR to set up the eabi
environment, and the \fB\-msdata\fR option can use both \f(CW\*(C`r2\*(C'\fR and
\&\f(CW\*(C`r13\*(C'\fR to point to two separate small data areas.  Selecting
\&\fB\-mno\-eabi\fR means that the stack is aligned to a 16 byte boundary,
do not call an initialization function from \f(CW\*(C`main\*(C'\fR, and the
\&\fB\-msdata\fR option will only use \f(CW\*(C`r13\*(C'\fR to point to a single
small data area.  The \fB\-meabi\fR option is on by default if you
configured \s-1GCC\s0 using one of the \fBpowerpc*\-*\-eabi*\fR options.
.IP "\fB\-msdata=eabi\fR" 4
.IX Item "-msdata=eabi"
On System V.4 and embedded PowerPC systems, put small initialized
\&\f(CW\*(C`const\*(C'\fR global and static data in the \fB.sdata2\fR section, which
is pointed to by register \f(CW\*(C`r2\*(C'\fR.  Put small initialized
non\-\f(CW\*(C`const\*(C'\fR global and static data in the \fB.sdata\fR section,
which is pointed to by register \f(CW\*(C`r13\*(C'\fR.  Put small uninitialized
global and static data in the \fB.sbss\fR section, which is adjacent to
the \fB.sdata\fR section.  The \fB\-msdata=eabi\fR option is
incompatible with the \fB\-mrelocatable\fR option.  The
\&\fB\-msdata=eabi\fR option also sets the \fB\-memb\fR option.
.IP "\fB\-msdata=sysv\fR" 4
.IX Item "-msdata=sysv"
On System V.4 and embedded PowerPC systems, put small global and static
data in the \fB.sdata\fR section, which is pointed to by register
\&\f(CW\*(C`r13\*(C'\fR.  Put small uninitialized global and static data in the
\&\fB.sbss\fR section, which is adjacent to the \fB.sdata\fR section.
The \fB\-msdata=sysv\fR option is incompatible with the
\&\fB\-mrelocatable\fR option.
.IP "\fB\-msdata=default\fR" 4
.IX Item "-msdata=default"
.PD 0
.IP "\fB\-msdata\fR" 4
.IX Item "-msdata"
.PD
On System V.4 and embedded PowerPC systems, if \fB\-meabi\fR is used,
compile code the same as \fB\-msdata=eabi\fR, otherwise compile code the
same as \fB\-msdata=sysv\fR.
.IP "\fB\-msdata\-data\fR" 4
.IX Item "-msdata-data"
On System V.4 and embedded PowerPC systems, put small global
data in the \fB.sdata\fR section.  Put small uninitialized global
data in the \fB.sbss\fR section.  Do not use register \f(CW\*(C`r13\*(C'\fR
to address small data however.  This is the default behavior unless
other \fB\-msdata\fR options are used.
.IP "\fB\-msdata=none\fR" 4
.IX Item "-msdata=none"
.PD 0
.IP "\fB\-mno\-sdata\fR" 4
.IX Item "-mno-sdata"
.PD
On embedded PowerPC systems, put all initialized global and static data
in the \fB.data\fR section, and all uninitialized data in the
\&\fB.bss\fR section.
.IP "\fB\-G\fR \fInum\fR" 4
.IX Item "-G num"
On embedded PowerPC systems, put global and static items less than or
equal to \fInum\fR bytes into the small data or bss sections instead of
the normal data or bss section.  By default, \fInum\fR is 8.  The
\&\fB\-G\fR \fInum\fR switch is also passed to the linker.
All modules should be compiled with the same \fB\-G\fR \fInum\fR value.
.IP "\fB\-mregnames\fR" 4
.IX Item "-mregnames"
.PD 0
.IP "\fB\-mno\-regnames\fR" 4
.IX Item "-mno-regnames"
.PD
On System V.4 and embedded PowerPC systems do (do not) emit register
names in the assembly language output using symbolic forms.
.IP "\fB\-mlongcall\fR" 4
.IX Item "-mlongcall"
.PD 0
.IP "\fB\-mno\-longcall\fR" 4
.IX Item "-mno-longcall"
.PD
By default assume that all calls are far away so that a longer more
expensive calling sequence is required.  This is required for calls
further than 32 megabytes (33,554,432 bytes) from the current location.
A short call will be generated if the compiler knows
the call cannot be that far away.  This setting can be overridden by
the \f(CW\*(C`shortcall\*(C'\fR function attribute, or by \f(CW\*(C`#pragma
longcall(0)\*(C'\fR.
.Sp
Some linkers are capable of detecting out-of-range calls and generating
glue code on the fly.  On these systems, long calls are unnecessary and
generate slower code.  As of this writing, the \s-1AIX\s0 linker can do this,
as can the \s-1GNU\s0 linker for PowerPC/64.  It is planned to add this feature
to the \s-1GNU\s0 linker for 32\-bit PowerPC systems as well.
.Sp
On Darwin/PPC systems, \f(CW\*(C`#pragma longcall\*(C'\fR will generate \*(L"jbsr
callee, L42\*(R", plus a \*(L"branch island\*(R" (glue code).  The two target
addresses represent the callee and the \*(L"branch island\*(R".  The
Darwin/PPC linker will prefer the first address and generate a \*(L"bl
callee\*(R" if the \s-1PPC\s0 \*(L"bl\*(R" instruction will reach the callee directly;
otherwise, the linker will generate \*(L"bl L42\*(R" to call the \*(L"branch
island\*(R".  The \*(L"branch island\*(R" is appended to the body of the
calling function; it computes the full 32\-bit address of the callee
and jumps to it.
.Sp
On Mach-O (Darwin) systems, this option directs the compiler emit to
the glue for every direct call, and the Darwin linker decides whether
to use or discard it.
.Sp
In the future, we may cause \s-1GCC\s0 to ignore all longcall specifications
when the linker is known to generate glue.
.IP "\fB\-pthread\fR" 4
.IX Item "-pthread"
Adds support for multithreading with the \fIpthreads\fR library.
This option sets flags for both the preprocessor and linker.
.PP
\fIS/390 and zSeries Options\fR
.IX Subsection "S/390 and zSeries Options"
.PP
These are the \fB\-m\fR options defined for the S/390 and zSeries architecture.
.IP "\fB\-mhard\-float\fR" 4
.IX Item "-mhard-float"
.PD 0
.IP "\fB\-msoft\-float\fR" 4
.IX Item "-msoft-float"
.PD
Use (do not use) the hardware floating-point instructions and registers
for floating-point operations.  When \fB\-msoft\-float\fR is specified,
functions in \fIlibgcc.a\fR will be used to perform floating-point
operations.  When \fB\-mhard\-float\fR is specified, the compiler
generates \s-1IEEE\s0 floating-point instructions.  This is the default.
.IP "\fB\-mhard\-dfp\fR" 4
.IX Item "-mhard-dfp"
.PD 0
.IP "\fB\-mno\-hard\-dfp\fR" 4
.IX Item "-mno-hard-dfp"
.PD
Use (do not use) the hardware decimal-floating-point instructions for
decimal-floating-point operations.  When \fB\-mno\-hard\-dfp\fR is
specified, functions in \fIlibgcc.a\fR will be used to perform
decimal-floating-point operations.  When \fB\-mhard\-dfp\fR is
specified, the compiler generates decimal-floating-point hardware
instructions.  This is the default for \fB\-march=z9\-ec\fR or higher.
.IP "\fB\-mlong\-double\-64\fR" 4
.IX Item "-mlong-double-64"
.PD 0
.IP "\fB\-mlong\-double\-128\fR" 4
.IX Item "-mlong-double-128"
.PD
These switches control the size of \f(CW\*(C`long double\*(C'\fR type. A size
of 64bit makes the \f(CW\*(C`long double\*(C'\fR type equivalent to the \f(CW\*(C`double\*(C'\fR
type. This is the default.
.IP "\fB\-mbackchain\fR" 4
.IX Item "-mbackchain"
.PD 0
.IP "\fB\-mno\-backchain\fR" 4
.IX Item "-mno-backchain"
.PD
Store (do not store) the address of the caller's frame as backchain pointer
into the callee's stack frame.
A backchain may be needed to allow debugging using tools that do not understand
\&\s-1DWARF\-2\s0 call frame information.
When \fB\-mno\-packed\-stack\fR is in effect, the backchain pointer is stored
at the bottom of the stack frame; when \fB\-mpacked\-stack\fR is in effect,
the backchain is placed into the topmost word of the 96/160 byte register
save area.
.Sp
In general, code compiled with \fB\-mbackchain\fR is call-compatible with
code compiled with \fB\-mmo\-backchain\fR; however, use of the backchain
for debugging purposes usually requires that the whole binary is built with
\&\fB\-mbackchain\fR.  Note that the combination of \fB\-mbackchain\fR,
\&\fB\-mpacked\-stack\fR and \fB\-mhard\-float\fR is not supported.  In order
to build a linux kernel use \fB\-msoft\-float\fR.
.Sp
The default is to not maintain the backchain.
.IP "\fB\-mpacked\-stack\fR" 4
.IX Item "-mpacked-stack"
.PD 0
.IP "\fB\-mno\-packed\-stack\fR" 4
.IX Item "-mno-packed-stack"
.PD
Use (do not use) the packed stack layout.  When \fB\-mno\-packed\-stack\fR is
specified, the compiler uses the all fields of the 96/160 byte register save
area only for their default purpose; unused fields still take up stack space.
When \fB\-mpacked\-stack\fR is specified, register save slots are densely
packed at the top of the register save area; unused space is reused for other
purposes, allowing for more efficient use of the available stack space.
However, when \fB\-mbackchain\fR is also in effect, the topmost word of
the save area is always used to store the backchain, and the return address
register is always saved two words below the backchain.
.Sp
As long as the stack frame backchain is not used, code generated with
\&\fB\-mpacked\-stack\fR is call-compatible with code generated with
\&\fB\-mno\-packed\-stack\fR.  Note that some non-FSF releases of \s-1GCC\s0 2.95 for
S/390 or zSeries generated code that uses the stack frame backchain at run
time, not just for debugging purposes.  Such code is not call-compatible
with code compiled with \fB\-mpacked\-stack\fR.  Also, note that the
combination of \fB\-mbackchain\fR,
\&\fB\-mpacked\-stack\fR and \fB\-mhard\-float\fR is not supported.  In order
to build a linux kernel use \fB\-msoft\-float\fR.
.Sp
The default is to not use the packed stack layout.
.IP "\fB\-msmall\-exec\fR" 4
.IX Item "-msmall-exec"
.PD 0
.IP "\fB\-mno\-small\-exec\fR" 4
.IX Item "-mno-small-exec"
.PD
Generate (or do not generate) code using the \f(CW\*(C`bras\*(C'\fR instruction
to do subroutine calls.
This only works reliably if the total executable size does not
exceed 64k.  The default is to use the \f(CW\*(C`basr\*(C'\fR instruction instead,
which does not have this limitation.
.IP "\fB\-m64\fR" 4
.IX Item "-m64"
.PD 0
.IP "\fB\-m31\fR" 4
.IX Item "-m31"
.PD
When \fB\-m31\fR is specified, generate code compliant to the
GNU/Linux for S/390 \s-1ABI\s0.  When \fB\-m64\fR is specified, generate
code compliant to the GNU/Linux for zSeries \s-1ABI\s0.  This allows \s-1GCC\s0 in
particular to generate 64\-bit instructions.  For the \fBs390\fR
targets, the default is \fB\-m31\fR, while the \fBs390x\fR
targets default to \fB\-m64\fR.
.IP "\fB\-mzarch\fR" 4
.IX Item "-mzarch"
.PD 0
.IP "\fB\-mesa\fR" 4
.IX Item "-mesa"
.PD
When \fB\-mzarch\fR is specified, generate code using the
instructions available on z/Architecture.
When \fB\-mesa\fR is specified, generate code using the
instructions available on \s-1ESA/390\s0.  Note that \fB\-mesa\fR is
not possible with \fB\-m64\fR.
When generating code compliant to the GNU/Linux for S/390 \s-1ABI\s0,
the default is \fB\-mesa\fR.  When generating code compliant
to the GNU/Linux for zSeries \s-1ABI\s0, the default is \fB\-mzarch\fR.
.IP "\fB\-mmvcle\fR" 4
.IX Item "-mmvcle"
.PD 0
.IP "\fB\-mno\-mvcle\fR" 4
.IX Item "-mno-mvcle"
.PD
Generate (or do not generate) code using the \f(CW\*(C`mvcle\*(C'\fR instruction
to perform block moves.  When \fB\-mno\-mvcle\fR is specified,
use a \f(CW\*(C`mvc\*(C'\fR loop instead.  This is the default unless optimizing for
size.
.IP "\fB\-mdebug\fR" 4
.IX Item "-mdebug"
.PD 0
.IP "\fB\-mno\-debug\fR" 4
.IX Item "-mno-debug"
.PD
Print (or do not print) additional debug information when compiling.
The default is to not print debug information.
.IP "\fB\-march=\fR\fIcpu-type\fR" 4
.IX Item "-march=cpu-type"
Generate code that will run on \fIcpu-type\fR, which is the name of a system
representing a certain processor type.  Possible values for
\&\fIcpu-type\fR are \fBg5\fR, \fBg6\fR, \fBz900\fR, \fBz990\fR,
\&\fBz9\-109\fR and \fBz9\-ec\fR.
When generating code using the instructions available on z/Architecture,
the default is \fB\-march=z900\fR.  Otherwise, the default is
\&\fB\-march=g5\fR.
.IP "\fB\-mtune=\fR\fIcpu-type\fR" 4
.IX Item "-mtune=cpu-type"
Tune to \fIcpu-type\fR everything applicable about the generated code,
except for the \s-1ABI\s0 and the set of available instructions.
The list of \fIcpu-type\fR values is the same as for \fB\-march\fR.
The default is the value used for \fB\-march\fR.
.IP "\fB\-mtpf\-trace\fR" 4
.IX Item "-mtpf-trace"
.PD 0
.IP "\fB\-mno\-tpf\-trace\fR" 4
.IX Item "-mno-tpf-trace"
.PD
Generate code that adds (does not add) in \s-1TPF\s0 \s-1OS\s0 specific branches to trace
routines in the operating system.  This option is off by default, even
when compiling for the \s-1TPF\s0 \s-1OS\s0.
.IP "\fB\-mfused\-madd\fR" 4
.IX Item "-mfused-madd"
.PD 0
.IP "\fB\-mno\-fused\-madd\fR" 4
.IX Item "-mno-fused-madd"
.PD
Generate code that uses (does not use) the floating point multiply and
accumulate instructions.  These instructions are generated by default if
hardware floating point is used.
.IP "\fB\-mwarn\-framesize=\fR\fIframesize\fR" 4
.IX Item "-mwarn-framesize=framesize"
Emit a warning if the current function exceeds the given frame size.  Because
this is a compile time check it doesn't need to be a real problem when the program
runs.  It is intended to identify functions which most probably cause
a stack overflow.  It is useful to be used in an environment with limited stack
size e.g. the linux kernel.
.IP "\fB\-mwarn\-dynamicstack\fR" 4
.IX Item "-mwarn-dynamicstack"
Emit a warning if the function calls alloca or uses dynamically
sized arrays.  This is generally a bad idea with a limited stack size.
.IP "\fB\-mstack\-guard=\fR\fIstack-guard\fR" 4
.IX Item "-mstack-guard=stack-guard"
.PD 0
.IP "\fB\-mstack\-size=\fR\fIstack-size\fR" 4
.IX Item "-mstack-size=stack-size"
.PD
If these options are provided the s390 back end emits additional instructions in
the function prologue which trigger a trap if the stack size is \fIstack-guard\fR
bytes above the \fIstack-size\fR (remember that the stack on s390 grows downward).
If the \fIstack-guard\fR option is omitted the smallest power of 2 larger than
the frame size of the compiled function is chosen.
These options are intended to be used to help debugging stack overflow problems.
The additionally emitted code causes only little overhead and hence can also be
used in production like systems without greater performance degradation.  The given
values have to be exact powers of 2 and \fIstack-size\fR has to be greater than
\&\fIstack-guard\fR without exceeding 64k.
In order to be efficient the extra code makes the assumption that the stack starts
at an address aligned to the value given by \fIstack-size\fR.
The \fIstack-guard\fR option can only be used in conjunction with \fIstack-size\fR.
.PP
\fIScore Options\fR
.IX Subsection "Score Options"
.PP
These options are defined for Score implementations:
.IP "\fB\-meb\fR" 4
.IX Item "-meb"
Compile code for big endian mode.  This is the default.
.IP "\fB\-mel\fR" 4
.IX Item "-mel"
Compile code for little endian mode.
.IP "\fB\-mnhwloop\fR" 4
.IX Item "-mnhwloop"
Disable generate bcnz instruction.
.IP "\fB\-muls\fR" 4
.IX Item "-muls"
Enable generate unaligned load and store instruction.
.IP "\fB\-mmac\fR" 4
.IX Item "-mmac"
Enable the use of multiply-accumulate instructions. Disabled by default.
.IP "\fB\-mscore5\fR" 4
.IX Item "-mscore5"
Specify the \s-1SCORE5\s0 as the target architecture.
.IP "\fB\-mscore5u\fR" 4
.IX Item "-mscore5u"
Specify the \s-1SCORE5U\s0 of the target architecture.
.IP "\fB\-mscore7\fR" 4
.IX Item "-mscore7"
Specify the \s-1SCORE7\s0 as the target architecture. This is the default.
.IP "\fB\-mscore7d\fR" 4
.IX Item "-mscore7d"
Specify the \s-1SCORE7D\s0 as the target architecture.
.PP
\fI\s-1SH\s0 Options\fR
.IX Subsection "SH Options"
.PP
These \fB\-m\fR options are defined for the \s-1SH\s0 implementations:
.IP "\fB\-m1\fR" 4
.IX Item "-m1"
Generate code for the \s-1SH1\s0.
.IP "\fB\-m2\fR" 4
.IX Item "-m2"
Generate code for the \s-1SH2\s0.
.IP "\fB\-m2e\fR" 4
.IX Item "-m2e"
Generate code for the SH2e.
.IP "\fB\-m3\fR" 4
.IX Item "-m3"
Generate code for the \s-1SH3\s0.
.IP "\fB\-m3e\fR" 4
.IX Item "-m3e"
Generate code for the SH3e.
.IP "\fB\-m4\-nofpu\fR" 4
.IX Item "-m4-nofpu"
Generate code for the \s-1SH4\s0 without a floating-point unit.
.IP "\fB\-m4\-single\-only\fR" 4
.IX Item "-m4-single-only"
Generate code for the \s-1SH4\s0 with a floating-point unit that only
supports single-precision arithmetic.
.IP "\fB\-m4\-single\fR" 4
.IX Item "-m4-single"
Generate code for the \s-1SH4\s0 assuming the floating-point unit is in
single-precision mode by default.
.IP "\fB\-m4\fR" 4
.IX Item "-m4"
Generate code for the \s-1SH4\s0.
.IP "\fB\-m4a\-nofpu\fR" 4
.IX Item "-m4a-nofpu"
Generate code for the SH4al\-dsp, or for a SH4a in such a way that the
floating-point unit is not used.
.IP "\fB\-m4a\-single\-only\fR" 4
.IX Item "-m4a-single-only"
Generate code for the SH4a, in such a way that no double-precision
floating point operations are used.
.IP "\fB\-m4a\-single\fR" 4
.IX Item "-m4a-single"
Generate code for the SH4a assuming the floating-point unit is in
single-precision mode by default.
.IP "\fB\-m4a\fR" 4
.IX Item "-m4a"
Generate code for the SH4a.
.IP "\fB\-m4al\fR" 4
.IX Item "-m4al"
Same as \fB\-m4a\-nofpu\fR, except that it implicitly passes
\&\fB\-dsp\fR to the assembler.  \s-1GCC\s0 doesn't generate any \s-1DSP\s0
instructions at the moment.
.IP "\fB\-mb\fR" 4
.IX Item "-mb"
Compile code for the processor in big endian mode.
.IP "\fB\-ml\fR" 4
.IX Item "-ml"
Compile code for the processor in little endian mode.
.IP "\fB\-mdalign\fR" 4
.IX Item "-mdalign"
Align doubles at 64\-bit boundaries.  Note that this changes the calling
conventions, and thus some functions from the standard C library will
not work unless you recompile it first with \fB\-mdalign\fR.
.IP "\fB\-mrelax\fR" 4
.IX Item "-mrelax"
Shorten some address references at link time, when possible; uses the
linker option \fB\-relax\fR.
.IP "\fB\-mbigtable\fR" 4
.IX Item "-mbigtable"
Use 32\-bit offsets in \f(CW\*(C`switch\*(C'\fR tables.  The default is to use
16\-bit offsets.
.IP "\fB\-mfmovd\fR" 4
.IX Item "-mfmovd"
Enable the use of the instruction \f(CW\*(C`fmovd\*(C'\fR.
.IP "\fB\-mhitachi\fR" 4
.IX Item "-mhitachi"
Comply with the calling conventions defined by Renesas.
.IP "\fB\-mrenesas\fR" 4
.IX Item "-mrenesas"
Comply with the calling conventions defined by Renesas.
.IP "\fB\-mno\-renesas\fR" 4
.IX Item "-mno-renesas"
Comply with the calling conventions defined for \s-1GCC\s0 before the Renesas
conventions were available.  This option is the default for all
targets of the \s-1SH\s0 toolchain except for \fBsh-symbianelf\fR.
.IP "\fB\-mnomacsave\fR" 4
.IX Item "-mnomacsave"
Mark the \f(CW\*(C`MAC\*(C'\fR register as call-clobbered, even if
\&\fB\-mhitachi\fR is given.
.IP "\fB\-mieee\fR" 4
.IX Item "-mieee"
Increase IEEE-compliance of floating-point code.
At the moment, this is equivalent to \fB\-fno\-finite\-math\-only\fR.
When generating 16 bit \s-1SH\s0 opcodes, getting IEEE-conforming results for
comparisons of NANs / infinities incurs extra overhead in every
floating point comparison, therefore the default is set to
\&\fB\-ffinite\-math\-only\fR.
.IP "\fB\-minline\-ic_invalidate\fR" 4
.IX Item "-minline-ic_invalidate"
Inline code to invalidate instruction cache entries after setting up
nested function trampolines.
This option has no effect if \-musermode is in effect and the selected
code generation option (e.g. \-m4) does not allow the use of the icbi
instruction.
If the selected code generation option does not allow the use of the icbi
instruction, and \-musermode is not in effect, the inlined code will
manipulate the instruction cache address array directly with an associative
write.  This not only requires privileged mode, but it will also
fail if the cache line had been mapped via the \s-1TLB\s0 and has become unmapped.
.IP "\fB\-misize\fR" 4
.IX Item "-misize"
Dump instruction size and location in the assembly code.
.IP "\fB\-mpadstruct\fR" 4
.IX Item "-mpadstruct"
This option is deprecated.  It pads structures to multiple of 4 bytes,
which is incompatible with the \s-1SH\s0 \s-1ABI\s0.
.IP "\fB\-mspace\fR" 4
.IX Item "-mspace"
Optimize for space instead of speed.  Implied by \fB\-Os\fR.
.IP "\fB\-mprefergot\fR" 4
.IX Item "-mprefergot"
When generating position-independent code, emit function calls using
the Global Offset Table instead of the Procedure Linkage Table.
.IP "\fB\-musermode\fR" 4
.IX Item "-musermode"
Don't generate privileged mode only code; implies \-mno\-inline\-ic_invalidate
if the inlined code would not work in user mode.
This is the default when the target is \f(CW\*(C`sh\-*\-linux*\*(C'\fR.
.IP "\fB\-multcost=\fR\fInumber\fR" 4
.IX Item "-multcost=number"
Set the cost to assume for a multiply insn.
.IP "\fB\-mdiv=\fR\fIstrategy\fR" 4
.IX Item "-mdiv=strategy"
Set the division strategy to use for SHmedia code.  \fIstrategy\fR must be
one of: call, call2, fp, inv, inv:minlat, inv20u, inv20l, inv:call,
inv:call2, inv:fp .
\&\*(L"fp\*(R" performs the operation in floating point.  This has a very high latency,
but needs only a few instructions, so it might be a good choice if
your code has enough easily exploitable \s-1ILP\s0 to allow the compiler to
schedule the floating point instructions together with other instructions.
Division by zero causes a floating point exception.
\&\*(L"inv\*(R" uses integer operations to calculate the inverse of the divisor,
and then multiplies the dividend with the inverse.  This strategy allows
cse and hoisting of the inverse calculation.  Division by zero calculates
an unspecified result, but does not trap.
\&\*(L"inv:minlat\*(R" is a variant of \*(L"inv\*(R" where if no cse / hoisting opportunities
have been found, or if the entire operation has been hoisted to the same
place, the last stages of the inverse calculation are intertwined with the
final multiply to reduce the overall latency, at the expense of using a few
more instructions, and thus offering fewer scheduling opportunities with
other code.
\&\*(L"call\*(R" calls a library function that usually implements the inv:minlat
strategy.
This gives high code density for m5\-*media\-nofpu compilations.
\&\*(L"call2\*(R" uses a different entry point of the same library function, where it
assumes that a pointer to a lookup table has already been set up, which
exposes the pointer load to cse / code hoisting optimizations.
\&\*(L"inv:call\*(R", \*(L"inv:call2\*(R" and \*(L"inv:fp\*(R" all use the \*(L"inv\*(R" algorithm for initial
code generation, but if the code stays unoptimized, revert to the \*(L"call\*(R",
\&\*(L"call2\*(R", or \*(L"fp\*(R" strategies, respectively.  Note that the
potentially-trapping side effect of division by zero is carried by a
separate instruction, so it is possible that all the integer instructions
are hoisted out, but the marker for the side effect stays where it is.
A recombination to fp operations or a call is not possible in that case.
\&\*(L"inv20u\*(R" and \*(L"inv20l\*(R" are variants of the \*(L"inv:minlat\*(R" strategy.  In the case
that the inverse calculation was nor separated from the multiply, they speed
up division where the dividend fits into 20 bits (plus sign where applicable),
by inserting a test to skip a number of operations in this case; this test
slows down the case of larger dividends.  inv20u assumes the case of a such
a small dividend to be unlikely, and inv20l assumes it to be likely.
.IP "\fB\-mdivsi3_libfunc=\fR\fIname\fR" 4
.IX Item "-mdivsi3_libfunc=name"
Set the name of the library function used for 32 bit signed division to
\&\fIname\fR.  This only affect the name used in the call and inv:call
division strategies, and the compiler will still expect the same
sets of input/output/clobbered registers as if this option was not present.
.IP "\fB\-madjust\-unroll\fR" 4
.IX Item "-madjust-unroll"
Throttle unrolling to avoid thrashing target registers.
This option only has an effect if the gcc code base supports the
\&\s-1TARGET_ADJUST_UNROLL_MAX\s0 target hook.
.IP "\fB\-mindexed\-addressing\fR" 4
.IX Item "-mindexed-addressing"
Enable the use of the indexed addressing mode for SHmedia32/SHcompact.
This is only safe if the hardware and/or \s-1OS\s0 implement 32 bit wrap-around
semantics for the indexed addressing mode.  The architecture allows the
implementation of processors with 64 bit \s-1MMU\s0, which the \s-1OS\s0 could use to
get 32 bit addressing, but since no current hardware implementation supports
this or any other way to make the indexed addressing mode safe to use in
the 32 bit \s-1ABI\s0, the default is \-mno\-indexed\-addressing.
.IP "\fB\-mgettrcost=\fR\fInumber\fR" 4
.IX Item "-mgettrcost=number"
Set the cost assumed for the gettr instruction to \fInumber\fR.
The default is 2 if \fB\-mpt\-fixed\fR is in effect, 100 otherwise.
.IP "\fB\-mpt\-fixed\fR" 4
.IX Item "-mpt-fixed"
Assume pt* instructions won't trap.  This will generally generate better
scheduled code, but is unsafe on current hardware.  The current architecture
definition says that ptabs and ptrel trap when the target anded with 3 is 3.
This has the unintentional effect of making it unsafe to schedule ptabs /
ptrel before a branch, or hoist it out of a loop.  For example,
_\|_do_global_ctors, a part of libgcc that runs constructors at program
startup, calls functions in a list which is delimited by \-1.  With the
\&\-mpt\-fixed option, the ptabs will be done before testing against \-1.
That means that all the constructors will be run a bit quicker, but when
the loop comes to the end of the list, the program crashes because ptabs
loads \-1 into a target register.  Since this option is unsafe for any
hardware implementing the current architecture specification, the default
is \-mno\-pt\-fixed.  Unless the user specifies a specific cost with
\&\fB\-mgettrcost\fR, \-mno\-pt\-fixed also implies \fB\-mgettrcost=100\fR;
this deters register allocation using target registers for storing
ordinary integers.
.IP "\fB\-minvalid\-symbols\fR" 4
.IX Item "-minvalid-symbols"
Assume symbols might be invalid.  Ordinary function symbols generated by
the compiler will always be valid to load with movi/shori/ptabs or
movi/shori/ptrel, but with assembler and/or linker tricks it is possible
to generate symbols that will cause ptabs / ptrel to trap.
This option is only meaningful when \fB\-mno\-pt\-fixed\fR is in effect.
It will then prevent cross-basic-block cse, hoisting and most scheduling
of symbol loads.  The default is \fB\-mno\-invalid\-symbols\fR.
.PP
\fI\s-1SPARC\s0 Options\fR
.IX Subsection "SPARC Options"
.PP
These \fB\-m\fR options are supported on the \s-1SPARC:\s0
.IP "\fB\-mno\-app\-regs\fR" 4
.IX Item "-mno-app-regs"
.PD 0
.IP "\fB\-mapp\-regs\fR" 4
.IX Item "-mapp-regs"
.PD
Specify \fB\-mapp\-regs\fR to generate output using the global registers
2 through 4, which the \s-1SPARC\s0 \s-1SVR4\s0 \s-1ABI\s0 reserves for applications.  This
is the default.
.Sp
To be fully \s-1SVR4\s0 \s-1ABI\s0 compliant at the cost of some performance loss,
specify \fB\-mno\-app\-regs\fR.  You should compile libraries and system
software with this option.
.IP "\fB\-mfpu\fR" 4
.IX Item "-mfpu"
.PD 0
.IP "\fB\-mhard\-float\fR" 4
.IX Item "-mhard-float"
.PD
Generate output containing floating point instructions.  This is the
default.
.IP "\fB\-mno\-fpu\fR" 4
.IX Item "-mno-fpu"
.PD 0
.IP "\fB\-msoft\-float\fR" 4
.IX Item "-msoft-float"
.PD
Generate output containing library calls for floating point.
\&\fBWarning:\fR the requisite libraries are not available for all \s-1SPARC\s0
targets.  Normally the facilities of the machine's usual C compiler are
used, but this cannot be done directly in cross-compilation.  You must make
your own arrangements to provide suitable library functions for
cross-compilation.  The embedded targets \fBsparc\-*\-aout\fR and
\&\fBsparclite\-*\-*\fR do provide software floating point support.
.Sp
\&\fB\-msoft\-float\fR changes the calling convention in the output file;
therefore, it is only useful if you compile \fIall\fR of a program with
this option.  In particular, you need to compile \fIlibgcc.a\fR, the
library that comes with \s-1GCC\s0, with \fB\-msoft\-float\fR in order for
this to work.
.IP "\fB\-mhard\-quad\-float\fR" 4
.IX Item "-mhard-quad-float"
Generate output containing quad-word (long double) floating point
instructions.
.IP "\fB\-msoft\-quad\-float\fR" 4
.IX Item "-msoft-quad-float"
Generate output containing library calls for quad-word (long double)
floating point instructions.  The functions called are those specified
in the \s-1SPARC\s0 \s-1ABI\s0.  This is the default.
.Sp
As of this writing, there are no \s-1SPARC\s0 implementations that have hardware
support for the quad-word floating point instructions.  They all invoke
a trap handler for one of these instructions, and then the trap handler
emulates the effect of the instruction.  Because of the trap handler overhead,
this is much slower than calling the \s-1ABI\s0 library routines.  Thus the
\&\fB\-msoft\-quad\-float\fR option is the default.
.IP "\fB\-mno\-unaligned\-doubles\fR" 4
.IX Item "-mno-unaligned-doubles"
.PD 0
.IP "\fB\-munaligned\-doubles\fR" 4
.IX Item "-munaligned-doubles"
.PD
Assume that doubles have 8 byte alignment.  This is the default.
.Sp
With \fB\-munaligned\-doubles\fR, \s-1GCC\s0 assumes that doubles have 8 byte
alignment only if they are contained in another type, or if they have an
absolute address.  Otherwise, it assumes they have 4 byte alignment.
Specifying this option avoids some rare compatibility problems with code
generated by other compilers.  It is not the default because it results
in a performance loss, especially for floating point code.
.IP "\fB\-mno\-faster\-structs\fR" 4
.IX Item "-mno-faster-structs"
.PD 0
.IP "\fB\-mfaster\-structs\fR" 4
.IX Item "-mfaster-structs"
.PD
With \fB\-mfaster\-structs\fR, the compiler assumes that structures
should have 8 byte alignment.  This enables the use of pairs of
\&\f(CW\*(C`ldd\*(C'\fR and \f(CW\*(C`std\*(C'\fR instructions for copies in structure
assignment, in place of twice as many \f(CW\*(C`ld\*(C'\fR and \f(CW\*(C`st\*(C'\fR pairs.
However, the use of this changed alignment directly violates the \s-1SPARC\s0
\&\s-1ABI\s0.  Thus, it's intended only for use on targets where the developer
acknowledges that their resulting code will not be directly in line with
the rules of the \s-1ABI\s0.
.IP "\fB\-mimpure\-text\fR" 4
.IX Item "-mimpure-text"
\&\fB\-mimpure\-text\fR, used in addition to \fB\-shared\fR, tells
the compiler to not pass \fB\-z text\fR to the linker when linking a
shared object.  Using this option, you can link position-dependent
code into a shared object.
.Sp
\&\fB\-mimpure\-text\fR suppresses the \*(L"relocations remain against
allocatable but non-writable sections\*(R" linker error message.
However, the necessary relocations will trigger copy-on-write, and the
shared object is not actually shared across processes.  Instead of
using \fB\-mimpure\-text\fR, you should compile all source code with
\&\fB\-fpic\fR or \fB\-fPIC\fR.
.Sp
This option is only available on SunOS and Solaris.
.IP "\fB\-mcpu=\fR\fIcpu_type\fR" 4
.IX Item "-mcpu=cpu_type"
Set the instruction set, register set, and instruction scheduling parameters
for machine type \fIcpu_type\fR.  Supported values for \fIcpu_type\fR are
\&\fBv7\fR, \fBcypress\fR, \fBv8\fR, \fBsupersparc\fR, \fBsparclite\fR,
\&\fBf930\fR, \fBf934\fR, \fBhypersparc\fR, \fBsparclite86x\fR,
\&\fBsparclet\fR, \fBtsc701\fR, \fBv9\fR, \fBultrasparc\fR,
\&\fBultrasparc3\fR, \fBniagara\fR and \fBniagara2\fR.
.Sp
Default instruction scheduling parameters are used for values that select
an architecture and not an implementation.  These are \fBv7\fR, \fBv8\fR,
\&\fBsparclite\fR, \fBsparclet\fR, \fBv9\fR.
.Sp
Here is a list of each supported architecture and their supported
implementations.
.Sp
.Vb 5
\&            v7:             cypress
\&            v8:             supersparc, hypersparc
\&            sparclite:      f930, f934, sparclite86x
\&            sparclet:       tsc701
\&            v9:             ultrasparc, ultrasparc3, niagara, niagara2
.Ve
.Sp
By default (unless configured otherwise), \s-1GCC\s0 generates code for the V7
variant of the \s-1SPARC\s0 architecture.  With \fB\-mcpu=cypress\fR, the compiler
additionally optimizes it for the Cypress \s-1CY7C602\s0 chip, as used in the
SPARCStation/SPARCServer 3xx series.  This is also appropriate for the older
SPARCStation 1, 2, \s-1IPX\s0 etc.
.Sp
With \fB\-mcpu=v8\fR, \s-1GCC\s0 generates code for the V8 variant of the \s-1SPARC\s0
architecture.  The only difference from V7 code is that the compiler emits
the integer multiply and integer divide instructions which exist in \s-1SPARC\-V8\s0
but not in \s-1SPARC\-V7\s0.  With \fB\-mcpu=supersparc\fR, the compiler additionally
optimizes it for the SuperSPARC chip, as used in the SPARCStation 10, 1000 and
2000 series.
.Sp
With \fB\-mcpu=sparclite\fR, \s-1GCC\s0 generates code for the SPARClite variant of
the \s-1SPARC\s0 architecture.  This adds the integer multiply, integer divide step
and scan (\f(CW\*(C`ffs\*(C'\fR) instructions which exist in SPARClite but not in \s-1SPARC\-V7\s0.
With \fB\-mcpu=f930\fR, the compiler additionally optimizes it for the
Fujitsu \s-1MB86930\s0 chip, which is the original SPARClite, with no \s-1FPU\s0.  With
\&\fB\-mcpu=f934\fR, the compiler additionally optimizes it for the Fujitsu
\&\s-1MB86934\s0 chip, which is the more recent SPARClite with \s-1FPU\s0.
.Sp
With \fB\-mcpu=sparclet\fR, \s-1GCC\s0 generates code for the SPARClet variant of
the \s-1SPARC\s0 architecture.  This adds the integer multiply, multiply/accumulate,
integer divide step and scan (\f(CW\*(C`ffs\*(C'\fR) instructions which exist in SPARClet
but not in \s-1SPARC\-V7\s0.  With \fB\-mcpu=tsc701\fR, the compiler additionally
optimizes it for the \s-1TEMIC\s0 SPARClet chip.
.Sp
With \fB\-mcpu=v9\fR, \s-1GCC\s0 generates code for the V9 variant of the \s-1SPARC\s0
architecture.  This adds 64\-bit integer and floating-point move instructions,
3 additional floating-point condition code registers and conditional move
instructions.  With \fB\-mcpu=ultrasparc\fR, the compiler additionally
optimizes it for the Sun UltraSPARC I/II/IIi chips.  With
\&\fB\-mcpu=ultrasparc3\fR, the compiler additionally optimizes it for the
Sun UltraSPARC III/III+/IIIi/IIIi+/IV/IV+ chips.  With
\&\fB\-mcpu=niagara\fR, the compiler additionally optimizes it for
Sun UltraSPARC T1 chips.  With \fB\-mcpu=niagara2\fR, the compiler
additionally optimizes it for Sun UltraSPARC T2 chips.
.IP "\fB\-mtune=\fR\fIcpu_type\fR" 4
.IX Item "-mtune=cpu_type"
Set the instruction scheduling parameters for machine type
\&\fIcpu_type\fR, but do not set the instruction set or register set that the
option \fB\-mcpu=\fR\fIcpu_type\fR would.
.Sp
The same values for \fB\-mcpu=\fR\fIcpu_type\fR can be used for
\&\fB\-mtune=\fR\fIcpu_type\fR, but the only useful values are those
that select a particular cpu implementation.  Those are \fBcypress\fR,
\&\fBsupersparc\fR, \fBhypersparc\fR, \fBf930\fR, \fBf934\fR,
\&\fBsparclite86x\fR, \fBtsc701\fR, \fBultrasparc\fR,
\&\fBultrasparc3\fR, \fBniagara\fR, and \fBniagara2\fR.
.IP "\fB\-mv8plus\fR" 4
.IX Item "-mv8plus"
.PD 0
.IP "\fB\-mno\-v8plus\fR" 4
.IX Item "-mno-v8plus"
.PD
With \fB\-mv8plus\fR, \s-1GCC\s0 generates code for the \s-1SPARC\-V8+\s0 \s-1ABI\s0.  The
difference from the V8 \s-1ABI\s0 is that the global and out registers are
considered 64\-bit wide.  This is enabled by default on Solaris in 32\-bit
mode for all \s-1SPARC\-V9\s0 processors.
.IP "\fB\-mvis\fR" 4
.IX Item "-mvis"
.PD 0
.IP "\fB\-mno\-vis\fR" 4
.IX Item "-mno-vis"
.PD
With \fB\-mvis\fR, \s-1GCC\s0 generates code that takes advantage of the UltraSPARC
Visual Instruction Set extensions.  The default is \fB\-mno\-vis\fR.
.PP
These \fB\-m\fR options are supported in addition to the above
on \s-1SPARC\-V9\s0 processors in 64\-bit environments:
.IP "\fB\-mlittle\-endian\fR" 4
.IX Item "-mlittle-endian"
Generate code for a processor running in little-endian mode.  It is only
available for a few configurations and most notably not on Solaris and Linux.
.IP "\fB\-m32\fR" 4
.IX Item "-m32"
.PD 0
.IP "\fB\-m64\fR" 4
.IX Item "-m64"
.PD
Generate code for a 32\-bit or 64\-bit environment.
The 32\-bit environment sets int, long and pointer to 32 bits.
The 64\-bit environment sets int to 32 bits and long and pointer
to 64 bits.
.IP "\fB\-mcmodel=medlow\fR" 4
.IX Item "-mcmodel=medlow"
Generate code for the Medium/Low code model: 64\-bit addresses, programs
must be linked in the low 32 bits of memory.  Programs can be statically
or dynamically linked.
.IP "\fB\-mcmodel=medmid\fR" 4
.IX Item "-mcmodel=medmid"
Generate code for the Medium/Middle code model: 64\-bit addresses, programs
must be linked in the low 44 bits of memory, the text and data segments must
be less than 2GB in size and the data segment must be located within 2GB of
the text segment.
.IP "\fB\-mcmodel=medany\fR" 4
.IX Item "-mcmodel=medany"
Generate code for the Medium/Anywhere code model: 64\-bit addresses, programs
may be linked anywhere in memory, the text and data segments must be less
than 2GB in size and the data segment must be located within 2GB of the
text segment.
.IP "\fB\-mcmodel=embmedany\fR" 4
.IX Item "-mcmodel=embmedany"
Generate code for the Medium/Anywhere code model for embedded systems:
64\-bit addresses, the text and data segments must be less than 2GB in
size, both starting anywhere in memory (determined at link time).  The
global register \f(CW%g4\fR points to the base of the data segment.  Programs
are statically linked and \s-1PIC\s0 is not supported.
.IP "\fB\-mstack\-bias\fR" 4
.IX Item "-mstack-bias"
.PD 0
.IP "\fB\-mno\-stack\-bias\fR" 4
.IX Item "-mno-stack-bias"
.PD
With \fB\-mstack\-bias\fR, \s-1GCC\s0 assumes that the stack pointer, and
frame pointer if present, are offset by \-2047 which must be added back
when making stack frame references.  This is the default in 64\-bit mode.
Otherwise, assume no such offset is present.
.PP
These switches are supported in addition to the above on Solaris:
.IP "\fB\-threads\fR" 4
.IX Item "-threads"
Add support for multithreading using the Solaris threads library.  This
option sets flags for both the preprocessor and linker.  This option does
not affect the thread safety of object code produced by the compiler or
that of libraries supplied with it.
.IP "\fB\-pthreads\fR" 4
.IX Item "-pthreads"
Add support for multithreading using the \s-1POSIX\s0 threads library.  This
option sets flags for both the preprocessor and linker.  This option does
not affect the thread safety of object code produced  by the compiler or
that of libraries supplied with it.
.IP "\fB\-pthread\fR" 4
.IX Item "-pthread"
This is a synonym for \fB\-pthreads\fR.
.PP
\fI\s-1SPU\s0 Options\fR
.IX Subsection "SPU Options"
.PP
These \fB\-m\fR options are supported on the \s-1SPU:\s0
.IP "\fB\-mwarn\-reloc\fR" 4
.IX Item "-mwarn-reloc"
.PD 0
.IP "\fB\-merror\-reloc\fR" 4
.IX Item "-merror-reloc"
.PD
The loader for \s-1SPU\s0 does not handle dynamic relocations.  By default, \s-1GCC\s0
will give an error when it generates code that requires a dynamic
relocation.  \fB\-mno\-error\-reloc\fR disables the error,
\&\fB\-mwarn\-reloc\fR will generate a warning instead.
.IP "\fB\-msafe\-dma\fR" 4
.IX Item "-msafe-dma"
.PD 0
.IP "\fB\-munsafe\-dma\fR" 4
.IX Item "-munsafe-dma"
.PD
Instructions which initiate or test completion of \s-1DMA\s0 must not be
reordered with respect to loads and stores of the memory which is being
accessed.  Users typically address this problem using the volatile
keyword, but that can lead to inefficient code in places where the
memory is known to not change.  Rather than mark the memory as volatile
we treat the \s-1DMA\s0 instructions as potentially effecting all memory.  With
\&\fB\-munsafe\-dma\fR users must use the volatile keyword to protect
memory accesses.
.IP "\fB\-mbranch\-hints\fR" 4
.IX Item "-mbranch-hints"
By default, \s-1GCC\s0 will generate a branch hint instruction to avoid
pipeline stalls for always taken or probably taken branches.  A hint
will not be generated closer than 8 instructions away from its branch.
There is little reason to disable them, except for debugging purposes,
or to make an object a little bit smaller.
.IP "\fB\-msmall\-mem\fR" 4
.IX Item "-msmall-mem"
.PD 0
.IP "\fB\-mlarge\-mem\fR" 4
.IX Item "-mlarge-mem"
.PD
By default, \s-1GCC\s0 generates code assuming that addresses are never larger
than 18 bits.  With \fB\-mlarge\-mem\fR code is generated that assumes
a full 32 bit address.
.IP "\fB\-mstdmain\fR" 4
.IX Item "-mstdmain"
By default, \s-1GCC\s0 links against startup code that assumes the SPU-style
main function interface (which has an unconventional parameter list).
With \fB\-mstdmain\fR, \s-1GCC\s0 will link your program against startup
code that assumes a C99\-style interface to \f(CW\*(C`main\*(C'\fR, including a
local copy of \f(CW\*(C`argv\*(C'\fR strings.
.IP "\fB\-mfixed\-range=\fR\fIregister-range\fR" 4
.IX Item "-mfixed-range=register-range"
Generate code treating the given register range as fixed registers.
A fixed register is one that the register allocator can not use.  This is
useful when compiling kernel code.  A register range is specified as
two registers separated by a dash.  Multiple register ranges can be
specified separated by a comma.
.IP "\fB\-mdual\-nops\fR" 4
.IX Item "-mdual-nops"
.PD 0
.IP "\fB\-mdual\-nops=\fR\fIn\fR" 4
.IX Item "-mdual-nops=n"
.PD
By default, \s-1GCC\s0 will insert nops to increase dual issue when it expects
it to increase performance.  \fIn\fR can be a value from 0 to 10.  A
smaller \fIn\fR will insert fewer nops.  10 is the default, 0 is the
same as \fB\-mno\-dual\-nops\fR.  Disabled with \fB\-Os\fR.
.IP "\fB\-mhint\-max\-nops=\fR\fIn\fR" 4
.IX Item "-mhint-max-nops=n"
Maximum number of nops to insert for a branch hint.  A branch hint must
be at least 8 instructions away from the branch it is effecting.  \s-1GCC\s0
will insert up to \fIn\fR nops to enforce this, otherwise it will not
generate the branch hint.
.IP "\fB\-mhint\-max\-distance=\fR\fIn\fR" 4
.IX Item "-mhint-max-distance=n"
The encoding of the branch hint instruction limits the hint to be within
256 instructions of the branch it is effecting.  By default, \s-1GCC\s0 makes
sure it is within 125.
.IP "\fB\-msafe\-hints\fR" 4
.IX Item "-msafe-hints"
Work around a hardware bug which causes the \s-1SPU\s0 to stall indefinitely.
By default, \s-1GCC\s0 will insert the \f(CW\*(C`hbrp\*(C'\fR instruction to make sure
this stall won't happen.
.PP
\fIOptions for System V\fR
.IX Subsection "Options for System V"
.PP
These additional options are available on System V Release 4 for
compatibility with other compilers on those systems:
.IP "\fB\-G\fR" 4
.IX Item "-G"
Create a shared object.
It is recommended that \fB\-symbolic\fR or \fB\-shared\fR be used instead.
.IP "\fB\-Qy\fR" 4
.IX Item "-Qy"
Identify the versions of each tool used by the compiler, in a
\&\f(CW\*(C`.ident\*(C'\fR assembler directive in the output.
.IP "\fB\-Qn\fR" 4
.IX Item "-Qn"
Refrain from adding \f(CW\*(C`.ident\*(C'\fR directives to the output file (this is
the default).
.IP "\fB\-YP,\fR\fIdirs\fR" 4
.IX Item "-YP,dirs"
Search the directories \fIdirs\fR, and no others, for libraries
specified with \fB\-l\fR.
.IP "\fB\-Ym,\fR\fIdir\fR" 4
.IX Item "-Ym,dir"
Look in the directory \fIdir\fR to find the M4 preprocessor.
The assembler uses this option.
.PP
\fIV850 Options\fR
.IX Subsection "V850 Options"
.PP
These \fB\-m\fR options are defined for V850 implementations:
.IP "\fB\-mlong\-calls\fR" 4
.IX Item "-mlong-calls"
.PD 0
.IP "\fB\-mno\-long\-calls\fR" 4
.IX Item "-mno-long-calls"
.PD
Treat all calls as being far away (near).  If calls are assumed to be
far away, the compiler will always load the functions address up into a
register, and call indirect through the pointer.
.IP "\fB\-mno\-ep\fR" 4
.IX Item "-mno-ep"
.PD 0
.IP "\fB\-mep\fR" 4
.IX Item "-mep"
.PD
Do not optimize (do optimize) basic blocks that use the same index
pointer 4 or more times to copy pointer into the \f(CW\*(C`ep\*(C'\fR register, and
use the shorter \f(CW\*(C`sld\*(C'\fR and \f(CW\*(C`sst\*(C'\fR instructions.  The \fB\-mep\fR
option is on by default if you optimize.
.IP "\fB\-mno\-prolog\-function\fR" 4
.IX Item "-mno-prolog-function"
.PD 0
.IP "\fB\-mprolog\-function\fR" 4
.IX Item "-mprolog-function"
.PD
Do not use (do use) external functions to save and restore registers
at the prologue and epilogue of a function.  The external functions
are slower, but use less code space if more than one function saves
the same number of registers.  The \fB\-mprolog\-function\fR option
is on by default if you optimize.
.IP "\fB\-mspace\fR" 4
.IX Item "-mspace"
Try to make the code as small as possible.  At present, this just turns
on the \fB\-mep\fR and \fB\-mprolog\-function\fR options.
.IP "\fB\-mtda=\fR\fIn\fR" 4
.IX Item "-mtda=n"
Put static or global variables whose size is \fIn\fR bytes or less into
the tiny data area that register \f(CW\*(C`ep\*(C'\fR points to.  The tiny data
area can hold up to 256 bytes in total (128 bytes for byte references).
.IP "\fB\-msda=\fR\fIn\fR" 4
.IX Item "-msda=n"
Put static or global variables whose size is \fIn\fR bytes or less into
the small data area that register \f(CW\*(C`gp\*(C'\fR points to.  The small data
area can hold up to 64 kilobytes.
.IP "\fB\-mzda=\fR\fIn\fR" 4
.IX Item "-mzda=n"
Put static or global variables whose size is \fIn\fR bytes or less into
the first 32 kilobytes of memory.
.IP "\fB\-mv850\fR" 4
.IX Item "-mv850"
Specify that the target processor is the V850.
.IP "\fB\-mbig\-switch\fR" 4
.IX Item "-mbig-switch"
Generate code suitable for big switch tables.  Use this option only if
the assembler/linker complain about out of range branches within a switch
table.
.IP "\fB\-mapp\-regs\fR" 4
.IX Item "-mapp-regs"
This option will cause r2 and r5 to be used in the code generated by
the compiler.  This setting is the default.
.IP "\fB\-mno\-app\-regs\fR" 4
.IX Item "-mno-app-regs"
This option will cause r2 and r5 to be treated as fixed registers.
.IP "\fB\-mv850e1\fR" 4
.IX Item "-mv850e1"
Specify that the target processor is the V850E1.  The preprocessor
constants \fB_\|_v850e1_\|_\fR and \fB_\|_v850e_\|_\fR will be defined if
this option is used.
.IP "\fB\-mv850e\fR" 4
.IX Item "-mv850e"
Specify that the target processor is the V850E.  The preprocessor
constant \fB_\|_v850e_\|_\fR will be defined if this option is used.
.Sp
If neither \fB\-mv850\fR nor \fB\-mv850e\fR nor \fB\-mv850e1\fR
are defined then a default target processor will be chosen and the
relevant \fB_\|_v850*_\|_\fR preprocessor constant will be defined.
.Sp
The preprocessor constants \fB_\|_v850\fR and \fB_\|_v851_\|_\fR are always
defined, regardless of which processor variant is the target.
.IP "\fB\-mdisable\-callt\fR" 4
.IX Item "-mdisable-callt"
This option will suppress generation of the \s-1CALLT\s0 instruction for the
v850e and v850e1 flavors of the v850 architecture.  The default is
\&\fB\-mno\-disable\-callt\fR which allows the \s-1CALLT\s0 instruction to be used.
.PP
\fI\s-1VAX\s0 Options\fR
.IX Subsection "VAX Options"
.PP
These \fB\-m\fR options are defined for the \s-1VAX:\s0
.IP "\fB\-munix\fR" 4
.IX Item "-munix"
Do not output certain jump instructions (\f(CW\*(C`aobleq\*(C'\fR and so on)
that the Unix assembler for the \s-1VAX\s0 cannot handle across long
ranges.
.IP "\fB\-mgnu\fR" 4
.IX Item "-mgnu"
Do output those jump instructions, on the assumption that you
will assemble with the \s-1GNU\s0 assembler.
.IP "\fB\-mg\fR" 4
.IX Item "-mg"
Output code for g\-format floating point numbers instead of d\-format.
.PP
\fIVxWorks Options\fR
.IX Subsection "VxWorks Options"
.PP
The options in this section are defined for all VxWorks targets.
Options specific to the target hardware are listed with the other
options for that target.
.IP "\fB\-mrtp\fR" 4
.IX Item "-mrtp"
\&\s-1GCC\s0 can generate code for both VxWorks kernels and real time processes
(RTPs).  This option switches from the former to the latter.  It also
defines the preprocessor macro \f(CW\*(C`_\|_RTP_\|_\*(C'\fR.
.IP "\fB\-non\-static\fR" 4
.IX Item "-non-static"
Link an \s-1RTP\s0 executable against shared libraries rather than static
libraries.  The options \fB\-static\fR and \fB\-shared\fR can
also be used for RTPs; \fB\-static\fR
is the default.
.IP "\fB\-Bstatic\fR" 4
.IX Item "-Bstatic"
.PD 0
.IP "\fB\-Bdynamic\fR" 4
.IX Item "-Bdynamic"
.PD
These options are passed down to the linker.  They are defined for
compatibility with Diab.
.IP "\fB\-Xbind\-lazy\fR" 4
.IX Item "-Xbind-lazy"
Enable lazy binding of function calls.  This option is equivalent to
\&\fB\-Wl,\-z,now\fR and is defined for compatibility with Diab.
.IP "\fB\-Xbind\-now\fR" 4
.IX Item "-Xbind-now"
Disable lazy binding of function calls.  This option is the default and
is defined for compatibility with Diab.
.PP
\fIx86\-64 Options\fR
.IX Subsection "x86-64 Options"
.PP
These are listed under
.PP
\fIXstormy16 Options\fR
.IX Subsection "Xstormy16 Options"
.PP
These options are defined for Xstormy16:
.IP "\fB\-msim\fR" 4
.IX Item "-msim"
Choose startup files and linker script suitable for the simulator.
.PP
\fIXtensa Options\fR
.IX Subsection "Xtensa Options"
.PP
These options are supported for Xtensa targets:
.IP "\fB\-mconst16\fR" 4
.IX Item "-mconst16"
.PD 0
.IP "\fB\-mno\-const16\fR" 4
.IX Item "-mno-const16"
.PD
Enable or disable use of \f(CW\*(C`CONST16\*(C'\fR instructions for loading
constant values.  The \f(CW\*(C`CONST16\*(C'\fR instruction is currently not a
standard option from Tensilica.  When enabled, \f(CW\*(C`CONST16\*(C'\fR
instructions are always used in place of the standard \f(CW\*(C`L32R\*(C'\fR
instructions.  The use of \f(CW\*(C`CONST16\*(C'\fR is enabled by default only if
the \f(CW\*(C`L32R\*(C'\fR instruction is not available.
.IP "\fB\-mfused\-madd\fR" 4
.IX Item "-mfused-madd"
.PD 0
.IP "\fB\-mno\-fused\-madd\fR" 4
.IX Item "-mno-fused-madd"
.PD
Enable or disable use of fused multiply/add and multiply/subtract
instructions in the floating-point option.  This has no effect if the
floating-point option is not also enabled.  Disabling fused multiply/add
and multiply/subtract instructions forces the compiler to use separate
instructions for the multiply and add/subtract operations.  This may be
desirable in some cases where strict \s-1IEEE\s0 754\-compliant results are
required: the fused multiply add/subtract instructions do not round the
intermediate result, thereby producing results with \fImore\fR bits of
precision than specified by the \s-1IEEE\s0 standard.  Disabling fused multiply
add/subtract instructions also ensures that the program output is not
sensitive to the compiler's ability to combine multiply and add/subtract
operations.
.IP "\fB\-mtext\-section\-literals\fR" 4
.IX Item "-mtext-section-literals"
.PD 0
.IP "\fB\-mno\-text\-section\-literals\fR" 4
.IX Item "-mno-text-section-literals"
.PD
Control the treatment of literal pools.  The default is
\&\fB\-mno\-text\-section\-literals\fR, which places literals in a separate
section in the output file.  This allows the literal pool to be placed
in a data \s-1RAM/ROM\s0, and it also allows the linker to combine literal
pools from separate object files to remove redundant literals and
improve code size.  With \fB\-mtext\-section\-literals\fR, the literals
are interspersed in the text section in order to keep them as close as
possible to their references.  This may be necessary for large assembly
files.
.IP "\fB\-mtarget\-align\fR" 4
.IX Item "-mtarget-align"
.PD 0
.IP "\fB\-mno\-target\-align\fR" 4
.IX Item "-mno-target-align"
.PD
When this option is enabled, \s-1GCC\s0 instructs the assembler to
automatically align instructions to reduce branch penalties at the
expense of some code density.  The assembler attempts to widen density
instructions to align branch targets and the instructions following call
instructions.  If there are not enough preceding safe density
instructions to align a target, no widening will be performed.  The
default is \fB\-mtarget\-align\fR.  These options do not affect the
treatment of auto-aligned instructions like \f(CW\*(C`LOOP\*(C'\fR, which the
assembler will always align, either by widening density instructions or
by inserting no-op instructions.
.IP "\fB\-mlongcalls\fR" 4
.IX Item "-mlongcalls"
.PD 0
.IP "\fB\-mno\-longcalls\fR" 4
.IX Item "-mno-longcalls"
.PD
When this option is enabled, \s-1GCC\s0 instructs the assembler to translate
direct calls to indirect calls unless it can determine that the target
of a direct call is in the range allowed by the call instruction.  This
translation typically occurs for calls to functions in other source
files.  Specifically, the assembler translates a direct \f(CW\*(C`CALL\*(C'\fR
instruction into an \f(CW\*(C`L32R\*(C'\fR followed by a \f(CW\*(C`CALLX\*(C'\fR instruction.
The default is \fB\-mno\-longcalls\fR.  This option should be used in
programs where the call target can potentially be out of range.  This
option is implemented in the assembler, not the compiler, so the
assembly code generated by \s-1GCC\s0 will still show direct call
instructions\-\-\-look at the disassembled object code to see the actual
instructions.  Note that the assembler will use an indirect call for
every cross-file call, not just those that really will be out of range.
.PP
\fIzSeries Options\fR
.IX Subsection "zSeries Options"
.PP
These are listed under
.Sh "Options for Code Generation Conventions"
.IX Subsection "Options for Code Generation Conventions"
These machine-independent options control the interface conventions
used in code generation.
.PP
Most of them have both positive and negative forms; the negative form
of \fB\-ffoo\fR would be \fB\-fno\-foo\fR.  In the table below, only
one of the forms is listed\-\-\-the one which is not the default.  You
can figure out the other form by either removing \fBno\-\fR or adding
it.
.IP "\fB\-fbounds\-check\fR" 4
.IX Item "-fbounds-check"
For front-ends that support it, generate additional code to check that
indices used to access arrays are within the declared range.  This is
currently only supported by the Java and Fortran front-ends, where
this option defaults to true and false respectively.
.IP "\fB\-ftrapv\fR" 4
.IX Item "-ftrapv"
This option generates traps for signed overflow on addition, subtraction,
multiplication operations.
.IP "\fB\-fwrapv\fR" 4
.IX Item "-fwrapv"
This option instructs the compiler to assume that signed arithmetic
overflow of addition, subtraction and multiplication wraps around
using twos-complement representation.  This flag enables some optimizations
and disables others.  This option is enabled by default for the Java
front-end, as required by the Java language specification.
.IP "\fB\-fexceptions\fR" 4
.IX Item "-fexceptions"
Enable exception handling.  Generates extra code needed to propagate
exceptions.  For some targets, this implies \s-1GCC\s0 will generate frame
unwind information for all functions, which can produce significant data
size overhead, although it does not affect execution.  If you do not
specify this option, \s-1GCC\s0 will enable it by default for languages like
\&\*(C+ which normally require exception handling, and disable it for
languages like C that do not normally require it.  However, you may need
to enable this option when compiling C code that needs to interoperate
properly with exception handlers written in \*(C+.  You may also wish to
disable this option if you are compiling older \*(C+ programs that don't
use exception handling.
.IP "\fB\-fnon\-call\-exceptions\fR" 4
.IX Item "-fnon-call-exceptions"
Generate code that allows trapping instructions to throw exceptions.
Note that this requires platform-specific runtime support that does
not exist everywhere.  Moreover, it only allows \fItrapping\fR
instructions to throw exceptions, i.e. memory references or floating
point instructions.  It does not allow exceptions to be thrown from
arbitrary signal handlers such as \f(CW\*(C`SIGALRM\*(C'\fR.
.IP "\fB\-funwind\-tables\fR" 4
.IX Item "-funwind-tables"
Similar to \fB\-fexceptions\fR, except that it will just generate any needed
static data, but will not affect the generated code in any other way.
You will normally not enable this option; instead, a language processor
that needs this handling would enable it on your behalf.
.IP "\fB\-fasynchronous\-unwind\-tables\fR" 4
.IX Item "-fasynchronous-unwind-tables"
Generate unwind table in dwarf2 format, if supported by target machine.  The
table is exact at each instruction boundary, so it can be used for stack
unwinding from asynchronous events (such as debugger or garbage collector).
.IP "\fB\-fpcc\-struct\-return\fR" 4
.IX Item "-fpcc-struct-return"
Return \*(L"short\*(R" \f(CW\*(C`struct\*(C'\fR and \f(CW\*(C`union\*(C'\fR values in memory like
longer ones, rather than in registers.  This convention is less
efficient, but it has the advantage of allowing intercallability between
GCC-compiled files and files compiled with other compilers, particularly
the Portable C Compiler (pcc).
.Sp
The precise convention for returning structures in memory depends
on the target configuration macros.
.Sp
Short structures and unions are those whose size and alignment match
that of some integer type.
.Sp
\&\fBWarning:\fR code compiled with the \fB\-fpcc\-struct\-return\fR
switch is not binary compatible with code compiled with the
\&\fB\-freg\-struct\-return\fR switch.
Use it to conform to a non-default application binary interface.
.IP "\fB\-freg\-struct\-return\fR" 4
.IX Item "-freg-struct-return"
Return \f(CW\*(C`struct\*(C'\fR and \f(CW\*(C`union\*(C'\fR values in registers when possible.
This is more efficient for small structures than
\&\fB\-fpcc\-struct\-return\fR.
.Sp
If you specify neither \fB\-fpcc\-struct\-return\fR nor
\&\fB\-freg\-struct\-return\fR, \s-1GCC\s0 defaults to whichever convention is
standard for the target.  If there is no standard convention, \s-1GCC\s0
defaults to \fB\-fpcc\-struct\-return\fR, except on targets where \s-1GCC\s0 is
the principal compiler.  In those cases, we can choose the standard, and
we chose the more efficient register return alternative.
.Sp
\&\fBWarning:\fR code compiled with the \fB\-freg\-struct\-return\fR
switch is not binary compatible with code compiled with the
\&\fB\-fpcc\-struct\-return\fR switch.
Use it to conform to a non-default application binary interface.
.IP "\fB\-fshort\-enums\fR" 4
.IX Item "-fshort-enums"
Allocate to an \f(CW\*(C`enum\*(C'\fR type only as many bytes as it need