@param first beginning of the character sequence.
       * @param last  one-past-the-end of the character sequence.
       *
       * @returns an unspecified value that represents the character
       * classification named by the character sequence designated by the
       * iterator range [first, last). The value returned shall be independent
       * of the case of the characters in the character sequence. If the name
       * is not recognized then returns a value that compares equal to 0.
       *
       * At least the following names (or their wide-character equivalent) are
       * supported.
       * - d
       * - w
       * - s
       * - alnum
       * - alpha
       * - blank
       * - cntrl
       * - digit
       * - graph
       * - lower
       * - print
       * - punct
       * - space
       * - upper
       * - xdigit
       *
       * @todo Implement this function.
       */
      template<typename _Fwd_iter>
        char_class_type
        lookup_classname(_Fwd_iter __first, _Fwd_iter __last) const
        { return 0; }

      /**
       * @brief Determines if @p c is a member of an identified class.
       *
       * @param c a character.
       * @param f a class type (as returned from lookup_classname).
       *
       * @returns true if the character @p c is a member of the classification
       * represented by @p f, false otherwise.
       *
       * @throws std::bad_cast if the current locale does not have a ctype
       *         facet.
       */
      bool
      isctype(_Ch_type __c, char_class_type __f) const
      {
	using std::ctype;
	using std::use_facet;
	const ctype<_Ch_type>& __ctype(use_facet<
				       ctype<_Ch_type> >(_M_locale));
	
	if (__ctype.is(__c, __f))
	  return true;
	
	// special case of underscore in [[:w:]]
	if (__c == __ctype.widen('_'))
	  {
	    const char* const __wb[] = "w";
	    char_class_type __wt = this->lookup_classname(__wb,
							  __wb + sizeof(__wb));
	    if (__f | __wt)
	      return true;
	  }
      
	// special case of [[:space:]] in [[:blank:]]
	if (__c == __ctype.isspace(__c))
	  {
	    const char* const __bb[] = "blank";
	    char_class_type __bt = this->lookup_classname(__bb,
							  __bb + sizeof(__bb));
	    if (__f | __bt)
	      return true;
	  }
	
	return false;
      }

      /**
       * @brief Converts a digit to an int.
       *
       * @param ch    a character representing a digit.
       * @param radix the radix if the numeric conversion (limited to 8, 10,
       *              or 16).
       * 
       * @returns the value represented by the digit ch in base radix if the
       * character ch is a valid digit in base radix; otherwise returns -1.
       *
       * @todo Implement this function.
       */
      int
      value(_Ch_type __ch, int __radix) const;
      
      /**
       * @brief Imbues the regex_traits object with a copy of a new locale.
       *
       * @param loc A locale.
       *
       * @returns a copy of the previous locale in use by the regex_traits
       *          object.
       *
       * @note Calling imbue with a different locale than the one currently in
       *       use invalidates all cached data held by *this.
       */
      locale_type
      imbue(locale_type __loc)
      {
	std::swap(_M_locale, __loc);
	return __loc;
      }
      
      /**
       * @brief Gets a copy of the current locale in use by the regex_traits
       * object.
       */
      locale_type
      getloc() const
      { return _M_locale; }
      
    protected:
      locale_type _M_locale;
    };


  // [7.8] Class basic_regex
  /**
   * Objects of specializations of this class represent regular expressions
   * constructed from sequences of character type @p _Ch_type.
   *
   * Storage for the regular expression is allocated and deallocated as
   * necessary by the member functions of this class.
   */
  template<typename _Ch_type, typename _Rx_traits = regex_traits<_Ch_type> >
    class basic_regex
    {
    public:
      // types:
      typedef _Ch_type                              value_type;
      typedef regex_constants::syntax_option_type flag_type;
      typedef typename _Rx_traits::locale_type  locale_type;
      typedef typename _Rx_traits::string_type  string_type;

      // [7.8.1] constants
      static const regex_constants::syntax_option_type icase
        = regex_constants::icase;
      static const regex_constants::syntax_option_type nosubs
        = regex_constants::nosubs;
      static const regex_constants::syntax_option_type optimize
        = regex_constants::optimize;
      static const regex_constants::syntax_option_type collate
        = regex_constants::collate;
      static const regex_constants::syntax_option_type ECMAScript
        = regex_constants::ECMAScript;
      static const regex_constants::syntax_option_type basic
        = regex_constants::basic;
      static const regex_constants::syntax_option_type extended
        = regex_constants::extended;
      static const regex_constants::syntax_option_type awk
        = regex_constants::awk;
      static const regex_constants::syntax_option_type grep
        = regex_constants::grep;
      static const regex_constants::syntax_option_type egrep
        = regex_constants::egrep;

      // [7.8.2] construct/copy/destroy
      /**
       * Constructs a basic regular expression that does not match any
       * character sequence.
       */
      basic_regex()
      : _M_flags(regex_constants::ECMAScript), _M_pattern(), _M_mark_count(0)
      { _M_compile(); }

      /**
       * @brief Constructs a basic regular expression from the sequence
       * [p, p + char_traits<_Ch_type>::length(p)) interpreted according to the
       * flags in @p f.
       *
       * @param p A pointer to the start of a C-style null-terminated string
       *          containing a regular expression.
       * @param f Flags indicating the syntax rules and options.
       *
       * @throws regex_error if @p p is not a valid regular expression.
       */
      explicit
      basic_regex(const _Ch_type* __p,
		  flag_type __f = regex_constants::ECMAScript)
      : _M_flags(__f), _M_pattern(__p), _M_mark_count(0)
      { _M_compile(); }

      /**
       * @brief Constructs a basic regular expression from the sequence
       * [p, p + len) interpreted according to the flags in @p f.
       *
       * @param p   A pointer to the start of a string containing a regular
       *            expression.
       * @param len The length of the string containing the regular expression.
       * @param f   Flags indicating the syntax rules and options.
       *
       * @throws regex_error if @p p is not a valid regular expression.
       */
      basic_regex(const _Ch_type* __p, std::size_t __len, flag_type __f)
      : _M_flags(__f) , _M_pattern(__p, __len), _M_mark_count(0)
      { _M_compile(); }

      /**
       * @brief Copy-constructs a basic regular expression.
       *
       * @param rhs A @p regex object.
     */
      basic_regex(const basic_regex& __rhs)
      : _M_flags(__rhs._M_flags), _M_pattern(__rhs._M_pattern),
	_M_mark_count(__rhs._M_mark_count)
      { _M_compile(); }

      /**
       * @brief Constructs a basic regular expression from the string
       * @p interpreted according to the flags in @p f.
       *
       * @param p A string containing a regular expression.
       * @param f Flags indicating the syntax rules and options.
       *
       * @throws regex_error if @p p is not a valid regular expression.
       */
      template<typename _Ch_traits, typename _Ch_alloc>
        explicit
        basic_regex(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,
		    flag_type __f = regex_constants::ECMAScript)
	: _M_flags(__f), _M_pattern(__s), _M_mark_count(0)
        { _M_compile(); }

      /**
       * @brief Constructs a basic regular expression from the range
       * [first, last) interpreted according to the flags in @p f.
       *
       * @param first The start of a range containing a valid regular
       *              expression.
       * @param last  The end of a range containing a valid regular
       *              expression.
       * @param f     The format flags of the regular expression.
       *
       * @throws regex_error if @p p is not a valid regular expression.
       */
      template<typename _InputIterator>
        basic_regex(_InputIterator __first, _InputIterator __last, 
		    flag_type __f = regex_constants::ECMAScript)
	: _M_flags(__f), _M_pattern(__first, __last), _M_mark_count(0)
        { _M_compile(); }

      /**
       * @brief Destroys a basic regular expression.
       */
      ~basic_regex()
      { }
      
      /**
       * @brief Assigns one regular expression to another.
       */
      basic_regex&
      operator=(const basic_regex& __rhs)
      { return this->assign(__rhs); }

      /**
       * @brief Replaces a regular expression with a new one constructed from
       * a C-style null-terminated string.
       *
       * @param A pointer to the start of a null-terminated C-style string
       *        containing a regular expression.
       */
      basic_regex&
      operator=(const _Ch_type* __p)
      { return this->assign(__p, flags()); }
      
      /**
       * @brief Replaces a regular expression with a new one constructed from
       * a string.
       *
       * @param A pointer to a string containing a regular expression.
       */
      template<typename _Ch_typeraits, typename _Allocator>
        basic_regex&
        operator=(const basic_string<_Ch_type, _Ch_typeraits, _Allocator>& __s)
        { return this->assign(__s, flags()); }

      // [7.8.3] assign
      /**
       * @brief the real assignment operator.
       *
       * @param that Another regular expression object.
       */
      basic_regex&
      assign(const basic_regex& __that)
      {
	basic_regex __tmp(__that);
	this->swap(__tmp);
	return *this;
      }
      
      /**
       * @brief Assigns a new regular expression to a regex object from a
       * C-style null-terminated string containing a regular expression
       * pattern.
       *
       * @param p     A pointer to a C-style null-terminated string containing
       *              a regular expression pattern.
       * @param flags Syntax option flags.
       *
       * @throws regex_error if p does not contain a valid regular expression
       * pattern interpreted according to @p flags.  If regex_error is thrown,
       * *this remains unchanged.
       */
      basic_regex&
      assign(const _Ch_type* __p,
	     flag_type __flags = regex_constants::ECMAScript)
      { return this->assign(string_type(__p), __flags); }

      /**
       * @brief Assigns a new regular expression to a regex object from a
       * C-style string containing a regular expression pattern.
       *
       * @param p     A pointer to a C-style string containing a
       *              regular expression pattern.
       * @param len   The length of the regular expression pattern string.
       * @param flags Syntax option flags.
       *
       * @throws regex_error if p does not contain a valid regular expression
       * pattern interpreted according to @p flags.  If regex_error is thrown,
       * *this remains unchanged.
       */
      basic_regex&
      assign(const _Ch_type* __p, std::size_t __len, flag_type __flags)
      { return this->assign(string_type(__p, __len), __flags); }

      /**
       * @brief Assigns a new regular expression to a regex object from a 
       * string containing a regular expression pattern.
       *
       * @param s     A string containing a regular expression pattern.
       * @param flags Syntax option flags.
       *
       * @throws regex_error if p does not contain a valid regular expression
       * pattern interpreted according to @p flags.  If regex_error is thrown,
       * *this remains unchanged.
       */
      template<typename _Ch_typeraits, typename _Allocator>
        basic_regex&
        assign(const basic_string<_Ch_type, _Ch_typeraits, _Allocator>& __s,
	       flag_type __f = regex_constants::ECMAScript)
        { 
	  basic_regex __tmp(__s, __f);
	  this->swap(__tmp);
	  return *this;
	}

      /**
       * @brief Assigns a new regular expression to a regex object.
       *
       * @param first The start of a range containing a valid regular
       *              expression.
       * @param last  The end of a range containing a valid regular
       *              expression.
       * @param flags Syntax option flags.
       *
       * @throws regex_error if p does not contain a valid regular expression
       * pattern interpreted according to @p flags.  If regex_error is thrown,
       * *this remains unchanged.
       */
      template<typename _InputIterator>
        basic_regex&
        assign(_InputIterator __first, _InputIterator __last,
	       flag_type __flags = regex_constants::ECMAScript)
        { return this->assign(string_type(__first, __last), __flags); }

      // [7.8.4] const operations
      /**
       * @brief Gets the number of marked subexpressions within the regular
       * expression.
       */
      unsigned int
      mark_count() const
      { return _M_mark_count; }
      
      /**
       * @brief Gets the flags used to construct the regular expression
       * or in the last call to assign().
       */
      flag_type
      flags() const
      { return _M_flags; }
      
      // [7.8.5] locale
      /**
       * @brief Imbues the regular expression object with the given locale.
       *
       * @param loc A locale.
       */
      locale_type
      imbue(locale_type __loc)
      { return _M_traits.imbue(__loc); }
      
      /**
       * @brief Gets the locale currently imbued in the regular expression
       *        object.
       */
      locale_type
      getloc() const
      { return _M_traits.getloc(); }
      
      // [7.8.6] swap
      /**
       * @brief Swaps the contents of two regular expression objects.
       *
       * @param rhs Another regular expression object.
       */
      void
      swap(basic_regex& __rhs)
      {
	std::swap(_M_flags,      __rhs._M_flags);
	std::swap(_M_pattern,    __rhs._M_pattern);
	std::swap(_M_mark_count, __rhs._M_mark_count);
	std::swap(_M_traits,     __rhs._M_traits);
      }
      
    private:
      /**
       * @brief Compiles a regular expression pattern into a NFA.
       * @todo Implement this function.
       */
      void _M_compile()
      { }

    protected:
      flag_type    _M_flags;
      string_type  _M_pattern;
      unsigned int _M_mark_count;
      _Rx_traits   _M_traits;
    };
  
  typedef basic_regex<char>    regex;
#ifdef _GLIBCXX_USE_WCHAR_T
  typedef basic_regex<wchar_t> wregex;
#endif


  // [7.8.6] basic_regex swap
  /**
   * @brief Swaps the contents of two regular expression objects.
   * @param lhs First regular expression.
   * @param rhs Second regular expression.
   */
  template<typename _Ch_type, typename _Rx_traits>
    inline void
    swap(basic_regex<_Ch_type, _Rx_traits>& __lhs,
	 basic_regex<_Ch_type, _Rx_traits>& __rhs)
    { return __lhs.swap(__rhs); }


  // [7.9] Class template sub_match
  /**
   * A sequence of characters matched by a particular marked sub-expression.
   *
   * An object of this class is essentially a pair of iterators marking a
   * matched subexpression within a regular expression pattern match. Such
   * objects can be converted to and compared with std::basic_string objects
   * of a similar base character type as the pattern matched by the regular
   * expression.
   *
   * The iterators that make up the pair are the usual half-open interval
   * referencing the actual original pattern matched.
   */
  template<typename _BiIter>
    class sub_match : public std::pair<_BiIter, _BiIter>
    {
    public:
      typedef typename iterator_traits<_BiIter>::value_type      value_type;
      typedef typename iterator_traits<_BiIter>::difference_type
                                                            difference_type;
      typedef _BiIter                                              iterator;

    public:
      bool matched;
      
      /**
       * Gets the length of the matching sequence.
       */
      difference_type
      length() const
      { return this->matched ? std::distance(this->first, this->second) : 0; }

      /**
       * @brief Gets the matching sequence as a string.
       *
       * @returns the matching sequence as a string.
       *
       * This is the implicit conversion operator.  It is identical to the
       * str() member function except that it will want to pop up in
       * unexpected places and cause a great deal of confusion and cursing
       * from the unwary.
       */
      operator basic_string<value_type>() const
      {
	return this->matched
	  ? std::basic_string<value_type>(this->first, this->second)
	  : std::basic_string<value_type>();
      }
      
      /**
       * @brief Gets the matching sequence as a string.
       *
       * @returns the matching sequence as a string.
       */
      basic_string<value_type>
      str() const
      {
	return this->matched
	  ? std::basic_string<value_type>(this->first, this->second)
	  : std::basic_string<value_type>();
      }
      
      /**
       * @brief Compares this and another matched sequence.
       *
       * @param s Another matched sequence to compare to this one.
       *
       * @retval <0 this matched sequence will collate before @p s.
       * @retval =0 this matched sequence is equivalent to @p s.
       * @retval <0 this matched sequence will collate after @p s.
       */
      int
      compare(const sub_match& __s) const
      { return this->str().compare(__s.str()); }

      /**
       * @brief Compares this sub_match to a string.
       *
       * @param s A string to compare to this sub_match.
       *
       * @retval <0 this matched sequence will collate before @p s.
       * @retval =0 this matched sequence is equivalent to @p s.
       * @retval <0 this matched sequence will collate after @p s.
       */
      int
      compare(const basic_string<value_type>& __s) const
      { return this->str().compare(__s); }
      
      /**
       * @brief Compares this sub_match to a C-style string.
       *
       * @param s A C-style string to compare to this sub_match.
       *
       * @retval <0 this matched sequence will collate before @p s.
       * @retval =0 this matched sequence is equivalent to @p s.
       * @retval <0 this matched sequence will collate after @p s.
       */
      int
      compare(const value_type* __s) const
      { return this->str().compare(__s); }
    };
  
  
  typedef sub_match<const char*>             csub_match;
  typedef sub_match<string::const_iterator>  ssub_match;
#ifdef _GLIBCXX_USE_WCHAR_T
  typedef sub_match<const wchar_t*>          wcsub_match;
  typedef sub_match<wstring::const_iterator> wssub_match;
#endif

  // [7.9.2] sub_match non-member operators
  
  /**
   * @brief Tests the equivalence of two regular expression submatches.
   * @param lhs First regular expression submatch.
   * @param rhs Second regular expression submatch.
   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.
   */
  template<typename _BiIter>
    inline bool
    operator==(const sub_match<_BiIter>& __lhs,
	       const sub_match<_BiIter>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  /**
   * @brief Tests the inequivalence of two regular expression submatches.
   * @param lhs First regular expression submatch.
   * @param rhs Second regular expression submatch.
   * @returns true if @a lhs  is not equivalent to @a rhs, false otherwise.
   */
  template<typename _BiIter>
    inline bool
    operator!=(const sub_match<_BiIter>& __lhs,
	       const sub_match<_BiIter>& __rhs)
    { return __lhs.compare(__rhs) != 0; }

  /**
   * @brief Tests the ordering of two regular expression submatches.
   * @param lhs First regular expression submatch.
   * @param rhs Second regular expression submatch.
   * @returns true if @a lhs precedes @a rhs, false otherwise.
   */
  template<typename _BiIter>
    inline bool
    operator<(const sub_match<_BiIter>& __lhs,
	      const sub_match<_BiIter>& __rhs)
    { return __lhs.compare(__rhs) < 0; }

  /**
   * @brief Tests the ordering of two regular expression submatches.
   * @param lhs First regular expression submatch.
   * @param rhs Second regular expression submatch.
   * @returns true if @a lhs does not succeed @a rhs, false otherwise.
   */
  template<typename _BiIter>
    inline bool
    operator<=(const sub_match<_BiIter>& __lhs,
	       const sub_match<_BiIter>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }

  /**
   * @brief Tests the ordering of two regular expression submatches.
   * @param lhs First regular expression submatch.
   * @param rhs Second regular expression submatch.
   * @returns true if @a lhs does not precede @a rhs, false otherwise.
   */
  template<typename _BiIter>
    inline bool
    operator>=(const sub_match<_BiIter>& __lhs,
	       const sub_match<_BiIter>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }

  /**
   * @brief Tests the ordering of two regular expression submatches.
   * @param lhs First regular expression submatch.
   * @param rhs Second regular expression submatch.
   * @returns true if @a lhs succeeds @a rhs, false otherwise.
   */
  template<typename _BiIter>
    inline bool
    operator>(const sub_match<_BiIter>& __lhs,
	      const sub_match<_BiIter>& __rhs)
    { return __lhs.compare(__rhs) > 0; }

  /**
   * @brief Tests the equivalence of a string and a regular expression
   *        submatch.
   * @param lhs A string.
   * @param rhs A regular expression submatch.
   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.
   */
  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
    inline bool
    operator==(const basic_string<
	       typename iterator_traits<_Bi_iter>::value_type,
	       _Ch_traits, _Ch_alloc>& __lhs,
	       const sub_match<_Bi_iter>& __rhs)
    { return __lhs == __rhs.str(); }

  /**
   * @brief Tests the inequivalence of a string and a regular expression
   *        submatch.
   * @param lhs A string.
   * @param rhs A regular expression submatch.
   * @returns true if @a lhs  is not equivalent to @a rhs, false otherwise.
   */
  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
    inline bool
    operator!=(const basic_string<
	       typename iterator_traits<_Bi_iter>::value_type,
	       _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)
    { return __lhs != __rhs.str(); }

  /**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param lhs A string.
   * @param rhs A regular expression submatch.
   * @returns true if @a lhs precedes @a rhs, false otherwise.
   */
  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
    inline bool
    operator<(const basic_string<
	      typename iterator_traits<_Bi_iter>::value_type,
	      _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)
     { return __lhs < __rhs.str(); }

  /**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param lhs A string.
   * @param rhs A regular expression submatch.
   * @returns true if @a lhs succeeds @a rhs, false otherwise.
   */
  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
    inline bool
    operator>(const basic_string<
	      typename iterator_traits<_Bi_iter>::value_type, 
	      _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)
    { return __lhs > __rhs.str(); }

  /**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param lhs A string.
   * @param rhs A regular expression submatch.
   * @returns true if @a lhs does not precede @a rhs, false otherwise.
   */
  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
    inline bool
    operator>=(const basic_string<
	       typename iterator_traits<_Bi_iter>::value_type,
	       _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)
    { return __lhs >= __rhs.str(); }

  /**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param lhs A string.
   * @param rhs A regular expression submatch.
   * @returns true if @a lhs does not succeed @a rhs, false otherwise.
   */
  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
    inline bool
    operator<=(const basic_string<
	       typename iterator_traits<_Bi_iter>::value_type,
	       _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)
    { return __lhs <= __rhs.str(); }

  /**
   * @brief Tests the equivalence of a regular expression submatch and a
   *        string.
   * @param lhs A regular expression submatch.
   * @param rhs A string.
   * @returns true if @a lhs is equivalent to @a rhs, false otherwise.
   */
  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
    inline bool
    operator==(const sub_match<_Bi_iter>& __lhs,
	       const basic_string<
	       typename iterator_traits<_Bi_iter>::value_type,
	       _Ch_traits, _Ch_alloc>& __rhs)
    { return __lhs.str() == __rhs; }

  /**
   * @brief Tests the inequivalence of a regular expression submatch and a
   *        string.
   * @param lhs A regular expression submatch.
   * @param rhs A string.
   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.
   */
  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
    inline bool
    operator!=(const sub_match<_Bi_iter>& __lhs,
	       const basic_string<
	       typename iterator_traits<_Bi_iter>::value_type,
	       _Ch_traits, _Ch_alloc>& __rhs)
    { return __lhs.str() != __rhs; }

  /**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param lhs A regular expression submatch.
   * @param rhs A string.
   * @returns true if @a lhs precedes @a rhs, false otherwise.
   */
  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>
    inline bool
    operator<(const sub_match<_Bi_iter>& __lhs,
	      const basic_string<
	      typename iterator_traits<_Bi_iter>::value_type,
	      _Ch_traits, _Ch_alloc>& __rhs)
    { return __lhs.str() < __rhs; }

  /**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param lhs A regular expression submatch.
   * @param rhs A string.
   * @returns true if @a lhs succeeds @a rhs, false otherwise.
   */
  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>
    inline bool
    operator>(const sub_match<_Bi_iter>& __lhs,
	      const basic_string<
	      typename iterator_traits<_Bi_iter>::value_type,
	      _Ch_traits, _Ch_alloc>& __rhs)
    { return __lhs.str() > __rhs; }

  /**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param lhs A regular expression submatch.
   * @param rhs A string.
   * @returns true if @a lhs does not precede @a rhs, false otherwise.
   */
  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>
    inline bool
    operator>=(const sub_match<_Bi_iter>& __lhs,
	       const basic_string<
	       typename iterator_traits<_Bi_iter>::value_type,
	       _Ch_traits, _Ch_alloc>& __rhs)
    { return __lhs.str() >= __rhs; }

  /**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param lhs A regular expression submatch.
   * @param rhs A string.
   * @returns true if @a lhs does not succeed @a rhs, false otherwise.
   */
  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>
    inline bool
    operator<=(const sub_match<_Bi_iter>& __lhs,
	       const basic_string<
	       typename iterator_traits<_Bi_iter>::value_type,
	       _Ch_traits, _Ch_alloc>& __rhs)
    { return __lhs.str() <= __rhs; }

  /**
   * @brief Tests the equivalence of a C string and a regular expression
   *        submatch.
   * @param lhs A C string.
   * @param rhs A regular expression submatch.
   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator==(typename iterator_traits<_Bi_iter>::value_type const* __lhs,
	       const sub_match<_Bi_iter>& __rhs)
    { return __lhs == __rhs.str(); }

  /**
   * @brief Tests the inequivalence of an iterator value and a regular
   *        expression submatch.
   * @param lhs A regular expression submatch.
   * @param rhs A string.
   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator!=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,
	       const sub_match<_Bi_iter>& __rhs)
    { return __lhs != __rhs.str(); }

  /**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param lhs A string.
   * @param rhs A regular expression submatch.
   * @returns true if @a lhs precedes @a rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator<(typename iterator_traits<_Bi_iter>::value_type const* __lhs,
	      const sub_match<_Bi_iter>& __rhs)
    { return __lhs < __rhs.str(); }

  /**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param lhs A string.
   * @param rhs A regular expression submatch.
   * @returns true if @a lhs succeeds @a rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator>(typename iterator_traits<_Bi_iter>::value_type const* __lhs,
	      const sub_match<_Bi_iter>& __rhs)
    { return __lhs > __rhs.str(); }

  /**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param lhs A string.
   * @param rhs A regular expression submatch.
   * @returns true if @a lhs does not precede @a rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator>=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,
	       const sub_match<_Bi_iter>& __rhs)
    { return __lhs >= __rhs.str(); }

  /**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param lhs A string.
   * @param rhs A regular expression submatch.
   * @returns true if @a lhs does not succeed @a rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator<=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,
	       const sub_match<_Bi_iter>& __rhs)
    { return __lhs <= __rhs.str(); }

  /**
   * @brief Tests the equivalence of a regular expression submatch and a
   *        string.
   * @param lhs A regular expression submatch.
   * @param rhs A pointer to a string?
   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator==(const sub_match<_Bi_iter>& __lhs,
	       typename iterator_traits<_Bi_iter>::value_type const* __rhs)
    { return __lhs.str() == __rhs; }

  /**
   * @brief Tests the inequivalence of a regular expression submatch and a
   *        string.
   * @param lhs A regular expression submatch.
   * @param rhs A pointer to a string.
   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator!=(const sub_match<_Bi_iter>& __lhs,
	       typename iterator_traits<_Bi_iter>::value_type const* __rhs)
    { return __lhs.str() != __rhs; }

  /**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param lhs A regular expression submatch.
   * @param rhs A string.
   * @returns true if @a lhs precedes @a rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator<(const sub_match<_Bi_iter>& __lhs,
	      typename iterator_traits<_Bi_iter>::value_type const* __rhs)
    { return __lhs.str() < __rhs; }

  /**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param lhs A regular expression submatch.
   * @param rhs A string.
   * @returns true if @a lhs succeeds @a rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator>(const sub_match<_Bi_iter>& __lhs,
	      typename iterator_traits<_Bi_iter>::value_type const* __rhs)
    { return __lhs.str() > __rhs; }

  /**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param lhs A regular expression submatch.
   * @param rhs A string.
   * @returns true if @a lhs does not precede @a rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator>=(const sub_match<_Bi_iter>& __lhs,
	       typename iterator_traits<_Bi_iter>::value_type const* __rhs)
    { return __lhs.str() >= __rhs; }

  /**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param lhs A regular expression submatch.
   * @param rhs A string.
   * @returns true if @a lhs does not succeed @a rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator<=(const sub_match<_Bi_iter>& __lhs,
	       typename iterator_traits<_Bi_iter>::value_type const* __rhs)
    { return __lhs.str() <= __rhs; }

  /**
   * @brief Tests the equivalence of a string and a regular expression
   *        submatch.
   * @param lhs A string.
   * @param rhs A regular expression submatch.
   * @returns true if @a lhs is equivalent to @a rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator==(typename iterator_traits<_Bi_iter>::value_type const& __lhs,
	       const sub_match<_Bi_iter>& __rhs)
    { return __lhs == __rhs.str(); }

  /**
   * @brief Tests the inequivalence of a string and a regular expression
   *        submatch.
   * @param lhs A string.
   * @param rhs A regular expression submatch.
   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator!=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,
	       const sub_match<_Bi_iter>& __rhs)
    { return __lhs != __rhs.str(); }

  /**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param lhs A string.
   * @param rhs A regular expression submatch.
   * @returns true if @a lhs precedes @a rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator<(typename iterator_traits<_Bi_iter>::value_type const& __lhs,
	      const sub_match<_Bi_iter>& __rhs)
    { return __lhs < __rhs.str(); }

  /**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param lhs A string.
   * @param rhs A regular expression submatch.
   * @returns true if @a lhs succeeds @a rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator>(typename iterator_traits<_Bi_iter>::value_type const& __lhs,
	      const sub_match<_Bi_iter>& __rhs)
    { return __lhs > __rhs.str(); }

  /**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param lhs A string.
   * @param rhs A regular expression submatch.
   * @returns true if @a lhs does not precede @a rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator>=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,
	       const sub_match<_Bi_iter>& __rhs)
    { return __lhs >= __rhs.str(); }

  /**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param lhs A string.
   * @param rhs A regular expression submatch.
   * @returns true if @a lhs does not succeed @a rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator<=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,
	       const sub_match<_Bi_iter>& __rhs)
    { return __lhs <= __rhs.str(); }

  /**
   * @brief Tests the equivalence of a regular expression submatch and a
   *        string.
   * @param lhs A regular expression submatch.
   * @param rhs A const string reference.
   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator==(const sub_match<_Bi_iter>& __lhs,
	       typename iterator_traits<_Bi_iter>::value_type const& __rhs)
    { return __lhs.str() == __rhs; }

  /**
   * @brief Tests the inequivalence of a regular expression submatch and a
   *        string.
   * @param lhs A regular expression submatch.
   * @param rhs A const string reference.
   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator!=(const sub_match<_Bi_iter>& __lhs,
	       typename iterator_traits<_Bi_iter>::value_type const& __rhs)
    { return __lhs.str() != __rhs; }

  /**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param lhs A regular expression submatch.
   * @param rhs A const string reference.
   * @returns true if @a lhs precedes @a rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator<(const sub_match<_Bi_iter>& __lhs,
	      typename iterator_traits<_Bi_iter>::value_type const& __rhs)
    { return __lhs.str() < __rhs; }

  /**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param lhs A regular expression submatch.
   * @param rhs A const string reference.
   * @returns true if @a lhs succeeds @a rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator>(const sub_match<_Bi_iter>& __lhs,
	      typename iterator_traits<_Bi_iter>::value_type const& __rhs)
    { return __lhs.str() > __rhs; }

  /**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param lhs A regular expression submatch.
   * @param rhs A const string reference.
   * @returns true if @a lhs does not precede @a rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator>=(const sub_match<_Bi_iter>& __lhs,
	       typename iterator_traits<_Bi_iter>::value_type const& __rhs)
    { return __lhs.str() >= __rhs; }

  /**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param lhs A regular expression submatch.
   * @param rhs A const string reference.
   * @returns true if @a lhs does not succeed @a rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator<=(const sub_match<_Bi_iter>& __lhs,
	       typename iterator_traits<_Bi_iter>::value_type const& __rhs)
    { return __lhs.str() <= __rhs; }

  /**
   * @brief Inserts a matched string into an output stream.
   *
   * @param os The output stream.
   * @param m  A submatch string.
   *
   * @returns the output stream with the submatch string inserted.
   */
  template<typename _Ch_type, typename _Ch_traits, typename _Bi_iter>
    inline
    basic_ostream<_Ch_type, _Ch_traits>&
    operator<<(basic_ostream<_Ch_type, _Ch_traits>& __os,
	       const sub_match<_Bi_iter>& __m)
    { return __os << __m.str(); }

  // [7.10] Class template match_results
  /**
   * A collection of character sequences representing the result of a regular
   * expression match.  Storage for the collection is allocated and freed as
   * necessary by the member functions of class template match_results.
   *
   * This class satisfies the Sequence requirements, with the exception that
   * only the operations defined for a const-qualified Sequence are supported.
   *
   * The sub_match object stored at index 0 represents sub-expression 0, i.e.
   * the whole match. In this case the sub_match member matched is always true.
   * The sub_match object stored at index n denotes what matched the marked
   * sub-expression n within the matched expression. If the sub-expression n
   * participated in a regular expression match then the sub_match member
   * matched evaluates to true, and members first and second denote the range
   * of characters [first, second) which formed that match. Otherwise matched
   * is false, and members first and second point to the end of the sequence
   * that was searched.
   */
  template<typename _Bi_iter,
	   typename _Allocator = allocator<sub_match<_Bi_iter> > >
    class match_results
    : private std::vector<std::_GLIBCXX_TR1 sub_match<_Bi_iter>, _Allocator>
    {
    private:
      typedef std::vector<std::_GLIBCXX_TR1 sub_match<_Bi_iter>, _Allocator>
                                                              _Base_type;

    public:
      typedef sub_match<_Bi_iter>                             value_type;
      typedef typename _Allocator::const_reference            const_reference;
      typedef const_reference                                 reference;
      typedef typename _Base_type::const_iterator             const_iterator;
      typedef const_iterator                                  iterator;
      typedef typename iterator_traits<_Bi_iter>::difference_type
                                                              difference_type;
      typedef typename _Allocator::size_type                  size_type;
      typedef _Allocator                                      allocator_type;
      typedef typename iterator_traits<_Bi_iter>::value_type  char_type;
      typedef basic_string<char_type>                         string_type;
  
    public:
      // [7.10.1] construct/copy/destroy
      /**
       * @brief Constructs a default match_results container.
       */
      explicit
      match_results(const _Allocator& __a = _Allocator())
      : _Base_type(__a), _M_matched(false)
      { }

      /**
       * @brief Copy constructs a match_result.
       */
      match_results(const match_results& __rhs)
      : _Base_type(__rhs), _M_matched(__rhs._M_matched),
	_M_prefix(__rhs._M_prefix), _M_suffix(__rhs._M_suffix)
      { }

      /**
       * @brief Assigns rhs to *this.
       */
      match_results&
      operator=(const match_results& __rhs)
      {
	match_results __tmp(__rhs);
	this->swap(__tmp);
      }

      /**
       * @todo Implement this function.
       */
      ~match_results()
      { }
      
      // [7.10.2] size
      /**
       * @todo Document this function.
       */
      size_type
      size() const
      { return _M_matched ? _Base_type::size() + 1 : 0; }
      
      /**
       * @todo Implement this function.
       */
      //size_type
      //max_size() const;
      using _Base_type::max_size;

      /**
       * @todo Document this function.
       */
      bool
      empty() const
      { return size() == 0; }
      
      // [7.10.3] element access
      /**
       * @brief Gets the length of the indicated submatch.
       * @param sub indicates the submatch.
       */
      difference_type
      length(size_type __sub = 0) const
      { return _M_matched ? this->str(__sub).length() : 0; }

      /**
       * @todo Document this function.
       */
      difference_type
      position(size_type __sub = 0) const
      {
	return _M_matched ? std::distance(this->prefix().first,
					  (*this)[__sub].first) : 0;
      }

      /**
       * @todo Document this function.
       */
      string_type
      str(size_type __sub = 0) const
      { return _M_matched ? (*this)[__sub].str() : string_type(); }
      
      /**
       * @todo Document this function.
       */
      const_reference
      operator[](size_type __n) const
      { return _Base_type::operator[](__n); }

      /**
       * @todo Document this function.
       */
      const_reference
      prefix() const
      { return _M_prefix; }

      /**
       * @todo Document this function.
       */
      const_reference
      suffix() const
      { return _M_suffix; }

      /**
       * @todo Document this function.
       */
      const_iterator
      begin() const
      { return _Base_type::begin(); }
      
      /**
       * @todo Document this function.
       */
      const_iterator
      end() const
      { return _Base_type::end(); }
      
      // [7.10.4] format
      /**
       * @todo Implement this function.
       */
      template<typename _Out_iter>
        _Out_iter
        format(_Out_iter __out, const string_type& __fmt,
	       regex_constants::match_flag_type __flags
	       = regex_constants::format_default) const
        { return __out; }

      /**
       * @todo Implement this function.
       */
      string_type
      format(const string_type& __fmt,
	     regex_constants::match_flag_type __flags
	     = regex_constants::format_default) const;

      // [7.10.5] allocator
      /**
       * @todo Document this function.
       */
      //allocator_type
      //get_allocator() const;
      using _Base_type::get_allocator;
      
      // [7.10.6] swap
      /**
       * @todo Document this function.
       */
      void
      swap(match_results& __that)
      {
	_Base_type::swap(__that);
	std::swap(_M_matched, __that._M_matched);
	std::swap(_M_prefix,  __that._M_prefix);
	std::swap(_M_suffix,  __that._M_suffix);
      }
      
    private:
      bool       _M_matched;
      value_type _M_prefix;
      value_type _M_suffix;
    };
  
  typedef match_results<const char*>             cmatch;
  typedef match_results<string::const_iterator>  smatch;
#ifdef _GLIBCXX_USE_WCHAR_T
  typedef match_results<const wchar_t*>          wcmatch;
  typedef match_results<wstring::const_iterator> wsmatch;
#endif

  // match_results comparisons
  /**
   * @todo Implement this function.
   */
  template<typename _Bi_iter, typename _Allocator>
    inline bool
    operator==(const match_results<_Bi_iter, _Allocator>& __m1,
	       const match_results<_Bi_iter, _Allocator>& __m2);

  /**
   * @todo Implement this function.
   */
  template<typename _Bi_iter, class _Allocator>
    inline bool
    operator!=(const match_results<_Bi_iter, _Allocator>& __m1,
	       const match_results<_Bi_iter, _Allocator>& __m2);

  // [7.10.6] match_results swap
  /**
   * @brief Swaps two match results.
   * @param lhs A match result.
   * @param rhs A match result.
   *
   * The contents of the two match_results objects are swapped.
   */
  template<typename _Bi_iter, typename _Allocator>
    inline void
    swap(match_results<_Bi_iter, _Allocator>& __lhs,
	 match_results<_Bi_iter, _Allocator>& __rhs)
    { return __lhs.swap(__rhs); }

  // [7.11.2] Function template regex_match
  /**
   * @brief Determines if there is a match between the regular expression @p e
   * and all of the character sequence [first, last).
   *
   * @param first Beginning of the character sequence to match.
   * @param last  One-past-the-end of the character sequence to match.
   * @param m     The match results.
   * @param re    The regular expression.
   * @param flags Controls how the regular expression is matched.
   *
   * @retval true  A match exists.
   * @retval false Otherwise.
   *
   * @todo Implement this function.
   */
  template<typename _Bi_iter, typename _Allocator,
	   typename _Ch_type, typename _Rx_traits>
    bool
    regex_match(_Bi_iter __first, _Bi_iter __last,
		match_results<_Bi_iter, _Allocator>& __m,
		const basic_regex<_Ch_type, _Rx_traits>& __re,
		regex_constants::match_flag_type __flags
		= regex_constants::match_default)
    { return false; }

  /**
   * @brief Indicates if there is a match between the regular expression @p e
   * and all of the character sequence [first, last).
   *
   * @param first Beginning of the character sequence to match.
   * @param last  One-past-the-end of the character sequence to match.
   * @param re    The regular expression.
   * @param flags Controls how the regular expression is matched.
   *
   * @retval true  A match exists.
   * @retval false Otherwise.
   */
  template<typename _Bi_iter, typename _Ch_type, typename _Rx_traits>
    bool
    regex_match(_Bi_iter __first, _Bi_iter __last,
		const basic_regex<_Ch_type, _Rx_traits>& __re,
		regex_constants::match_flag_type __flags
		= regex_constants::match_default)
    { 
      match_results<_Bi_iter> __what;
      return regex_match(__first, __last, __what, __re, __flags);
    }

  /**
   * @brief Determines if there is a match between the regular expression @p e
   * and a C-style null-terminated string.
   *
   * @param s  The C-style null-terminated string to match.
   * @param m  The match results.
   * @param re The regular expression.
   * @param f  Controls how the regular expression is matched.
   *
   * @retval true  A match exists.
   * @retval false Otherwise.
   */
  template<typename _Ch_type, typename _Allocator, typename _Rx_traits>
    inline bool
    regex_match(const _Ch_type* __s,
		match_results<const _Ch_type*, _Allocator>& __m,
		const basic_regex<_Ch_type, _Rx_traits>& __re,
		regex_constants::match_flag_type __f
		= regex_constants::match_default)
    { return regex_match(__s, __s + _Rx_traits::length(__s), __m, __re, __f); }

  /**
   * @brief Determines if there is a match between the regular expression @p e
   * and a string.
   *
   * @param s     The string to match.
   * @param m     The match results.
   * @param re    The regular expression.
   * @param flags Controls how the regular expression is matched.
   *
   * @retval true  A match exists.
   * @retval false Otherwise.
   */
  template<typename _Ch_traits, typename _Ch_alloc,
	   typename _Allocator, typename _Ch_type, typename _Rx_traits>
    inline bool
    regex_match(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,
		match_results<typename basic_string<_Ch_type, 
		_Ch_traits, _Ch_alloc>::const_iterator, _Allocator>& __m,
		const basic_regex<_Ch_type, _Rx_traits>& __re,
		regex_constants::match_flag_type __flags
		= regex_constants::match_default)
    { return regex_match(__s.begin(), __s.end(), __m, __re, __flags); }

  /**
   * @brief Indicates if there is a match between the regular expression @p e
   * and a C-style null-terminated string.
   *
   * @param s  The C-style null-terminated string to match.
   * @param re The regular expression.
   * @param f  Controls how the regular expression is matched.
   *
   * @retval true  A match exists.
   * @retval false Otherwise.
   */
  template<typename _Ch_type, class _Rx_traits>
    inline bool
    regex_match(const _Ch_type* __s,
		const basic_regex<_Ch_type, _Rx_traits>& __re,
		regex_constants::match_flag_type __f
		= regex_constants::match_default)
    { return regex_match(__s, __s + _Rx_traits::length(__s), __re, __f); }

  /**
   * @brief Indicates if there is a match between the regular expression @p e
   * and a string.
   *
   * @param s     [IN] The string to match.
   * @param re    [IN] The regular expression.
   * @param flags [IN] Controls how the regular expression is matched.
   *
   * @retval true  A match exists.
   * @retval false Otherwise.
   */
  template<typename _Ch_traits, typename _Str_allocator,
	   typename _Ch_type, typename _Rx_traits>
    inline bool
    regex_match(const basic_string<_Ch_type, _Ch_traits, _Str_allocator>& __s,
		const basic_regex<_Ch_type, _Rx_traits>& __re,
		regex_constants::match_flag_type __flags
		= regex_constants::match_default)
    { return regex_match(__s.begin(), __s.end(), __re, __flags); }

  // [7.11.3] Function template regex_search
  /**
   * Searches for a regular expression within a range.
   * @param first [IN]  The start of the string to search.
   * @param last  [IN]  One-past-the-end of the string to search.
   * @param m     [OUT] The match results.
   * @param re    [IN]  The regular expression to search for.
   * @param flags [IN]  Search policy flags.
   * @retval true  A match was found within the string.
   * @retval false No match was found within the string, the content of %m is
   *               undefined.
   * @todo Implement this function.
   */
  template<typename _Bi_iter, typename _Allocator,
	   typename _Ch_type, typename _Rx_traits>
    inline bool
    regex_search(_Bi_iter __first, _Bi_iter __last,
		 match_results<_Bi_iter, _Allocator>& __m,
		 const basic_regex<_Ch_type, _Rx_traits>& __re,
		 regex_constants::match_flag_type __flags
		 = regex_constants::match_default)
    { return false; }

  /**
   * Searches for a regular expression within a range.
   * @param first [IN]  The start of the string to search.
   * @param last  [IN]  One-past-the-end of the string to search.
   * @param re    [IN]  The regular expression to search for.
   * @param flags [IN]  Search policy flags.
   * @retval true  A match was found within the string.
   * @retval false No match was found within the string.
   * @todo Document me.
   */
  template<typename _Bi_iter, typename _Ch_type, typename _Rx_traits>
    inline bool
    regex_search(_Bi_iter __first, _Bi_iter __last,
		 const basic_regex<_Ch_type, _Rx_traits>& __re,
		 regex_constants::match_flag_type __flags
		 = regex_constants::match_default)
    {
      match_results<_Bi_iter> __what;
      return regex_search(__first, __last, __what, __re, __flags);
    }

  /**
   * @brief Searches for a regular expression within a C-string.
   * @param s [IN]  A C-string to search for the regex.
   * @param m [OUT] The set of regex matches.
   * @param e [IN]  The regex to search for in @p s.
   * @param f [IN]  The search flags.
   * @retval true  A match was found within the string.
   * @retval false No match was found within the string, the content of %m is
   *               undefined.
   * @todo Document me.
   */
  template<typename _Ch_type, class _Allocator, class _Rx_traits>
    inline bool
    regex_search(const _Ch_type* __s,
		 match_results<const _Ch_type*, _Allocator>& __m,
		 const basic_regex<_Ch_type, _Rx_traits>& __e,
		 regex_constants::match_flag_type __f
		 = regex_constants::match_default)
    { return regex_search(__s, __s + _Rx_traits::length(__s), __m, __e, __f); }

  /**
   * @brief Searches for a regular expression within a C-string.
   * @param s [IN]  The C-string to search.
   * @param e [IN]  The regular expression to search for.
   * @param f [IN]  Search policy flags.
   * @retval true  A match was found within the string.
   * @retval false No match was found within the string.
   * @todo Document me.
   */
  template<typename _Ch_type, typename _Rx_traits>
    inline bool
    regex_search(const _Ch_type* __s,
		 const basic_regex<_Ch_type, _Rx_traits>& __e,
		 regex_constants::match_flag_type __f
		 = regex_constants::match_default)
    { return regex_search(__s, __s + _Rx_traits::length(__s), __e, __f); }

  /**
   * @brief Searches for a regular expression within a string.
   * @param s     [IN]  The string to search.
   * @param e     [IN]  The regular expression to search for.
   * @param flags [IN]  Search policy flags.
   * @retval true  A match was found within the string.
   * @retval false No match was found within the string.
   * @todo Document me.
   */
  template<typename _Ch_traits, typename _String_allocator,
	   typename _Ch_type, typename _Rx_traits>
    inline bool
    regex_search(const basic_string<_Ch_type, _Ch_traits,
		 _String_allocator>& __s,
		 const basic_regex<_Ch_type, _Rx_traits>& __e,
		 regex_constants::match_flag_type __flags
		 = regex_constants::match_default)
    { return regex_search(__s.begin(), __s.end(), __e, __flags); }

  /**
   * @brief Searches for a regular expression within a string.
   * @param s [IN]  A C++ string to search for the regex.
   * @param m [OUT] The set of regex matches.
   * @param e [IN]  The regex to search for in @p s.
   * @param f [IN]  The search flags.
   * @retval true  A match was found within the string.
   * @retval false No match was found within the string, the content of %m is
   *               undefined.
   */
  template<typename _Ch_traits, typename _Ch_alloc,
	   typename _Allocator, typename _Ch_type,
	   typename _Rx_traits>
    inline bool
    regex_search(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,
		 match_results<typename basic_string<_Ch_type,
		 _Ch_traits, _Ch_alloc>::const_iterator, _Allocator>& __m,
		 const basic_regex<_Ch_type, _Rx_traits>& __e,
		 regex_constants::match_flag_type __f
		 = regex_constants::match_default)
    { return regex_search(__s.begin(), __s.end(), __m, __e, __f); }

  // [7.11.4] Function template regex_replace
  /**
   * @todo Implement this function.
   * @todo Document this function.
   */
  template<typename _Out_iter, typename _Bi_iter,
	   typename _Rx_traits, typename _Ch_type>
    inline _Out_iter
    regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,
		  const basic_regex<_Ch_type, _Rx_traits>& __e,
		  const basic_string<_Ch_type>& __fmt,
		  regex_constants::match_flag_type __flags
		  = regex_constants::match_default)
    { return __out; }

  /**
   * @todo Document me.
   */
  template<typename _Rx_traits, typename _Ch_type>
    inline basic_string<_Ch_type>
    regex_replace(const basic_string<_Ch_type>& __s,
		  const basic_regex<_Ch_type, _Rx_traits>& __e,
		  const basic_string<_Ch_type>& __fmt,
		  regex_constants::match_flag_type __flags
		  = regex_constants::match_default)
    {
      std::string __result;
      regex_replace(std::back_inserter(__result),
		    __s.begin(), __s.end(), __e, __fmt, __flags);
      return __result;
    }

  // [7.12.1] Class template regex_iterator
  /**
   * An iterator adaptor that will provide repeated calls of regex_search over 
   * a range until no more matches remain.
   */
  template<typename _Bi_iter,
	   typename _Ch_type = typename iterator_traits<_Bi_iter>::value_type,
	   typename _Rx_traits = regex_traits<_Ch_type> >
    class regex_iterator
    {
    public:
      typedef basic_regex<_Ch_type, _Rx_traits>  regex_type;
      typedef match_results<_Bi_iter>            value_type;
      typedef std::ptrdiff_t                     difference_type;
      typedef const value_type*                  pointer;
      typedef const value_type&                  reference;
      typedef std::forward_iterator_tag          iterator_category;

    public:
      /**
       * @brief Provides a singular iterator, useful for indicating
       * one-past-the-end of a range.
       * @todo Implement this function.
       * @todo Document this function.
       */
      regex_iterator();
      
      /**
       * Constructs a %regex_iterator...
       * @param a  [IN] The start of a text range to search.
       * @param b  [IN] One-past-the-end of the text range to search.
       * @param re [IN] The regular expression to match.
       * @param m  [IN] Policy flags for match rules.
       * @todo Implement this function.
       * @todo Document this function.
       */
      regex_iterator(_Bi_iter __a, _Bi_iter __b, const regex_type& __re,
		     regex_constants::match_flag_type __m
		     = regex_constants::match_default);

      /**
       * Copy constructs a %regex_iterator.
       * @todo Implement this function.
       * @todo Document this function.
       */
      regex_iterator(const regex_iterator& __rhs);
      
      /**
       * @todo Implement this function.
       * @todo Document this function.
       */
      regex_iterator&
      operator=(const regex_iterator& __rhs);
      
      /**
       * @todo Implement this function.
       * @todo Document this function.
       */
      bool
      operator==(const regex_iterator& __rhs);
      
      /**
       * @todo Implement this function.
       * @todo Document this function.
       */
      bool
      operator!=(const regex_iterator& __rhs);
      
      /**
       * @todo Implement this function.
       * @todo Document this function.
       */
      const value_type&
      operator*();
      
      /**
       * @todo Implement this function.
       * @todo Document this function.
       */
      const value_type*
      operator->();
      
      /**
       * @todo Implement this function.
       * @todo Document this function.
       */
      regex_iterator&
      operator++();
      
      /**
       * @todo Implement this function.
       * @todo Document this function.
       */
      regex_iterator
      operator++(int);
      
    private:
      // these members are shown for exposition only:
      _Bi_iter                         begin;
      _Bi_iter                         end;
      const regex_type*                pregex;
      regex_constants::match_flag_type flags;
      match_results<_Bi_iter>          match;
    };
  
  typedef regex_iterator<const char*>             cregex_iterator;
  typedef regex_iterator<string::const_iterator>  sregex_iterator;
#ifdef _GLIBCXX_USE_WCHAR_T
  typedef regex_iterator<const wchar_t*>          wcregex_iterator;
  typedef regex_iterator<wstring::const_iterator> wsregex_iterator;
#endif

  // [7.12.2] Class template regex_token_iterator
  /**
   * Iterates over submatches in a range (or "splits" a text string).
   *
   * The purpose of this iterator is to enumerate all, or all specified,
   * matches of a regular expression within a text range.  The dereferenced
   * value of an iterator of this class is a std::tr1::sub_match object.
   */
  template<typename _Bi_iter,
	   typename _Ch_type = typename iterator_traits<_Bi_iter>::value_type,
	   typename _Rx_traits = regex_traits<_Ch_type> >
    class regex_token_iterator
    {
    public:
      typedef basic_regex<_Ch_type, _Rx_traits> regex_type;
      typedef sub_match<_Bi_iter>               value_type;
      typedef std::ptrdiff_t                    difference_type;
      typedef const value_type*                 pointer;
      typedef const value_type&                 reference;
      typedef std::forward_iterator_tag         iterator_category;
      
    public:
      /**
       * @brief Default constructs a %regex_token_iterator.
       * @todo Implement this function.
       * 
       * A default-constructed %regex_token_iterator is a singular iterator
       * that will compare equal to the one-past-the-end value for any
       * iterator of the same type.
       */
      regex_token_iterator();
      
      /**
       * Constructs a %regex_token_iterator...
       * @param a          [IN] The start of the text to search.
       * @param b          [IN] One-past-the-end of the text to search.
       * @param re         [IN] The regular expression to search for.
       * @param submatch   [IN] Which submatch to return.  There are some
       *                        special values for this parameter:
       *                        - -1 each enumerated subexpression does NOT
       *                          match the regular expression (aka field
       *                          splitting)
       *                        - 0 the entire string matching the
       *                          subexpression is returned for each match
       *                          within the text.
       *                        - >0 enumerates only the indicated
       *                          subexpression from a match within the text.
       * @param m          [IN] Policy flags for match rules.
       *
       * @todo Implement this function.
       * @todo Document this function.
       */
      regex_token_iterator(_Bi_iter __a, _Bi_iter __b, const regex_type& __re,
			   int __submatch = 0,
			   regex_constants::match_flag_type __m
			   = regex_constants::match_default);

      /**
       * Constructs a %regex_token_iterator...
       * @param a          [IN] The start of the text to search.
       * @param b          [IN] One-past-the-end of the text to search.
       * @param re         [IN] The regular expression to search for.
       * @param submatches [IN] A list of subexpressions to return for each
       *                        regular expression match within the text.
       * @param m          [IN] Policy flags for match rules.
       *
       * @todo Implement this function.
       * @todo Document this function.
       */
      regex_token_iterator(_Bi_iter __a, _Bi_iter __b,
			   const regex_type& __re,
			   const std::vector<int>& __submatches,
			   regex_constants::match_flag_type __m
			     = regex_constants::match_default);

      /**
       * Constructs a %regex_token_iterator...
       * @param a          [IN] The start of the text to search.
       * @param b          [IN] One-past-the-end of the text to search.
       * @param re         [IN] The regular expression to search for.
       * @param submatches [IN] A list of subexpressions to return for each
       *                        regular expression match within the text.
       * @param m          [IN] Policy flags for match rules.
       
       * @todo Implement this function.
       * @todo Document this function.
       */
      template<std::size_t _Nm>
        regex_token_iterator(_Bi_iter __a, _Bi_iter __b,
			     const regex_type& __re,
			     const int (&__submatches)[_Nm],
			     regex_constants::match_flag_type __m
			     = regex_constants::match_default);

      /**
       * @brief Copy constructs a %regex_token_iterator.
       * @param rhs [IN] A %regex_token_iterator to copy.
       * @todo Implement this function.
       */
      regex_token_iterator(const regex_token_iterator& __rhs);
      
      /**
       * @brief Assigns a %regex_token_iterator to another.
       * @param rhs [IN] A %regex_token_iterator to copy.
       * @todo Implement this function.
       */
      regex_token_iterator&
      operator=(const regex_token_iterator& __rhs);
      
      /**
       * @brief Compares a %regex_token_iterator to another for equality.
       * @todo Implement this function.
       */
      bool
      operator==(const regex_token_iterator& _