from, sys_recvfrom)
#define __NR_sendmsg				46
__SYSCALL(__NR_sendmsg, sys_sendmsg)
#define __NR_recvmsg				47
__SYSCALL(__NR_recvmsg, sys_recvmsg)

#define __NR_shutdown				48
__SYSCALL(__NR_shutdown, sys_shutdown)
#define __NR_bind				49
__SYSCALL(__NR_bind, sys_bind)
#define __NR_listen				50
__SYSCALL(__NR_listen, sys_listen)
#define __NR_getsockname			51
__SYSCALL(__NR_getsockname, sys_getsockname)
#define __NR_getpeername			52
__SYSCALL(__NR_getpeername, sys_getpeername)
#define __NR_socketpair				53
__SYSCALL(__NR_socketpair, sys_socketpair)
#define __NR_setsockopt				54
__SYSCALL(__NR_setsockopt, sys_setsockopt)
#define __NR_getsockopt				55
__SYSCALL(__NR_getsockopt, sys_getsockopt)

#define __NR_clone				56
__SYSCALL(__NR_clone, stub_clone)
#define __NR_fork				57
__SYSCALL(__NR_fork, stub_fork)
#define __NR_vfork				58
__SYSCALL(__NR_vfork, stub_vfork)
#define __NR_execve				59
__SYSCALL(__NR_execve, stub_execve)
#define __NR_exit				60
__SYSCALL(__NR_exit, sys_exit)
#define __NR_wait4				61
__SYSCALL(__NR_wait4, sys_wait4)
#define __NR_kill				62
__SYSCALL(__NR_kill, sys_kill)
#define __NR_uname				63
__SYSCALL(__NR_uname, sys_newuname)

#define __NR_semget				64
__SYSCALL(__NR_semget, sys_semget)
#define __NR_semop				65
__SYSCALL(__NR_semop, sys_semop)
#define __NR_semctl				66
__SYSCALL(__NR_semctl, sys_semctl)
#define __NR_shmdt				67
__SYSCALL(__NR_shmdt, sys_shmdt)
#define __NR_msgget				68
__SYSCALL(__NR_msgget, sys_msgget)
#define __NR_msgsnd				69
__SYSCALL(__NR_msgsnd, sys_msgsnd)
#define __NR_msgrcv				70
__SYSCALL(__NR_msgrcv, sys_msgrcv)
#define __NR_msgctl				71
__SYSCALL(__NR_msgctl, sys_msgctl)

#define __NR_fcntl				72
__SYSCALL(__NR_fcntl, sys_fcntl)
#define __NR_flock				73
__SYSCALL(__NR_flock, sys_flock)
#define __NR_fsync				74
__SYSCALL(__NR_fsync, sys_fsync)
#define __NR_fdatasync				75
__SYSCALL(__NR_fdatasync, sys_fdatasync)
#define __NR_truncate				76
__SYSCALL(__NR_truncate, sys_truncate)
#define __NR_ftruncate				77
__SYSCALL(__NR_ftruncate, sys_ftruncate)
#define __NR_getdents				78
__SYSCALL(__NR_getdents, sys_getdents)
#define __NR_getcwd				79
__SYSCALL(__NR_getcwd, sys_getcwd)

#define __NR_chdir				80
__SYSCALL(__NR_chdir, sys_chdir)
#define __NR_fchdir				81
__SYSCALL(__NR_fchdir, sys_fchdir)
#define __NR_rename				82
__SYSCALL(__NR_rename, sys_rename)
#define __NR_mkdir				83
__SYSCALL(__NR_mkdir, sys_mkdir)
#define __NR_rmdir				84
__SYSCALL(__NR_rmdir, sys_rmdir)
#define __NR_creat				85
__SYSCALL(__NR_creat, sys_creat)
#define __NR_link				86
__SYSCALL(__NR_link, sys_link)
#define __NR_unlink				87
__SYSCALL(__NR_unlink, sys_unlink)

#define __NR_symlink				88
__SYSCALL(__NR_symlink, sys_symlink)
#define __NR_readlink				89
__SYSCALL(__NR_readlink, sys_readlink)
#define __NR_chmod				90
__SYSCALL(__NR_chmod, sys_chmod)
#define __NR_fchmod				91
__SYSCALL(__NR_fchmod, sys_fchmod)
#define __NR_chown				92
__SYSCALL(__NR_chown, sys_chown)
#define __NR_fchown				93
__SYSCALL(__NR_fchown, sys_fchown)
#define __NR_lchown				94
__SYSCALL(__NR_lchown, sys_lchown)
#define __NR_umask				95
__SYSCALL(__NR_umask, sys_umask)

#define __NR_gettimeofday			96
__SYSCALL(__NR_gettimeofday, sys_gettimeofday)
#define __NR_getrlimit				97
__SYSCALL(__NR_getrlimit, sys_getrlimit)
#define __NR_getrusage				98
__SYSCALL(__NR_getrusage, sys_getrusage)
#define __NR_sysinfo				99
__SYSCALL(__NR_sysinfo, sys_sysinfo)
#define __NR_times				100
__SYSCALL(__NR_times, sys_times)
#define __NR_ptrace				101
__SYSCALL(__NR_ptrace, sys_ptrace)
#define __NR_getuid				102
__SYSCALL(__NR_getuid, sys_getuid)
#define __NR_syslog				103
__SYSCALL(__NR_syslog, sys_syslog)

/* at the very end the stuff that never runs during the benchmarks */
#define __NR_getgid				104
__SYSCALL(__NR_getgid, sys_getgid)
#define __NR_setuid				105
__SYSCALL(__NR_setuid, sys_setuid)
#define __NR_setgid				106
__SYSCALL(__NR_setgid, sys_setgid)
#define __NR_geteuid				107
__SYSCALL(__NR_geteuid, sys_geteuid)
#define __NR_getegid				108
__SYSCALL(__NR_getegid, sys_getegid)
#define __NR_setpgid				109
__SYSCALL(__NR_setpgid, sys_setpgid)
#define __NR_getppid				110
__SYSCALL(__NR_getppid, sys_getppid)
#define __NR_getpgrp				111
__SYSCALL(__NR_getpgrp, sys_getpgrp)

#define __NR_setsid				112
__SYSCALL(__NR_setsid, sys_setsid)
#define __NR_setreuid				113
__SYSCALL(__NR_setreuid, sys_setreuid)
#define __NR_setregid				114
__SYSCALL(__NR_setregid, sys_setregid)
#define __NR_getgroups				115
__SYSCALL(__NR_getgroups, sys_getgroups)
#define __NR_setgroups				116
__SYSCALL(__NR_setgroups, sys_setgroups)
#define __NR_setresuid				117
__SYSCALL(__NR_setresuid, sys_setresuid)
#define __NR_getresuid				118
__SYSCALL(__NR_getresuid, sys_getresuid)
#define __NR_setresgid				119
__SYSCALL(__NR_setresgid, sys_setresgid)

#define __NR_getresgid				120
__SYSCALL(__NR_getresgid, sys_getresgid)
#define __NR_getpgid				121
__SYSCALL(__NR_getpgid, sys_getpgid)
#define __NR_setfsuid				122
__SYSCALL(__NR_setfsuid, sys_setfsuid)
#define __NR_setfsgid				123
__SYSCALL(__NR_setfsgid, sys_setfsgid)
#define __NR_getsid				124
__SYSCALL(__NR_getsid, sys_getsid)
#define __NR_capget				125
__SYSCALL(__NR_capget, sys_capget)
#define __NR_capset				126
__SYSCALL(__NR_capset, sys_capset)

#define __NR_rt_sigpending			127
__SYSCALL(__NR_rt_sigpending, sys_rt_sigpending)
#define __NR_rt_sigtimedwait			128
__SYSCALL(__NR_rt_sigtimedwait, sys_rt_sigtimedwait)
#define __NR_rt_sigqueueinfo			129
__SYSCALL(__NR_rt_sigqueueinfo, sys_rt_sigqueueinfo)
#define __NR_rt_sigsuspend			130
__SYSCALL(__NR_rt_sigsuspend, sys_rt_sigsuspend)
#define __NR_sigaltstack			131
__SYSCALL(__NR_sigaltstack, stub_sigaltstack)
#define __NR_utime				132
__SYSCALL(__NR_utime, sys_utime)
#define __NR_mknod				133
__SYSCALL(__NR_mknod, sys_mknod)

/* Only needed for a.out */
#define __NR_uselib				134
__SYSCALL(__NR_uselib, sys_ni_syscall)
#define __NR_personality			135
__SYSCALL(__NR_personality, sys_personality)

#define __NR_ustat				136
__SYSCALL(__NR_ustat, sys_ustat)
#define __NR_statfs				137
__SYSCALL(__NR_statfs, sys_statfs)
#define __NR_fstatfs				138
__SYSCALL(__NR_fstatfs, sys_fstatfs)
#define __NR_sysfs				139
__SYSCALL(__NR_sysfs, sys_sysfs)

#define __NR_getpriority			140
__SYSCALL(__NR_getpriority, sys_getpriority)
#define __NR_setpriority			141
__SYSCALL(__NR_setpriority, sys_setpriority)
#define __NR_sched_setparam			142
__SYSCALL(__NR_sched_setparam, sys_sched_setparam)
#define __NR_sched_getparam			143
__SYSCALL(__NR_sched_getparam, sys_sched_getparam)
#define __NR_sched_setscheduler			144
__SYSCALL(__NR_sched_setscheduler, sys_sched_setscheduler)
#define __NR_sched_getscheduler			145
__SYSCALL(__NR_sched_getscheduler, sys_sched_getscheduler)
#define __NR_sched_get_priority_max		146
__SYSCALL(__NR_sched_get_priority_max, sys_sched_get_priority_max)
#define __NR_sched_get_priority_min		147
__SYSCALL(__NR_sched_get_priority_min, sys_sched_get_priority_min)
#define __NR_sched_rr_get_interval		148
__SYSCALL(__NR_sched_rr_get_interval, sys_sched_rr_get_interval)

#define __NR_mlock				149
__SYSCALL(__NR_mlock, sys_mlock)
#define __NR_munlock				150
__SYSCALL(__NR_munlock, sys_munlock)
#define __NR_mlockall				151
__SYSCALL(__NR_mlockall, sys_mlockall)
#define __NR_munlockall				152
__SYSCALL(__NR_munlockall, sys_munlockall)

#define __NR_vhangup				153
__SYSCALL(__NR_vhangup, sys_vhangup)

#define __NR_modify_ldt				154
__SYSCALL(__NR_modify_ldt, sys_modify_ldt)

#define __NR_pivot_root				155
__SYSCALL(__NR_pivot_root, sys_pivot_root)

#define __NR__sysctl				156
__SYSCALL(__NR__sysctl, sys_sysctl)

#define __NR_prctl				157
__SYSCALL(__NR_prctl, sys_prctl)
#define __NR_arch_prctl				158
__SYSCALL(__NR_arch_prctl, sys_arch_prctl)

#define __NR_adjtimex				159
__SYSCALL(__NR_adjtimex, sys_adjtimex)

#define __NR_setrlimit				160
__SYSCALL(__NR_setrlimit, sys_setrlimit)

#define __NR_chroot				161
__SYSCALL(__NR_chroot, sys_chroot)

#define __NR_sync				162
__SYSCALL(__NR_sync, sys_sync)

#define __NR_acct				163
__SYSCALL(__NR_acct, sys_acct)

#define __NR_settimeofday			164
__SYSCALL(__NR_settimeofday, sys_settimeofday)

#define __NR_mount				165
__SYSCALL(__NR_mount, sys_mount)
#define __NR_umount2				166
__SYSCALL(__NR_umount2, sys_umount)

#define __NR_swapon				167
__SYSCALL(__NR_swapon, sys_swapon)
#define __NR_swapoff				168
__SYSCALL(__NR_swapoff, sys_swapoff)

#define __NR_reboot				169
__SYSCALL(__NR_reboot, sys_reboot)

#define __NR_sethostname			170
__SYSCALL(__NR_sethostname, sys_sethostname)
#define __NR_setdomainname			171
__SYSCALL(__NR_setdomainname, sys_setdomainname)

#define __NR_iopl				172
__SYSCALL(__NR_iopl, stub_iopl)
#define __NR_ioperm				173
__SYSCALL(__NR_ioperm, sys_ioperm)

#define __NR_create_module			174
__SYSCALL(__NR_create_module, sys_ni_syscall)
#define __NR_init_module			175
__SYSCALL(__NR_init_module, sys_init_module)
#define __NR_delete_module			176
__SYSCALL(__NR_delete_module, sys_delete_module)
#define __NR_get_kernel_syms			177
__SYSCALL(__NR_get_kernel_syms, sys_ni_syscall)
#define __NR_query_module			178
__SYSCALL(__NR_query_module, sys_ni_syscall)

#define __NR_quotactl				179
__SYSCALL(__NR_quotactl, sys_quotactl)

#define __NR_nfsservctl				180
__SYSCALLä‚  ã‚  å‚  ç‚  é‚  è‚  ê‚  ë‚  í‚  ì‚                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (__NR_nfsservctl, sys_nfsservctl)

/* reserved for LiS/STREAMS */
#define __NR_getpmsg				181
__SYSCALL(__NR_getpmsg, sys_ni_syscall)
#define __NR_putpmsg				182
__SYSCALL(__NR_putpmsg, sys_ni_syscall)

/* reserved for AFS */
#define __NR_afs_syscall			183
__SYSCALL(__NR_afs_syscall, sys_ni_syscall)

/* reserved for tux */
#define __NR_tuxcall				184
__SYSCALL(__NR_tuxcall, sys_ni_syscall)

#define __NR_security				185
__SYSCALL(__NR_security, sys_ni_syscall)

#define __NR_gettid				186
__SYSCALL(__NR_gettid, sys_gettid)

#define __NR_readahead				187
__SYSCALL(__NR_readahead, sys_readahead)
#define __NR_setxattr				188
__SYSCALL(__NR_setxattr, sys_setxattr)
#define __NR_lsetxattr				189
__SYSCALL(__NR_lsetxattr, sys_lsetxattr)
#define __NR_fsetxattr				190
__SYSCALL(__NR_fsetxattr, sys_fsetxattr)
#define __NR_getxattr				191
__SYSCALL(__NR_getxattr, sys_getxattr)
#define __NR_lgetxattr				192
__SYSCALL(__NR_lgetxattr, sys_lgetxattr)
#define __NR_fgetxattr				193
__SYSCALL(__NR_fgetxattr, sys_fgetxattr)
#define __NR_listxattr				194
__SYSCALL(__NR_listxattr, sys_listxattr)
#define __NR_llistxattr				195
__SYSCALL(__NR_llistxattr, sys_llistxattr)
#define __NR_flistxattr				196
__SYSCALL(__NR_flistxattr, sys_flistxattr)
#define __NR_removexattr			197
__SYSCALL(__NR_removexattr, sys_removexattr)
#define __NR_lremovexattr			198
__SYSCALL(__NR_lremovexattr, sys_lremovexattr)
#define __NR_fremovexattr			199
__SYSCALL(__NR_fremovexattr, sys_fremovexattr)
#define __NR_tkill				200
__SYSCALL(__NR_tkill, sys_tkill)
#define __NR_time				201
__SYSCALL(__NR_time, sys_time)
#define __NR_futex				202
__SYSCALL(__NR_futex, sys_futex)
#define __NR_sched_setaffinity			203
__SYSCALL(__NR_sched_setaffinity, sys_sched_setaffinity)
#define __NR_sched_getaffinity			204
__SYSCALL(__NR_sched_getaffinity, sys_sched_getaffinity)
#define __NR_set_thread_area			205
__SYSCALL(__NR_set_thread_area, sys_ni_syscall)	/* use arch_prctl */
#define __NR_io_setup				206
__SYSCALL(__NR_io_setup, sys_io_setup)
#define __NR_io_destroy				207
__SYSCALL(__NR_io_destroy, sys_io_destroy)
#define __NR_io_getevents			208
__SYSCALL(__NR_io_getevents, sys_io_getevents)
#define __NR_io_submit				209
__SYSCALL(__NR_io_submit, sys_io_submit)
#define __NR_io_cancel				210
__SYSCALL(__NR_io_cancel, sys_io_cancel)
#define __NR_get_thread_area			211
__SYSCALL(__NR_get_thread_area, sys_ni_syscall)	/* use arch_prctl */
#define __NR_lookup_dcookie			212
__SYSCALL(__NR_lookup_dcookie, sys_lookup_dcookie)
#define __NR_epoll_create			213
__SYSCALL(__NR_epoll_create, sys_epoll_create)
#define __NR_epoll_ctl_old			214
__SYSCALL(__NR_epoll_ctl_old, sys_ni_syscall)
#define __NR_epoll_wait_old			215
__SYSCALL(__NR_epoll_wait_old, sys_ni_syscall)
#define __NR_remap_file_pages			216
__SYSCALL(__NR_remap_file_pages, sys_remap_file_pages)
#define __NR_getdents64				217
__SYSCALL(__NR_getdents64, sys_getdents64)
#define __NR_set_tid_address			218
__SYSCALL(__NR_set_tid_address, sys_set_tid_address)
#define __NR_restart_syscall			219
__SYSCALL(__NR_restart_syscall, sys_restart_syscall)
#define __NR_semtimedop				220
__SYSCALL(__NR_semtimedop, sys_semtimedop)
#define __NR_fadvise64				221
__SYSCALL(__NR_fadvise64, sys_fadvise64)
#define __NR_timer_create			222
__SYSCALL(__NR_timer_create, sys_timer_create)
#define __NR_timer_settime			223
__SYSCALL(__NR_timer_settime, sys_timer_settime)
#define __NR_timer_gettime			224
__SYSCALL(__NR_timer_gettime, sys_timer_gettime)
#define __NR_timer_getoverrun			225
__SYSCALL(__NR_timer_getoverrun, sys_timer_getoverrun)
#define __NR_timer_delete			226
__SYSCALL(__NR_timer_delete, sys_timer_delete)
#define __NR_clock_settime			227
__SYSCALL(__NR_clock_settime, sys_clock_settime)
#define __NR_clock_gettime			228
__SYSCALL(__NR_clock_gettime, sys_clock_gettime)
#define __NR_clock_getres			229
__SYSCALL(__NR_clock_getres, sys_clock_getres)
#define __NR_clock_nanosleep			230
__SYSCALL(__NR_clock_nanosleep, sys_clock_nanosleep)
#define __NR_exit_group				231
__SYSCALL(__NR_exit_group, sys_exit_group)
#define __NR_epoll_wait				232
__SYSCALL(__NR_epoll_wait, sys_epoll_wait)
#define __NR_epoll_ctl				233
__SYSCALL(__NR_epoll_ctl, sys_epoll_ctl)
#define __NR_tgkill				234
__SYSCALL(__NR_tgkill, sys_tgkill)
#define __NR_utimes				235
__SYSCALL(__NR_utimes, sys_utimes)
#define __NR_vserver				236
__SYSCALL(__NR_vserver, sys_ni_syscall)
#define __NR_mbind				237
__SYSCALL(__NR_mbind, sys_mbind)
#define __NR_set_mempolicy			238
__SYSCALL(__NR_set_mempolicy, sys_set_mempolicy)
#define __NR_get_mempolicy			239
__SYSCALL(__NR_get_mempolicy, sys_get_mempolicy)
#define __NR_mq_open				240
__SYSCALL(__NR_mq_open, sys_mq_open)
#define __NR_mq_unlink				241
__SYSCALL(__NR_mq_unlink, sys_mq_unlink)
#define __NR_mq_timedsend			242
__SYSCALL(__NR_mq_timedsend, sys_mq_timedsend)
#define __NR_mq_timedreceive			243
__SYSCALL(__NR_mq_timedreceive, sys_mq_timedreceive)
#define __NR_mq_notify				244
__SYSCALL(__NR_mq_notify, sys_mq_notify)
#define __NR_mq_getsetattr			245
__SYSCALL(__NR_mq_getsetattr, sys_mq_getsetattr)
#define __NR_kexec_load				246
__SYSCALL(__NR_kexec_load, sys_kexec_load)
#define __NR_waitid				247
__SYSCALL(__NR_waitid, sys_waitid)
#define __NR_add_key				248
__SYSCALL(__NR_add_key, sys_add_key)
#define __NR_request_key			249
__SYSCALL(__NR_request_key, sys_request_key)
#define __NR_keyctl				250
__SYSCALL(__NR_keyctl, sys_keyctl)
#define __NR_ioprio_set				251
__SYSCALL(__NR_ioprio_set, sys_ioprio_set)
#define __NR_ioprio_get				252
__SYSCALL(__NR_ioprio_get, sys_ioprio_get)
#define __NR_inotify_init			253
__SYSCALL(__NR_inotify_init, sys_inotify_init)
#define __NR_inotify_add_watch			254
__SYSCALL(__NR_inotify_add_watch, sys_inotify_add_watch)
#define __NR_inotify_rm_watch			255
__SYSCALL(__NR_inotify_rm_watch, sys_inotify_rm_watch)
#define __NR_migrate_pages			256
__SYSCALL(__NR_migrate_pages, sys_migrate_pages)
#define __NR_openat				257
__SYSCALL(__NR_openat, sys_openat)
#define __NR_mkdirat				258
__SYSCALL(__NR_mkdirat, sys_mkdirat)
#define __NR_mknodat				259
__SYSCALL(__NR_mknodat, sys_mknodat)
#define __NR_fchownat				260
__SYSCALL(__NR_fchownat, sys_fchownat)
#define __NR_futimesat				261
__SYSCALL(__NR_futimesat, sys_futimesat)
#define __NR_newfstatat				262
__SYSCALL(__NR_newfstatat, sys_newfstatat)
#define __NR_unlinkat				263
__SYSCALL(__NR_unlinkat, sys_unlinkat)
#define __NR_renameat				264
__SYSCALL(__NR_renameat, sys_renameat)
#define __NR_linkat				265
__SYSCALL(__NR_linkat, sys_linkat)
#define __NR_symlinkat				266
__SYSCALL(__NR_symlinkat, sys_symlinkat)
#define __NR_readlinkat				267
__SYSCALL(__NR_readlinkat, sys_readlinkat)
#define __NR_fchmodat				268
__SYSCALL(__NR_fchmodat, sys_fchmodat)
#define __NR_faccessat				269
__SYSCALL(__NR_faccessat, sys_faccessat)
#define __NR_pselect6				270
__SYSCALL(__NR_pselect6, sys_pselect6)
#define __NR_ppoll				271
__SYSCALL(__NR_ppoll,	sys_ppoll)
#define __NR_unshare				272
__SYSCALL(__NR_unshare,	sys_unshare)
#define __NR_set_robust_list			273
__SYSCALL(__NR_set_robust_list, sys_set_robust_list)
#define __NR_get_robust_list			274
__SYSCALL(__NR_get_robust_list, sys_get_robust_list)
#define __NR_splice				275
__SYSCALL(__NR_splice, sys_splice)
#define __NR_tee				276
__SYSCALL(__NR_tee, sys_tee)
#define __NR_sync_file_range			277
__SYSCALL(__NR_sync_file_range, sys_sync_file_range)
#define __NR_vmsplice				278
__SYSCALL(__NR_vmsplice, sys_vmsplice)
#define __NR_move_pages				279
__SYSCALL(__NR_move_pages, sys_move_pages)
#define __NR_utimensat				280
__SYSCALL(__NR_utimensat, sys_utimensat)
#define __IGNORE_getcpu		/* implemented as a vsyscall */
#define __NR_epoll_pwait			281
__SYSCALL(__NR_epoll_pwait, sys_epoll_pwait)
#define __NR_signalfd				282
__SYSCALL(__NR_signalfd, sys_signalfd)
#define __NR_timerfd_create			283
__SYSCALL(__NR_timerfd_create, sys_timerfd_create)
#define __NR_eventfd				284
__SYSCALL(__NR_eventfd, sys_eventfd)
#define __NR_fallocate				285
__SYSCALL(__NR_fallocate, sys_fallocate)
#define __NR_timerfd_settime			286
__SYSCALL(__NR_timerfd_settime, sys_timerfd_settime)
#define __NR_timerfd_gettime			287
__SYSCALL(__NR_timerfd_gettime, sys_timerfd_gettime)
#define __NR_accept4				288
__SYSCALL(__NR_accept4, sys_accept4)
#define __NR_signalfd4				289
__SYSCALL(__NR_signalfd4, sys_signalfd4)
#define __NR_eventfd2				290
__SYSCALL(__NR_eventfd2, sys_eventfd2)
#define __NR_epoll_create1			291
__SYSCALL(__NR_epoll_create1, sys_epoll_create1)
#define __NR_dup3				292
__SYSCALL(__NR_dup3, sys_dup3)
#define __NR_pipe2				293
__SYSCALL(__NR_pipe2, sys_pipe2)
#define __NR_inotify_init1			294
__SYSCALL(__NR_inotify_init1, sys_inotify_init1)
#define __NR_preadv				295
__SYSCALL(__NR_preadv, sys_preadv)
#define __NR_pwritev				296
__SYSCALL(__NR_pwritev, sys_pwritev)
#define __NR_rt_tgsigqueueinfo			297
__SYSCALL(__NR_rt_tgsigqueueinfo, sys_rt_tgsigqueueinfo)
#define __NR_perf_event_open			298
__SYSCALL(__NR_perf_event_open, sys_perf_event_open)
#define __NR_recvmmsg				299
__SYSCALL(__NR_recvmmsg, sys_recvmmsg)
#define __NR_fanotify_init			300
__SYSCALL(__NR_fanotify_init, sys_fanotify_init)
#define __NR_fanotify_mark			301
__SYSCALL(__NR_fanotify_mark, sys_fanotify_mark)
#define __NR_prlimit64				302
__SYSCALL(__NR_prlimit64, sys_prlimit64)

#ifndef __NO_STUBS
#define __ARCH_WANT_OLD_READDIR
#define __ARCH_WANT_OLD_STAT
#define __ARCH_WANT_SYS_ALARM
#define __ARCH_WANT_SYS_GETHOSTNAME
#define __ARCH_WANT_SYS_PAUSE
#define __ARCH_WANT_SYS_SGETMASK
#define __ARCH_WANT_SYS_SIGNAL
#define __ARCH_WANT_SYS_UTIME
#define __ARCH_WANT_SYS_WAITPID
#define __ARCH_WANT_SYS_SOCKETCALL
#define __ARCH_WANT_SYS_FADVISE64
#define __ARCH_WANT_SYS_GETPGRP
#define __ARCH_WANT_SYS_LLSEEK
#define __ARCH_WANT_SYS_NICE
#define __ARCH_WANT_SYS_OLD_GETRLIMIT
#define __ARCH_WANT_SYS_OLD_UNAME
#define __ARCH_WANT_SYS_OLDUMOUNT
#define __ARCH_WANT_SYS_SIGPENDING
#define __ARCH_WANT_SYS_SIGPROCMASK
#define __ARCH_WANT_SYS_RT_SIGACTION
#define __ARCH_WANT_SYS_RT_SIGSUSPEND
#define __ARCH_WANT_SYS_TIME
#define __ARCH_WANT_COMPAT_SYS_TIME
#endif	/* __NO_STUBS */


#endif /* _ASM_X86_UNISTD_64_H */
                                                                                                                                                         #ifndef _ASM_X86_VSYSCALL_H
#define _ASM_X86_VSYSCALL_H

enum vsyscall_num {
	__NR_vgettimeofday,
	__NR_vtime,
	__NR_vgetcpu,
};

#define VSYSCALL_START (-10UL << 20)
#define VSYSCALL_SIZE 1024
#define VSYSCALL_END (-2UL << 20)
#define VSYSCALL_MAPPED_PAGES 1
#define VSYSCALL_ADDR(vsyscall_nr) (VSYSCALL_START+VSYSCALL_SIZE*(vsyscall_nr))


#endif /* _ASM_X86_VSYSCALL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #include <asm-generic/param.h>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #ifndef _ASM_X86_MMAN_H
#define _ASM_X86_MMAN_H

#define MAP_32BIT	0x40		/* only give out 32bit addresses */

#include <asm-generic/mman.h>

#endif /* _ASM_X86_MMAN_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ô-   .   _$   ..  ö-   if_shaper.h õ-   
ppp-comp.h  ú-   	if_slip.h   ù-   if_packet.h û-   
ppp_defs.h  ü-   if_arp.h†-   if_ppp.h°-   if.h¢-   
ethernet.h  £-  Droute.h                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /* Copyright (C) 1998 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef _NET_IF_SHAPER_H
#define _NET_IF_SHAPER_H 1

#include <features.h>
#include <sys/types.h>
#include <net/if.h>
#include <sys/ioctl.h>

__BEGIN_DECLS

#define SHAPER_QLEN	10
/*
 *	This is a bit speed dependant (read it shouldnt be a constant!)
 *
 *	5 is about right for 28.8 upwards. Below that double for every
 *	halving of speed or so. - ie about 20 for 9600 baud.
 */
#define SHAPER_LATENCY	(5 * HZ)
#define SHAPER_MAXSLIP	2
#define SHAPER_BURST	(HZ / 50)	/* Good for >128K then */

#define SHAPER_SET_DEV		0x0001
#define SHAPER_SET_SPEED	0x0002
#define SHAPER_GET_DEV		0x0003
#define SHAPER_GET_SPEED	0x0004

struct shaperconf
{
  u_int16_t ss_cmd;
  union
  {
    char ssu_name[14];
    u_int32_t ssu_speed;
  } ss_u;
#define ss_speed ss_u.ssu_speed
#define ss_name ss_u.ssu_name
};

__END_DECLS

#endif /* net/if_shaper.h */
                                                                                                                                                                                                                                                                                                                                                                      #include <linux/ppp-comp.h>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /* Copyright (C) 1997 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef _NET_IF_SLIP_H
#define _NET_IF_SLIP_H 1

/* We can use the kernel header.  */
#include <linux/if_slip.h>

#endif	/* net/if_slip.h.  */
                              /* Definitions for use with Linux SOCK_PACKET sockets.
   Copyright (C) 1997, 1998 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef __IF_PACKET_H
#define __IF_PACKET_H

#include <features.h>
#include <bits/sockaddr.h>

/* This is the SOCK_PACKET address structure as used in Linux 2.0.
   From Linux 2.1 the AF_PACKET interface is preferred and you should
   consider using it in place of this one.  */

struct sockaddr_pkt
  {
    __SOCKADDR_COMMON (spkt_);
    unsigned char spkt_device[14];
    unsigned short spkt_protocol;
  };

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #ifndef _NET_PPP_DEFS_H
#define _NET_PPP_DEFS_H 1

#define __need_time_t
#include <time.h>

#include <asm/types.h>
#include <linux/ppp_defs.h>

#endif /* net/ppp_defs.h */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /* Definitions for Address Resolution Protocol.
   Copyright (C) 1997,1999,2001,2006 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/* Based on the 4.4BSD and Linux version of this file.  */

#ifndef _NET_IF_ARP_H

#define _NET_IF_ARP_H 1
#include <sys/cdefs.h>

#include <sys/types.h>
#include <sys/socket.h>

__BEGIN_DECLS

/* Some internals from deep down in the kernel.  */
#define MAX_ADDR_LEN	7


/* This structure defines an ethernet arp header.  */

/* ARP protocol opcodes. */
#define	ARPOP_REQUEST	1		/* ARP request.  */
#define	ARPOP_REPLY	2		/* ARP reply.  */
#define	ARPOP_RREQUEST	3		/* RARP request.  */
#define	ARPOP_RREPLY	4		/* RARP reply.  */
#define	ARPOP_InREQUEST	8		/* InARP request.  */
#define	ARPOP_InREPLY	9		/* InARP reply.  */
#define	ARPOP_NAK	10		/* (ATM)ARP NAK.  */

/* See RFC 826 for protocol description.  ARP packets are variable
   in size; the arphdr structure defines the fixed-length portion.
   Protocol type values are the same as those for 10 Mb/s Ethernet.
   It is followed by the variable-sized fields ar_sha, arp_spa,
   arp_tha and arp_tpa in that order, according to the lengths
   specified.  Field names used correspond to RFC 826.  */

struct arphdr
  {
    unsigned short int ar_hrd;		/* Format of hardware address.  */
    unsigned short int ar_pro;		/* Format of protocol address.  */
    unsigned char ar_hln;		/* Length of hardware address.  */
    unsigned char ar_pln;		/* Length of protocol address.  */
    unsigned short int ar_op;		/* ARP opcode (command).  */
#if 0
    /* Ethernet looks like this : This bit is variable sized
       however...  */
    unsigned char __ar_sha[ETH_ALEN];	/* Sender hardware address.  */
    unsigned char __ar_sip[4];		/* Sender IP address.  */
    unsigned char __ar_tha[ETH_ALEN];	/* Target hardware address.  */
    unsigned char __ar_tip[4];		/* Target IP address.  */
#endif
  };


/* ARP protocol HARDWARE identifiers. */
#define ARPHRD_NETROM	0		/* From KA9Q: NET/ROM pseudo. */
#define ARPHRD_ETHER 	1		/* Ethernet 10/100Mbps.  */
#define	ARPHRD_EETHER	2		/* Experimental Ethernet.  */
#define	ARPHRD_AX25	3		/* AX.25 Level 2.  */
#define	ARPHRD_PRONET	4		/* PROnet token ring.  */
#define	ARPHRD_CHAOS	5		/* Chaosnet.  */
#define	ARPHRD_IEEE802	6		/* IEEE 802.2 Ethernet/TR/TB.  */
#define	ARPHRD_ARCNET	7		/* ARCnet.  */
#define	ARPHRD_APPLETLK	8		/* APPLEtalk.  */
#define	ARPHRD_DLCI	15		/* Frame Relay DLCI.  */
#define	ARPHRD_ATM	19		/* ATM.  */
#define	ARPHRD_METRICOM	23		/* Metricom STRIP (new IANA id).  */
#define ARPHRD_IEEE1394	24		/* IEEE 1394 IPv4 - RFC 2734.  */
#define ARPHRD_EUI64		27		/* EUI-64.  */
#define ARPHRD_INFINIBAND	32		/* InfiniBand.  */

/* Dummy types for non ARP hardware */
#define ARPHRD_SLIP	256
#define ARPHRD_CSLIP	257
#define ARPHRD_SLIP6	258
#define ARPHRD_CSLIP6	259
#define ARPHRD_RSRVD	260		/* Notional KISS type.  */
#define ARPHRD_ADAPT	264
#define ARPHRD_ROSE	270
#define ARPHRD_X25	271		/* CCITT X.25.  */
#define ARPHRD_HWX25	272		/* Boards with X.25 in firmware.  */
#define ARPHRD_PPP	512
#define ARPHRD_CISCO	513		/* Cisco HDLC.  */
#define ARPHRD_HDLC	ARPHRD_CISCO
#define ARPHRD_LAPB	516		/* LAPB.  */
#define ARPHRD_DDCMP	517		/* Digital's DDCMP.  */
#define	ARPHRD_RAWHDLC	518		/* Raw HDLC.  */

#define ARPHRD_TUNNEL	768		/* IPIP tunnel.  */
#define ARPHRD_TUNNEL6	769		/* IPIP6 tunnel.  */
#define ARPHRD_FRAD	770             /* Frame Relay Access Device.  */
#define ARPHRD_SKIP	771		/* SKIP vif.  */
#define ARPHRD_LOOPBACK	772		/* Loopback device.  */
#define ARPHRD_LOCALTLK 773		/* Localtalk device.  */
#define ARPHRD_FDDI	774		/* Fiber Distributed Data Interface. */
#define ARPHRD_BIF	775             /* AP1000 BIF.  */
#define ARPHRD_SIT	776		/* sit0 device - IPv6-in-IPv4.  */
#define ARPHRD_IPDDP	777		/* IP-in-DDP tunnel.  */
#define ARPHRD_IPGRE	778		/* GRE over IP.  */
#define ARPHRD_PIMREG	779		/* PIMSM register interface.  */
#define ARPHRD_HIPPI	780		/* High Performance Parallel I'face. */
#define ARPHRD_ASH	781		/* (Nexus Electronics) Ash.  */
#define ARPHRD_ECONET	782		/* Acorn Econet.  */
#define ARPHRD_IRDA	783		/* Linux-IrDA.  */
#define ARPHRD_FCPP	784		/* Point to point fibrechanel.  */
#define ARPHRD_FCAL	785		/* Fibrechanel arbitrated loop.  */
#define ARPHRD_FCPL	786		/* Fibrechanel public loop.  */
#define ARPHRD_FCFABRIC 787		/* Fibrechanel fabric.  */
#define ARPHRD_IEEE802_TR 800		/* Magic type ident for TR.  */
#define ARPHRD_IEEE80211 801		/* IEEE 802.11.  */
#define ARPHRD_IEEE80211_PRISM 802	/* IEEE 802.11 + Prism2 header.  */
#define ARPHRD_IEEE80211_RADIOTAP 803	/* IEEE 802.11 + radiotap header.  */

#define ARPHRD_VOID	  0xFFFF	/* Void type, nothing is known.  */
#define ARPHRD_NONE	  0xFFFE	/* Zero header length.  */


/* ARP ioctl request.  */
struct arpreq
  {
    struct sockaddr arp_pa;		/* Protocol address.  */
    struct sockaddr arp_ha;		/* Hardware address.  */
    int arp_flags;			/* Flags.  */
    struct sockaddr arp_netmask;	/* Netmask (only for proxy arps).  */
    char arp_dev[16];
  };

struct arpreq_old
  {
    struct sockaddr arp_pa;		/* Protocol address.  */
    struct sockaddr arp_ha;		/* Hardware address.  */
    int arp_flags;			/* Flags.  */
    struct sockaddr arp_netmask;	/* Netmask (only for proxy arps).  */
  };

/* ARP Flag values.  */
#define ATF_COM		0x02		/* Completed entry (ha valid).  */
#define	ATF_PERM	0x04		/* Permanent entry.  */
#define	ATF_PUBL	0x08		/* Publish entry.  */
#define	ATF_USETRAILERS	0x10		/* Has requested trailers.  */
#define ATF_NETMASK     0x20            /* Want to use a netmask (only
					   for proxy entries).  */
#define ATF_DONTPUB	0x40		/* Don't answer this addresses.  */
#define ATF_MAGIC	0x80		/* Automatically added entry.  */


/* Support for the user space arp daemon, arpd.  */
#define ARPD_UPDATE	0x01
#define ARPD_LOOKUP	0x02
#define ARPD_FLUSH	0x03

struct arpd_request
  {
    unsigned short int req;		/* Request type.  */
    u_int32_t ip;			/* IP address of entry.  */
    unsigned long int dev;		/* Device entry is tied to.  */
    unsigned long int stamp;
    unsigned long int updated;
    unsigned char ha[MAX_ADDR_LEN];	/* Hardware address.  */
  };

__END_DECLS

#endif	/* net/if_arp.h */
                                                                                                                           /*	From: if_ppp.h,v 1.3 1995/06/12 11:36:50 paulus Exp */

/*
 * if_ppp.h - Point-to-Point Protocol definitions.
 *
 * Copyright (c) 1989 Carnegie Mellon University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
 * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 *  ==FILEVERSION 960926==
 *
 *  NOTE TO MAINTAINERS:
 *     If you modify this file at all, please set the above date.
 *     if_ppp.h is shipped with a PPP distribution as well as with the kernel;
 *     if everyone increases the FILEVERSION number above, then scripts
 *     can do the right thing when deciding whether to install a new if_ppp.h
 *     file.  Don't change the format of that line otherwise, so the
 *     installation script can recognize it.
 */


#ifndef __NET_IF_PPP_H
#define __NET_IF_PPP_H 1

#include <sys/types.h>
#include <sys/cdefs.h>

#include <net/if.h>
#include <sys/ioctl.h>
#include <net/ppp_defs.h>

__BEGIN_DECLS

/*
 * Packet sizes
 */

#define	PPP_MTU		1500	/* Default MTU (size of Info field) */
#define PPP_MAXMRU	65000	/* Largest MRU we allow */
#define PPP_VERSION	"2.2.0"
#define PPP_MAGIC	0x5002	/* Magic value for the ppp structure */
#define PROTO_IPX	0x002b	/* protocol numbers */
#define PROTO_DNA_RT    0x0027  /* DNA Routing */


/*
 * Bit definitions for flags.
 */

#define SC_COMP_PROT	0x00000001	/* protocol compression (output) */
#define SC_COMP_AC	0x00000002	/* header compression (output) */
#define	SC_COMP_TCP	0x00000004	/* TCP (VJ) compression (output) */
#define SC_NO_TCP_CCID	0x00000008	/* disable VJ connection-id comp. */
#define SC_REJ_COMP_AC	0x00000010	/* reject adrs/ctrl comp. on input */
#define SC_REJ_COMP_TCP	0x00000020	/* reject TCP (VJ) comp. on input */
#define SC_CCP_OPEN	0x00000040	/* Look at CCP packets */
#define SC_CCP_UP	0x00000080	/* May send/recv compressed packets */
#define SC_ENABLE_IP	0x00000100	/* IP packets may be exchanged */
#define SC_COMP_RUN	0x00001000	/* compressor has been inited */
#define SC_DECOMP_RUN	0x00002000	/* decompressor has been inited */
#define SC_DEBUG	0x00010000	/* enable debug messages */
#define SC_LOG_INPKT	0x00020000	/* log contents of good pkts recvd */
#define SC_LOG_OUTPKT	0x00040000	/* log contents of pkts sent */
#define SC_LOG_RAWIN	0x00080000	/* log all chars received */
#define SC_LOG_FLUSH	0x00100000	/* log all chars flushed */
#define	SC_MASK		0x0fE0ffff	/* bits that user can change */

/* state bits */
#define	SC_ESCAPED	0x80000000	/* saw a PPP_ESCAPE */
#define	SC_FLUSH	0x40000000	/* flush input until next PPP_FLAG */
#define SC_VJ_RESET	0x20000000	/* Need to reset the VJ decompressor */
#define SC_XMIT_BUSY	0x10000000	/* ppp_write_wakeup is active */
#define SC_RCV_ODDP	0x08000000	/* have rcvd char with odd parity */
#define SC_RCV_EVNP	0x04000000	/* have rcvd char with even parity */
#define SC_RCV_B7_1	0x02000000	/* have rcvd char with bit 7 = 1 */
#define SC_RCV_B7_0	0x01000000	/* have rcvd char with bit 7 = 0 */
#define SC_DC_FERROR	0x00800000	/* fatal decomp error detected */
#define SC_DC_ERROR	0x00400000	/* non-fatal decomp error detected */

/*
 * Ioctl definitions.
 */

struct npioctl {
    int		protocol;	/* PPP protocol, e.g. PPP_IP */
    enum NPmode	mode;
};

/* Structure describing a CCP configuration option, for PPPIOCSCOMPRESS */
struct ppp_option_data {
	u_int8_t  *ptr;
	u_int32_t length;
	int	  transmit;
};

struct ifpppstatsreq {
  struct ifreq	   b;
  struct ppp_stats stats;			/* statistic information */
};

struct ifpppcstatsreq {
  struct ifreq		b;
  struct ppp_comp_stats stats;
};

#define ifr__name       b.ifr_ifrn.ifrn_name
#define stats_ptr       b.ifr_ifru.ifru_data

/*
 * Ioctl definitions.
 */

#define	PPPIOCGFLAGS	_IOR('t', 90, int)	/* get configuration flags */
#define	PPPIOCSFLAGS	_IOW('t', 89, int)	/* set configuration flags */
#define	PPPIOCGASYNCMAP	_IOR('t', 88, int)	/* get async map */
#define	PPPIOCSASYNCMAP	_IOW('t', 87, int)	/* set async map */
#define	PPPIOCGUNIT	_IOR('t', 86, int)	/* get ppp unit number */
#define	PPPIOCGRASYNCMAP _IOR('t', 85, int)	/* get receive async map */
#define	PPPIOCSRASYNCMAP _IOW('t', 84, int)	/* set receive async map */
#define	PPPIOCGMRU	_IOR('t', 83, int)	/* get max receive unit */
#define	PPPIOCSMRU	_IOW('t', 82, int)	/* set max receive unit */
#define	PPPIOCSMAXCID	_IOW('t', 81, int)	/* set VJ max slot ID */
#define PPPIOCGXASYNCMAP _IOR('t', 80, ext_accm) /* get extended ACCM */
#define PPPIOCSXASYNCMAP _IOW('t', 79, ext_accm) /* set extended ACCM */
#define PPPIOCXFERUNIT	_IO('t', 78)		/* transfer PPP unit */
#define PPPIOCSCOMPRESS	_IOW('t', 77, struct ppp_option_data)
#define PPPIOCGNPMODE	_IOWR('t', 76, struct npioctl) /* get NP mode */
#define PPPIOCSNPMODE	_IOW('t', 75, struct npioctl)  /* set NP mode */
#define PPPIOCGDEBUG	_IOR('t', 65, int)	/* Read debug level */
#define PPPIOCSDEBUG	_IOW('t', 64, int)	/* Set debug level */
#define PPPIOCGIDLE	_IOR('t', 63, struct ppp_idle) /* get idle time */

#define SIOCGPPPSTATS   (SIOCDEVPRIVATE + 0)
#define SIOCGPPPVER     (SIOCDEVPRIVATE + 1)  /* NEVER change this!! */
#define SIOCGPPPCSTATS  (SIOCDEVPRIVATE + 2)

#if !defined(ifr_mtu)
#define ifr_mtu	ifr_ifru.ifru_metric
#endif

__END_DECLS

#endif /* net/if_ppp.h */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /* net/if.h -- declarations for inquiring about network interfaces
   Copyright (C) 1997,98,99,2000,2001 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef _NET_IF_H
#define _NET_IF_H	1

#include <features.h>

#ifdef __USE_MISC
# include <sys/types.h>
# include <sys/socket.h>
#endif


/* Length of interface name.  */
#define IF_NAMESIZE	16

struct if_nameindex
  {
    unsigned int if_index;	/* 1, 2, ... */
    char *if_name;		/* null terminated name: "eth0", ... */
  };


#ifdef __USE_MISC
/* Standard interface flags. */
enum
  {
    IFF_UP = 0x1,		/* Interface is up.  */
# define IFF_UP	IFF_UP
    IFF_BROADCAST = 0x2,	/* Broadcast address valid.  */
# define IFF_BROADCAST	IFF_BROADCAST
    IFF_DEBUG = 0x4,		/* Turn on debugging.  */
# define IFF_DEBUG	IFF_DEBUG
    IFF_LOOPBACK = 0x8,		/* Is a loopback net.  */
# define IFF_LOOPBACK	IFF_LOOPBACK
    IFF_POINTOPOINT = 0x10,	/* Interface is point-to-point link.  */
# define IFF_POINTOPOINT IFF_POINTOPOINT
    IFF_NOTRAILERS = 0x20,	/* Avoid use of trailers.  */
# define IFF_NOTRAILERS	IFF_NOTRAILERS
    IFF_RUNNING = 0x40,		/* Resources allocated.  */
# define IFF_RUNNING	IFF_RUNNING
    IFF_NOARP = 0x80,		/* No address resolution protocol.  */
# define IFF_NOARP	IFF_NOARP
    IFF_PROMISC = 0x100,	/* Receive all packets.  */
# define IFF_PROMISC	IFF_PROMISC

    /* Not supported */
    IFF_ALLMULTI = 0x200,	/* Receive all multicast packets.  */
# define IFF_ALLMULTI	IFF_ALLMULTI

    IFF_MASTER = 0x400,		/* Master of a load balancer.  */
# define IFF_MASTER	IFF_MASTER
    IFF_SLAVE = 0x800,		/* Slave of a load balancer.  */
# define IFF_SLAVE	IFF_SLAVE

    IFF_MULTICAST = 0x1000,	/* Supports multicast.  */
# define IFF_MULTICAST	IFF_MULTICAST

    IFF_PORTSEL = 0x2000,	/* Can set media type.  */
# define IFF_PORTSEL	IFF_PORTSEL
    IFF_AUTOMEDIA = 0x4000,	/* Auto media select active.  */
# define IFF_AUTOMEDIA	IFF_AUTOMEDIA
    IFF_DYNAMIC = 0x8000	/* Dialup device with changing addresses.  */
# define IFF_DYNAMIC	IFF_DYNAMIC
  };

/* The ifaddr structure contains information about one address of an
   interface.  They are maintained by the different address families,
   are allocated and attached when an address is set, and are linked
   together so all addresses for an interface can be located.  */

struct ifaddr
  {
    struct sockaddr ifa_addr;	/* Address of interface.  */
    union
      {
	struct sockaddr	ifu_broadaddr;
	struct sockaddr	ifu_dstaddr;
      } ifa_ifu;
    struct iface *ifa_ifp;	/* Back-pointer to interface.  */
    struct ifaddr *ifa_next;	/* Next address for interface.  */
  };

# define ifa_broadaddr	ifa_ifu.ifu_broadaddr	/* broadcast address	*/
# define ifa_dstaddr	ifa_ifu.ifu_dstaddr	/* other end of link	*/

/* Device mapping structure. I'd just gone off and designed a
   beautiful scheme using only loadable modules with arguments for
   driver options and along come the PCMCIA people 8)

   Ah well. The get() side of this is good for WDSETUP, and it'll be
   handy for debugging things. The set side is fine for now and being
   very small might be worth keeping for clean configuration.  */

struct ifmap
  {
    unsigned long int mem_start;
    unsigned long int mem_end;
    unsigned short int base_addr;
    unsigned char irq;
    unsigned char dma;
    unsigned char port;
    /* 3 bytes spare */
  };

/* Interface request structure used for socket ioctl's.  All interface
   ioctl's must have parameter definitions which begin with ifr_name.
   The remainder may be interface specific.  */

struct ifreq
  {
# define IFHWADDRLEN	6
# define IFNAMSIZ	IF_NAMESIZE
    union
      {
	char ifrn_name[IFNAMSIZ];	/* Interface name, e.g. "en0".  */
      } ifr_ifrn;

    union
      {
	struct sockaddr ifru_addr;
	struct sockaddr ifru_dstaddr;
	struct sockaddr ifru_broadaddr;
	struct sockaddr ifru_netmask;
	struct sockaddr ifru_hwaddr;
	short int ifru_flags;
	int ifru_ivalue;
	int ifru_mtu;
	struct ifmap ifru_map;
	char ifru_slave[IFNAMSIZ];	/* Just fits the size */
	char ifru_newname[IFNAMSIZ];
	__caddr_t ifru_data;
      } ifr_ifru;
  };
# define ifr_name	ifr_ifrn.ifrn_name	/* interface name 	*/
# define ifr_hwaddr	ifr_ifru.ifru_hwaddr	/* MAC address 		*/
# define ifr_addr	ifr_ifru.ifru_addr	/* address		*/
# define ifr_dstaddr	ifr_ifru.ifru_dstaddr	/* other end of p-p lnk	*/
# define ifr_broadaddr	ifr_ifru.ifru_broadaddr	/* broadcast address	*/
# define ifr_netmask	ifr_ifru.ifru_netmask	/* interface net mask	*/
# define ifr_flags	ifr_ifru.ifru_flags	/* flags		*/
# define ifr_metric	ifr_ifru.ifru_ivalue	/* metric		*/
# define ifr_mtu	ifr_ifru.ifru_mtu	/* mtu			*/
# define ifr_map	ifr_ifru.ifru_map	/* device map		*/
# define ifr_slave	ifr_ifru.ifru_slave	/* slave device		*/
# define ifr_data	ifr_ifru.ifru_data	/* for use by interface	*/
# define ifr_ifindex	ifr_ifru.ifru_ivalue    /* interface index      */
# define ifr_bandwidth	ifr_ifru.ifru_ivalue	/* link bandwidth	*/
# define ifr_qlen	ifr_ifru.ifru_ivalue	/* queue length		*/
# define ifr_newname	ifr_ifru.ifru_newname	/* New name		*/
# define _IOT_ifreq	_IOT(_IOTS(char),IFNAMSIZ,_IOTS(char),16,0,0)
# define _IOT_ifreq_short _IOT(_IOTS(char),IFNAMSIZ,_IOTS(short),1,0,0)
# define _IOT_ifreq_int	_IOT(_IOTS(char),IFNAMSIZ,_IOTS(int),1,0,0)


/* Structure used in SIOCGIFCONF request.  Used to retrieve interface
   configuration for machine (useful for programs which must know all
   networks accessible).  */

struct ifconf
  {
    int	ifc_len;			/* Size of buffer.  */
    union
      {
	__caddr_t ifcu_buf;
	struct ifreq *ifcu_req;
      } ifc_ifcu;
  };
# define ifc_buf	ifc_ifcu.ifcu_buf	/* Buffer address.  */
# define ifc_req	ifc_ifcu.ifcu_req	/* Array of structures.  */
# define _IOT_ifconf _IOT(_IOTS(struct ifconf),1,0,0,0,0) /* not right */
#endif	/* Misc.  */

__BEGIN_DECLS

/* Convert an interface name to an index, and vice versa.  */
extern unsigned int if_nametoindex (__const char *__ifname) __THROW;
extern char *if_indextoname (unsigned int __ifindex, char *__ifname) __THROW;

/* Return a list of all interfaces and their indices.  */
extern struct if_nameindex *if_nameindex (void) __THROW;

/* Free the data returned from if_nameindex.  */
extern void if_freenameindex (struct if_nameindex *__ptr) __THROW;

__END_DECLS

#endif /* net/if.h */
                                                                                                           /* Copyright (C) 1997, 1999, 2001, 2008 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/* Based on the FreeBSD version of this file. Curiously, that file
   lacks a copyright in the header. */

#ifndef __NET_ETHERNET_H
#define __NET_ETHERNET_H 1

#include <sys/cdefs.h>
#include <sys/types.h>
#include <linux/if_ether.h>     /* IEEE 802.3 Ethernet constants */

__BEGIN_DECLS

/* This is a name for the 48 bit ethernet address available on many
   systems.  */
struct ether_addr
{
  u_int8_t ether_addr_octet[ETH_ALEN];
} __attribute__ ((__packed__));

/* 10Mb/s ethernet header */
struct ether_header
{
  u_int8_t  ether_dhost[ETH_ALEN];	/* destination eth addr	*/
  u_int8_t  ether_shost[ETH_ALEN];	/* source ether addr	*/
  u_int16_t ether_type;		        /* packet type ID field	*/
} __attribute__ ((__packed__));

/* Ethernet protocol ID's */
#define	ETHERTYPE_PUP		0x0200          /* Xerox PUP */
#define ETHERTYPE_SPRITE	0x0500		/* Sprite */
#define	ETHERTYPE_IP		0x0800		/* IP */
#define	ETHERTYPE_ARP		0x0806		/* Address resolution */
#define	ETHERTYPE_REVARP	0x8035		/* Reverse ARP */
#define ETHERTYPE_AT		0x809B		/* AppleTalk protocol */
#define ETHERTYPE_AARP		0x80F3		/* AppleTalk ARP */
#define	ETHERTYPE_VLAN		0x8100		/* IEEE 802.1Q VLAN tagging */
#define ETHERTYPE_IPX		0x8137		/* IPX */
#define	ETHERTYPE_IPV6		0x86dd		/* IP protocol version 6 */
#define ETHERTYPE_LOOPBACK	0x9000		/* used to test interfaces */


#define	ETHER_ADDR_LEN	ETH_ALEN                 /* size of ethernet addr */
#define	ETHER_TYPE_LEN	2                        /* bytes in type field */
#define	ETHER_CRC_LEN	4                        /* bytes in CRC field */
#define	ETHER_HDR_LEN	ETH_HLEN                 /* total octets in header */
#define	ETHER_MIN_LEN	(ETH_ZLEN + ETHER_CRC_LEN) /* min packet length */
#define	ETHER_MAX_LEN	(ETH_FRAME_LEN + ETHER_CRC_LEN) /* max packet length */

/* make sure ethenet length is valid */
#define	ETHER_IS_VALID_LEN(foo)	\
	((foo) >= ETHER_MIN_LEN && (foo) <= ETHER_MAX_LEN)

/*
 * The ETHERTYPE_NTRAILER packet types starting at ETHERTYPE_TRAIL have
 * (type-ETHERTYPE_TRAIL)*512 bytes of data followed
 * by an ETHER type (as given above) and then the (variable-length) header.
 */
#define	ETHERTYPE_TRAIL		0x1000		/* Trailer packet */
#define	ETHERTYPE_NTRAILER	16

#define	ETHERMTU	ETH_DATA_LEN
#define	ETHERMIN	(ETHER_MIN_LEN - ETHER_HDR_LEN - ETHER_CRC_LEN)

__END_DECLS

#endif	/* net/ethernet.h */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /* Copyright (C) 1997, 2002 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/* Based on the 4.4BSD and Linux version of this file.  */

#ifndef _NET_ROUTE_H
#define _NET_ROUTE_H	1

#include <features.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <bits/wordsize.h>


/* This structure gets passed by the SIOCADDRT and SIOCDELRT calls. */
struct rtentry
  {
    unsigned long int rt_pad1;
    struct sockaddr rt_dst;		/* Target address.  */
    struct sockaddr rt_gateway;		/* Gateway addr (RTF_GATEWAY).  */
    struct sockaddr rt_genmask;		/* Target network mask (IP).  */
    unsigned short int rt_flags;
    short int rt_pad2;
    unsigned long int rt_pad3;
    unsigned char rt_tos;
    unsigned char rt_class;
#if __WORDSIZE == 64
    short int rt_pad4[3];
#else
    short int rt_pad4;
#endif
    short int rt_metric;		/* +1 for binary compatibility!  */
    char *rt_dev;			/* Forcing the device at add.  */
    unsigned long int rt_mtu;		/* Per route MTU/Window.  */
    unsigned long int rt_window;	/* Window clamping.  */
    unsigned short int rt_irtt;		/* Initial RTT.  */
  };
/* Compatibility hack.  */
#define rt_mss	rt_mtu


struct in6_rtmsg
  {
    struct in6_addr rtmsg_dst;
    struct in6_addr rtmsg_src;
    struct in6_addr rtmsg_gateway;
    u_int32_t rtmsg_type;
    u_int16_t rtmsg_dst_len;
    u_int16_t rtmsg_src_len;
    u_int32_t rtmsg_metric;
    unsigned long int rtmsg_info;
    u_int32_t rtmsg_flags;
    int rtmsg_ifindex;
  };


#define	RTF_UP		0x0001		/* Route usable.  */
#define	RTF_GATEWAY	0x0002		/* Destination is a gateway.  */

#define	RTF_HOST	0x0004		/* Host entry (net otherwise).  */
#define RTF_REINSTATE	0x0008		/* Reinstate route after timeout.  */
#define	RTF_DYNAMIC	0x0010		/* Created dyn. (by redirect).  */
#define	RTF_MODIFIED	0x0020		/* Modified dyn. (by redirect).  */
#define RTF_MTU		0x0040		/* Specific MTU for this route.  */
#define RTF_MSS		RTF_MTU		/* Compatibility.  */
#define RTF_WINDOW	0x0080		/* Per route window clamping.  */
#define RTF_IRTT	0x0100		/* Initial round trip time.  */
#define RTF_REJECT	0x0200		/* Reject route.  */
#define	RTF_STATIC	0x0400		/* Manually injected route.  */
#define	RTF_XRESOLVE	0x0800		/* External resolver.  */
#define RTF_NOFORWARD   0x1000		/* Forwarding inhibited.  */
#define RTF_THROW	0x2000		/* Go to next class.  */
#define RTF_NOPMTUDISC  0x4000		/* Do not send packets with DF.  */

/* for IPv6 */
#define RTF_DEFAULT	0x00010000	/* default - learned via ND	*/
#define RTF_ALLONLINK	0x00020000	/* fallback, no routers on link	*/
#define RTF_ADDRCONF	0x00040000	/* addrconf route - RA		*/

#define RTF_LINKRT	0x00100000	/* link specific - device match	*/
#define RTF_NONEXTHOP	0x00200000	/* route with no nexthop	*/

#define RTF_CACHE	0x01000000	/* cache entry			*/
#define RTF_FLOW	0x02000000	/* flow significant route	*/
#define RTF_POLICY	0x04000000	/* policy route			*/

#define RTCF_VALVE	0x00200000
#define RTCF_MASQ	0x00400000
#define RTCF_NAT	0x00800000
#define RTCF_DOREDIRECT 0x01000000
#define RTCF_LOG	0x02000000
#define RTCF_DIRECTSRC	0x04000000

#define RTF_LOCAL	0x80000000
#define RTF_INTERFACE	0x40000000
#define RTF_MULTICAST	0x20000000
#define RTF_BROADCAST	0x10000000
#define RTF_NAT		0x08000000

#define RTF_ADDRCLASSMASK	0xF8000000
#define RT_ADDRCLASS(flags)	((__u_int32_t) flags >> 23)

#define RT_TOS(tos)		((tos) & IPTOS_TOS_MASK)

#define RT_LOCALADDR(flags)	((flags & RTF_ADDRCLASSMASK) \
				 == (RTF_LOCAL|RTF_INTERFACE))

#define RT_CLASS_UNSPEC		0
#define RT_CLASS_DEFAULT	253

#define RT_CLASS_MAIN		254
#define RT_CLASS_LOCAL		255
#define RT_CLASS_MAX		255


#define RTMSG_ACK		NLMSG_ACK
#define RTMSG_OVERRUN		NLMSG_OVERRUN

#define RTMSG_NEWDEVICE		0x11
#define RTMSG_DELDEVICE		0x12
#define RTMSG_NEWROUTE		0x21
#define RTMSG_DELROUTE		0x22
#define RTMSG_NEWRULE		0x31
#define RTMSG_DELRULE		0x32
#define RTMSG_CONTROL		0x40

#define RTMSG_AR_FAILED		0x51	/* Address Resolution failed.  */

#endif /* net/route.h */
                                                                                                                                                                                                                                                                                                                                                     §-   .   _$   ..  •-  Ëipx.h                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /* Copyright (C) 1991, 92, 93, 95, 96, 97, 98 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef __NETIPX_IPX_H
#define __NETIPX_IPX_H 1

#include <features.h>

#include <sys/types.h>
#include <bits/sockaddr.h>

__BEGIN_DECLS

#define SOL_IPX    256          /* sockopt level */

#define IPX_TYPE        1
#define IPX_NODE_LEN	6
#define IPX_MTU		576

struct sockaddr_ipx
  {
    sa_family_t sipx_family;
    u_int16_t sipx_port;
    u_int32_t sipx_network;
    unsigned char sipx_node[IPX_NODE_LEN];
    u_int8_t sipx_type;
    unsigned char sipx_zero;	/* 16 byte fill */
  };

/*
 *	So we can fit the extra info for SIOCSIFADDR into the address nicely
 */

#define sipx_special	sipx_port
#define sipx_action	sipx_zero
#define IPX_DLTITF	0
#define IPX_CRTITF	1

typedef struct ipx_route_definition
  {
    unsigned long ipx_network;
    unsigned long ipx_router_network;
    unsigned char ipx_router_node[IPX_NODE_LEN];
  }
ipx_route_definition;

typedef struct ipx_interface_definition
  {
    unsigned long ipx_network;
    unsigned char ipx_device[16];
    unsigned char ipx_dlink_type;
#define IPX_FRAME_NONE		0
#define IPX_FRAME_SNAP		1
#define IPX_FRAME_8022		2
#define IPX_FRAME_ETHERII	3
#define IPX_FRAME_8023		4
#define IPX_FRAME_TR_8022	5
    unsigned